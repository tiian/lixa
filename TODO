Go on with liblixapq.c
- an interesting logical bug was discovered. For cold recovery, LIXA need to
  issue xa_commit/xa_rollback to the resource manager, but this could be
  performed only traversing "idle" state; "idle" state needs xa_start/xa_end,
  but in cold recovery no transaction can be started. The logical solution 
  seems to be implementing xa_start(TMRESUME) xa_end() and than xa_commit or
  xa_rollback could be called. But another problem arises: TMRESUME could be
  used by another transaction manager (if someone re-use the wrapper library)
  and it would be bugged because PostgreSQL does not implement it at the
  low level.
  This behavior should be tested against Oracle and DB2 too... I'm not sure
  they refuse xa_commit/xa_rollback: they are probably violating the XA
  state table protocol.
  Another dirty trick might be to create a flag: allowing xa_commit/xa_rollback
  after xa_recover... but it does not seem to me a brillian solution...
- lixa_pq_recover
- write a full case test for the PostgreSQL resource manager
- replace XID serialization with new implementation

When tx_rollback() is called, LIXA does not call xa_end(TMFAIL), but xa_end(TMSUCCESS); this is not
an error, but it does not inform the resource manager as soon as possible of the transaction manager
next action; try to change this piece of code of lixa_xa.c:
xa_end_flags=TMSUCCESS; (line 504)
with something like
if (commit)
  xa_end_flags=TMSUCCESS;
else
  xa_end_flags=TMFAIL;
A full regression test must be performed...

Try this scenario:
- a multithread application
- one thread connects to a resource manager like Oracle or DB2 using tx_open()
- after tx_open() the server crashes, for example in server_xa_start_24
- the thread calls tx_commit() after some native SQL update operations
- the server crashed, the thread receive TX_FAIL from the transaction manager
- the thread can not close the connection to the database using tx_close()
  because after TX_FAIL the transaction manager can no longer perform work on
  behalf of the application
- what happens with locks inside the database(s)?
- is it right to document the application must close the resource managers by
  itself after a TX_FAIL return code??
- is it sufficient thread termination to clean-up database(s) state(s)?
- generally tx_close() can not be executed: some times it may happen, some 
  times it can not work properly

Try what happens if lixax_conf.xml contains a profile without resource 
managers.

Document a memory leak introduced by libxml2:
xmlInitParser()
xmlCleanupParser()
must be called from the same thread (cite the thread/libxml2 URL).
If xmlCleanupParser() is called from a different thread, 1 block of 24 bytes
is definitely lost.
It seems the leak is limited to 24 bytes, but some critical pattern might
exploit a recursive behavior... :(
This could be an issue for some situations:
if the called functions are executed inside threads and the main program is the
transaction monitor itself, there is no way to assure the same thread called
xmlInitParser() is able to call xmlCleanupParser() too because the first thread
should remain locked until all the thread completed.
From a LIXA point of view, xmlInitParser() is called from the first thread
that calls tx_open() and xmlCleanupParser() is called from the last thread
that leaves tx_close(). The issue must be discussed with libxml2 development
team. Unfortunately, tx_open() can no be called from the main program and the
following functions from a different thread because this behavior would violate
XA standard: to avoid this issue a "proxy thread" should be used for XA
functions, but the "solution" is worst then the "problem".
If the multithreaded application has a main program - you are not writing a
library or a module - you can call
tx_open() in the main, before every thread is started
tx_close() in the main, after every thread is completed
this should avoid the memory leak. Pay attention the tx_open() at main level
is not inherited at the thread level: every thread must call its own tx_open()
too; this is only a workaround to force xmlInitParser() and xmlCleanupParser()
only at main program instead of at first starting thread / last ending thread.

After beta release, after interesting stuff like Python and PHP bindings, the 
custom containers developed for LIXA could be substituted with glib standard 
containers.
