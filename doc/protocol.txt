This file contains documentation related to the LIXA client/server protocol

The protocol is based on XML messages exchange.
No validation is performed against XML.
XML parsing is "static": only expected tags/attributes are searched and
retrieved.
XML generation is "static": from a composite struct, a serialization function
able to understand the struct, generates the resulting XML document.
The usage of XML is possibly not strictly compliant with standards; it's used
as a serialization/deserialization tool to avoid portability nightmares and
cross platform issues (server is big endian, client is little endian or server
is ASCII, client is EBCDIC...).

Every message must have two distinctive fields in the header:
- verb: the operation correlated to the data contained in the XML document
- step: the progress inside the operation
an optional field is
- level: the level of implemented protocol

This documentations contains: state tables for transitions of client/server
messages and some message samples.

***************************************************************************

verb=1 (xa_open)

  level: message level, version
  verb:  xa_open -> 1
  step:  8, 16, 24, ... as necessary

  client->server message (question)
  <msg level="1" verb="1" step="8">
    <client profile="VZ67"/>
    <rsrmgrs>
      <rsrmgr rmid="0" name="dummyrm" xa_name="lixa_dummyrm"/>
      <rsrmgr rmid="1" name="randomrm" xa_name="lixa_randomrm"/>
    </rsrmgrs>
  </msg>

  server -> client message (answer)
  <msg level="1" verb="1" step="16">
    <answer rc="0"/>
  </msg>

  client -> server message (async assertion)
  <msg level="1" verb="1" step="24">
    <conthr state="1"/>
    <xa_open_execs>
      <xa_open_exec xa_info="xa_open string" rmid="0" flags="0" rc="0" state="1"/>
      <xa_open_exec xa_info="xa_open string" rmid="1" flags="0" rc="0" state="1"/>
    </xa_open_execs>
  </msg>
  

client 			 server		description
verb=1,step=8 -->			send list of resource managers
	      				allocate blocks & synch
		<-- verb=1,step=16	confirm block allocation
verb=1,step=24 -->  			send list of executions of xa_open
	       				routine (store xa_open results on 
					transaction manager server)

***************************************************************************

verb=2 (xa_close)

  level: message level, version
  verb:  xa_close -> 2
  step:  8

  client->server message (async assertion)
  <msg verb="2" step="8">
    <rsrmgrs>
      <rsrmgr rmid="0"/>
      <rsrmgr rmid="1"/>
    </rsrmgrs>
  </msg>

client 			 server		description
verb=2,step=8 -->			send list of resource managers
	      				free now useless blocks

***************************************************************************

verb=3 (xa_start)

  level: message level, version
  verb:  xa_start -> 3
  step:  8, 16, 24, ... as necessary

  client->server message (send the XID - transaction id - and the resource
                          managers will receive xa_start)
  <msg level="1" verb="3" step="8">
    <conthr xid="xid string in ASCII form"/>
    <rsrmgrs>
      <rsrmgr rmid="0"/>
      <rsrmgr rmid="1"/>
    </rsrmgrs>
  </msg>

  server -> client message (answer)
  <msg level="1" verb="3" step="16">
    <answer rc="0"/>
  </msg>

  client -> server message (async assertion)
  <msg level="1" verb="3" step="24">
    <conthr state="?"/>
    <xa_start_execs>
      <xa_start_exec rmid="0" flags="0" rc="0" state="?"/>
      <xa_start_exec rmid="1" flags="0" rc="0" state="?"/>
    </xa_start_execs>
  </msg>

client 			 server		description
verb=3,step=8 -->			send XID (transaction id)
					send list of resource managers
	      				will receive xa_start
		<-- verb=3,step=16	synchronize status file
		    			confirm operation
verb=3,step=24 -->  			send list of executions of xa_start
	       				routine (store xa_start results and
					new states on transaction manager 
					server)

***************************************************************************


