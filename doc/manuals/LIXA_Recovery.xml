<chapter xml:id="Recovery">
  <title>Recovery</title> 
  <para>
    This chapter explains some advanced concepts that the LIXA system
    administrator should know to solve some complex issues the XA 
    technology could generate.
    LIXA technology provide two type of recovery:
    <itemizedlist mark="bullet">
      <listitem><para>
	  <emphasis>Automatic Recovery</emphasis>: 
	  it happens silently and rolls back or commits
	  the transactions that crashed before a consistent point had been
	  reached
      </para></listitem>
      <listitem><para>
	  <emphasis>Manual Recovery</emphasis>:
	  it is invoked by <command>lixar</command> utility
	  to solve the transactions that cannot be automatically recovered
      </para></listitem>
    </itemizedlist>	
  </para>
  <section>
    <title>Automatic (warm) recovery</title>
    <section>
      <title>Scenario 1: autonoumos rollback</title>
      <para>
	If your environment is configured and runs as designed, when an
	Application Program fails an automatic recovery operation fix the
	problem as soon as possible. Below there is a first trivial
	scenarios:
	<itemizedlist mark="bullet">
	  <listitem>
	    <para>the Application Program crashes before it reaches the
	      <function>xa_prepare()</function> function
	      (called by <function>tx_commit()</function>)
	    </para>
	  </listitem>
	  <listitem>
	    <para>the Resource Managers 
	      <emphasis>autonoumosly</emphasis> roll back the
	      work in progress and the environment is cleaned up</para>
	  </listitem>
	</itemizedlist>	
	the distributed transaction started but it did not initiated the
	two phase commit protocol: there is no relevant difference between
	this scenario and a single Resource Manager (one phase commit)
	scenario. The LIXA Transaction Manager does <emphasis>not</emphasis>
	manage a recovery phase.
	<figure xml:id="recover1">
	  <title>The Application Program crashes before <function>xa_prepare()</function></title>
	  <mediaobject>
	    <imageobject>
	      <imagedata fileref="LIXA_Recovery_01.png"/>
	    </imageobject>
	  </mediaobject>
	</figure>
      </para>
    </section>
    <section>
      <title>Scenario 2: a second Application Program triggers the recovery action</title>
      <para>
	The following scenario is slightly different:
	<itemizedlist mark="bullet">
	  <listitem>
	    <para>the Application Program crashes after it has passed the
	      <function>xa_prepare()</function> function but before it
	      reaches the <function>xa_commit()</function> function
	    </para>
	  </listitem>
	  <listitem>
	    <para>the Resource Managers keep the <emphasis>prepared</emphasis>
	    transaction <quote>in flight</quote> until the Transaction
	    Manager decides the proper recovery action</para>
	  </listitem>
	  <listitem>
	    <para>an <quote>equivalent</quote> Application Program starts 
	      and activates
	      the LIXA Transaction Manager with <function>tx_open()</function>
	    </para>
	  </listitem>
	  <listitem>
	    <para>the LIXA Transaction Manager discovers there is a
	      <emphasis>prepared</emphasis> transaction and establishes that
	      it must commit the transaction
	    </para>
	  </listitem>
	  <listitem>
	    <para>the second Application Program implicitly and inconsciously
	    started the recovery process of a previously crashed
	    Application Program</para>
	  </listitem>
	</itemizedlist>	
	<figure xml:id="recover2">
	  <title>The Application Program crashes after <function>xa_prepare()</function></title>
	  <mediaobject>
	    <imageobject>
	      <imagedata fileref="LIXA_Recovery_02.png"/>
	    </imageobject>
	  </mediaobject>
	</figure>
	The above pattern is the result of the LIXA design: the Transaction
	Manager is not an active component, but it's a passive one and
	is embedded in the Application Program when it links the
	<systemitem class="library">lixac</systemitem> library 
	and activates it with the
	<function>tx_open()</function> function.
      </para>
      <note><para>
	  Depending on the crash time: slightly before the 
	  <emphasis>prepare phase</emphasis>,
	  in the middle of the <emphasis>prepare phase</emphasis>,
	  after the completion of the <emphasis>prepare phase</emphasis>, 
	  the LIXA Transaction Manager chooses a different recovery 
	  operation between
	  <function>xa_commit()</function> and 
	  <function>xa_rollback()</function>.
      </para></note>
    </section>
  </section>
  <section xml:id="Automatic_recovery_concepts">
    <title>Automatic recovery concepts</title>
    <para>
      Automatic (warm) recovery uses the information stored inside the
      LIXA state server to decide which transaction must be recovered and
      how it should be completed (committed or rolled back).
    </para>
    <para>
      The above paragraphs explain what's happen when automatic recovery
      starts and completes (rolls back or commits) the transaction marked
      as <quote>recovery pending</quote>.
    </para>
    <para>
      <foreignphrase>
	An <quote>equivalent</quote> Application Program starts and activates
	the LIXA Transaction Manager with <function>tx_open()</function>.
	The LIXA Transaction Manager autonoumosly coordinates the transaction
	completion and the Application Program is not aware of this
	<quote>under the covers</quote> operation.
      </foreignphrase>
    </para>
    <section xml:id="Application_Program_equivalence">
      <title>Application Program equivalence</title>
      <para>
	From the LIXA Transaction Manager point of view,
	two Application Programs are
	equivalent when they are associated to the same 
	<emphasis>job</emphasis>.
      </para>
      <para>
	The job associated to an Application Program can be:
	<itemizedlist mark="bullet">
	  <listitem>
	    <para>
	      the content of the environment variable 
	      <varname>LIXA_JOB</varname> if it is set
	    </para>
	  </listitem>
	  <listitem>
	    <para>
	      a string computed in this way if the environment variable 
	      <varname>LIXA_JOB</varname> is <emphasis>not</emphasis> set:
	      <para>
		<varname>branch qualifier</varname> + 
		<quote>/</quote> + 
		<systemitem class="ipaddress">IP address</systemitem>
	      </para>
	      where <varname>branch qualifier</varname> is computed as:
	      <para>
		<function>MD5</function>(<filename>lixac_conf.xml</filename> + 
		$(<varname>LIXA_PROFILE</varname>) +
		<function>gethostid()</function>)
	      </para>
	    </para>
	  </listitem>
	</itemizedlist>
	An example of <varname>branch qualifier</varname> is
	<quote>0fc29445b1d4c3f4ed6be2fea20f918b</quote>, while an example of
	job automatically associated to an Application Program is
	<quote>0fc29445b1d4c3f4ed6be2fea20f918b/127.0.0.1</quote>
      </para>
      <note><para>
	  If you don't set the environment variable 
	  <varname>LIXA_JOB</varname> all the Application Programs that
	  meet this requirements:
	  <itemizedlist mark="bullet">
	    <listitem><para>
		they use a config file (<filename>lixac_conf.xml</filename>)
		with the same content
	    </para></listitem>
	    <listitem><para>
		they use a <varname>LIXA_PROFILE</varname> environment variable
		with the same content
	    </para></listitem>
	    <listitem><para>
		they run in a host that returns the same value to
		<function>gethostid()</function> function		
	    </para></listitem>
	    <listitem><para>
		they are calling the LIXA state server from the same 
		IP address	
	    </para></listitem>
	  </itemizedlist>
	  <emphasis>are associated to the same job</emphasis>.
      </para></note>
      <para>
	To pick-up the job associated to an Application Program you can
	activate the trace using the bit associated to the label
	<quote>LIXA_TRACE_MOD_CLIENT_CONFIG</quote>. Take a look to
	<xref linkend="Tracing_modules"/> for more information.
	This is an excerpt from the trace:
	<screen>
[...]	  
2011-12-03 17:00:59.746036 [6021/1078050640] client_config_job
2011-12-03 17:00:59.746073 [6021/1078050640] client_config_job: acquiring exclusive mutex
2011-12-03 17:00:59.746120 [6021/1078050640] client_config_job: 'LIXA_JOB' environment variable not found, computing job string...
2011-12-03 17:00:59.746175 [6021/1078050640] lixa_job_set_source_ip
2011-12-03 17:00:59.746275 [6021/1078050640] lixa_job_set_source_ip/excp=1/ret_cod=0/errno=0
2011-12-03 17:00:59.746339 [6021/1078050640] client_config_job: job value for this process is '0fc29445b1d4c3f4ed6be2fea20f918b/127.0.0.1      '
2011-12-03 17:00:59.746379 [6021/1078050640] client_config_job: releasing exclusive mutex
2011-12-03 17:00:59.746514 [6021/1078050640] client_config_job/excp=3/ret_cod=0/errno=0
[...]
	</screen>
	<important><para>
	    Setting the environment variable <varname>LIXA_JOB</varname>
	    allows you to associate any Application Program to a custom
	    user defined job: this may be interesting if you are using a
	    workload balanced environment, this may be dangerous if you
	    associate Application Programs using a different set of
	    Resource Managers to the same job.
	</para></important>
      </para>
      <para>
	If you don't set <varname>LIXA_JOB</varname> environment variable,
	the default behavior should be strong enought to avoid issues when
	LIXA is used under <quote>standard</quote> conditions.
      </para>
    </section>
    <section>
      <title>Automatic Recovery in a distributed environment</title>
      <para>
	The previous section (see 
	<xref linkend="Application_Program_equivalence"/>) explains the
	conditions that must be met to enable automatic recovery.
	A tipical scenario that needs tuning is a workload balanced
	Application Server environment as is in the below picture:
	<figure xml:id="recover3">
	  <title>Workload balanced Application Server</title>
	  <mediaobject>
	    <imageobject>
	      <imagedata fileref="LIXA_Recovery_03.png"/>
	    </imageobject>
	  </mediaobject>
	</figure>
	The same program (<quote>Application Program 1</quote>) is
	executed by two different Application Servers: this is a typical
	configuration used to improve service availability and scalability.
	If the Application Server 1 is running in a different host than
	Application Server 2 (this is a de facto standard), by default 
	LIXA will
	associate <emphasis>two different jobs.</emphasis>
      </para>
      <important><para>
	  The LIXA default behavior is not the optimal one when you are
	  using a workload balanced environment.
	</para>
	<para>
	  If the host of Application Server 1 crashed, the Application Program
	  running inside Application Server 2
	  could not automatically recover the transactions in 
	  <quote>prepared/in-doubt/recovery pending</quote> of the
	  Application Server 1 because they are associated to a different
	  <emphasis>job</emphasis>.
	</para>
	<para>
	  This is a scenario when setting <varname>LIXA_JOB</varname> is
	  <emphasis>strongly</emphasis> suggested.
      </para></important>
      <warning><para>
	  When you set the <varname>LIXA_JOB</varname> environment variable
	  to control LIXA automatic recovery feature you 
	  <emphasis>must not</emphasis> associate the same job to 
	  Application Programs that use different sets of Resource Managers
	  or use the same set of Resource Managers but with different
	  options for any Resource Manager.
	  If you broke this rule, you would probably face difficult to 
	  troubleshoot issues: automatic recovery could fail and you
	  would have to understand why.
      </para></warning>
    </section>
    <section xml:id="Forcing_automatic_recovery">
      <title>Forcing automatic recovery</title>
      <para>
	Sometimes you need to force the automatic recovery to happen because
	the crashed Applicaton Program is a <quote>one shot</quote> program
	and you can not execute it a second time due to some functional
	constrain.
      </para>
      <para>
	Any application program meeting the requirements described above can
	be used, <command>lixat</command> utility command too. The following
	example will show you how it works using PostgreSQL and Oracle
	Resource Managers.
      </para>
      <para>
	First of all, you must configure, build and install the LIXA project
	software enabling PostgreSQL, Oracle and crash simulation features:
	<screen>
tiian@ubuntu:~/lixa$ ./configure --with-oracle=/usr/lib/oracle/xe/app/oracle/product/10.2.0/server \
> --with-postgresql-include=/usr/include/postgresql --with-postgresql-lib=/usr/lib \
> --enable-crash
	</screen>
	then you must follow the steps described in 
	<xref linkend="Development_example6_pql_ora"/>
	to prepare the scenario environment.
	Open three different terminal sessions as explained in the above
	example, and try to insert/delete a row:
	<table frame="box">
	  <thead><tr><td>[Shell terminal session]</td></tr></thead>
	  <tbody><tr><td><screen>
tiian@ubuntu:~/tmp$ echo $LIXA_PROFILE
PQL_STA_ORA_DYN
tiian@ubuntu:~/tmp$ echo $ORACLE_HOME
/usr/lib/oracle/xe/app/oracle/product/10.2.0/server
tiian@ubuntu:~/tmp$ echo $ORACLE_SID
XE
tiian@ubuntu:~/tmp$ echo $LD_LIBRARY_PATH
/usr/lib/oracle/xe/app/oracle/product/10.2.0/server/lib::/opt/lixa/lib
tiian@ubuntu:~/tmp$ ./example6_pql_ora insert
Inserting a row in the tables...
Oracle INSERT statement executed!
tiian@ubuntu:~/tmp$ ./example6_pql_ora delete
Deleting a row from the tables...
Oracle DELETE statement executed!
	  </screen></td></tr></tbody>
	</table>
	To simulate a crash after the <function>xa_prepare()</function>
	completed successfully, you can set the environment variable
	<varname>LIXA_CRASH_POINT</varname> to the value
	<constant>LIXA_CRASH_POINT_PREPARE_2</constant>
	(see <filename>src/common/lixa_crash.h</filename>:
	<table frame="box">
	  <thead><tr><td>[Shell terminal session]</td></tr></thead>
	  <tbody><tr><td><screen>
tiian@ubuntu:~/tmp$ export LIXA_CRASH_POINT=15
tiian@ubuntu:~/tmp$ echo $LIXA_CRASH_POINT
15
tiian@ubuntu:~/tmp$ ./example6_pql_ora insert
Inserting a row in the tables...
Oracle INSERT statement executed!
Aborted
	  </screen></td></tr></tbody>
	</table>
	You can check there is a prepared (in-doubt) transaction inside Oracle:
	<table frame="box">
	  <thead><tr><td>[Oracle terminal session]</td></tr></thead>
	  <tbody><tr><td><screen>
SQL> select * from dba_pending_transactions;

  FORMATID
----------
GLOBALID
--------------------------------------------------------------------------------
BRANCHID
--------------------------------------------------------------------------------
1279875137
97DD30A150604AFDBFA5FDC94B611FD5
9BAC7BE1C129EA6EE31F2D71B318120C
	  </screen></td></tr></tbody>
	</table>
	And the same transaction inside PostgreSQL:
	<table frame="box">
	  <thead><tr><td>[PostgreSQL terminal session]</td></tr></thead>
	  <tbody><tr><td><screen>
testdb=> select * from pg_prepared_xacts;
 transaction |                                    gid                                     |           prepared            | owner | database 
-------------+----------------------------------------------------------------------------+-------------------------------+-------+----------
         874 | 1279875137.97dd30a150604afdbfa5fdc94b611fd5.9bac7be1c129ea6ee31f2d71b318120c | 2011-12-14 22:02:50.462682+01 | tiian | testdb
	  </screen></td></tr></tbody>
	</table>
	It is suggested to activate the trace related to the 
	<quote>client recovery</quote>
	module (see <xref linkend="Tracing_modules"/>)
	before running <command>lixat</command> program:
	<table frame="box">
	  <thead><tr><td>[Shell terminal session]</td></tr></thead>
	  <tbody><tr><td><screen>
tiian@ubuntu:~/tmp$ export LIXA_TRACE_MASK=0x00040000
tiian@ubuntu:~/tmp$ /opt/lixa/bin/lixat 
2011-12-14 22:22:01.740634 [27735/3073944240] client_recovery
2011-12-14 22:22:01.740771 [27735/3073944240] client_recovery: sending 197 bytes ('000191&lt;?xml version="1.0" encoding="UTF-8" ?&gt;&lt;msg level="0" verb="8" step="8"&gt;&lt;client job="9bac7be1c129ea6ee31f2d71b318120c/127.0.0.1      " config_digest="9bac7be1c129ea6ee31f2d71b318120c"/&gt;&lt;/msg&gt;') to the server for step 8
2011-12-14 22:22:01.759352 [27735/3073944240] client_recovery: receiving 561 bytes from the server |&lt;?xml version="1.0" encoding="UTF-8" ?&gt;&lt;msg level="0" verb="8" step="16"&gt;&lt;answer rc="0"/&gt;&lt;client job="9bac7be1c129ea6ee31f2d71b318120c/127.0.0.1      " config_digest="9bac7be1c129ea6ee31f2d71b318120c"&gt;&lt;last_verb_step verb="5" step="16"/&gt;&lt;state finished="0" txstate="3" will_commit="1" will_rollback="0" xid="1279875137.97dd30a150604afdbfa5fdc94b611fd5.9bac7be1c129ea6ee31f2d71b318120c"/&gt;&lt;/client&gt;&lt;rsrmgrs&gt;&lt;rsrmgr rmid="0" next_verb="0" r_state="1" s_state="33" td_state="10"/&gt;&lt;rsrmgr rmid="1" next_verb="0" r_state="1" s_state="33" td_state="20"/&gt;&lt;/rsrmgrs&gt;&lt;/msg&gt;|
2011-12-14 22:22:01.759776 [27735/3073944240] client_recovery_analyze
2011-12-14 22:22:01.759857 [27735/3073944240] client_recovery_analyze: the TX was committing
2011-12-14 22:22:01.759873 [27735/3073944240] client_recovery_analyze: rmid=0, r_state=1, s_state=33, td_state=10
2011-12-14 22:22:01.759884 [27735/3073944240] client_recovery_analyze: rmid=1, r_state=1, s_state=33, td_state=20
2011-12-14 22:22:01.759902 [27735/3073944240] client_recovery_analyze/excp=1/ret_cod=0/errno=0
2011-12-14 22:22:01.759921 [27735/3073944240] client_recovery: transaction '1279875137.97dd30a150604afdbfa5fdc94b611fd5.9bac7be1c129ea6ee31f2d71b318120c' must be committed
2011-12-14 22:22:01.759937 [27735/3073944240] client_recovery_commit
2011-12-14 22:22:01.759971 [27735/3073944240] client_recovery_commit: committing transaction '1279875137.97dd30a150604afdbfa5fdc94b611fd5.9bac7be1c129ea6ee31f2d71b318120c'
2011-12-14 22:22:01.759998 [27735/3073944240] client_recovery_commit: xa_commit for rmid=0, name='PostgreSQL_stareg', xa_name='PostgreSQL[LIXA]'...
2011-12-14 22:22:02.143764 [27735/3073944240] client_recovery_commit: rc=0
2011-12-14 22:22:02.143866 [27735/3073944240] client_recovery_commit: xa_commit for rmid=1, name='OracleXE_dynreg', xa_name='Oracle_XA'...
2011-12-14 22:22:03.188211 [27735/3073944240] client_recovery_commit: rc=0
2011-12-14 22:22:03.188272 [27735/3073944240] client_recovery_commit/excp=1/ret_cod=0/errno=0
2011-12-14 22:22:03.188318 [27735/3073944240] client_recovery: sending 187 bytes ('000181&lt;?xml version="1.0" encoding="UTF-8" ?&gt;&lt;msg level="0" verb="8" step="24"&gt;&lt;recovery failed="0" commit="1"/&gt;&lt;rsrmgrs&gt;&lt;rsrmgr rmid="0" rc="0"/&gt;&lt;rsrmgr rmid="1" rc="0"/&gt;&lt;/rsrmgrs&gt;&lt;/msg&gt;') to the server for step 24
2011-12-14 22:22:03.188496 [27735/3073944240] client_recovery: sending 197 bytes ('000191&lt;?xml version="1.0" encoding="UTF-8" ?&gt;&lt;msg level="0" verb="8" step="8"&gt;&lt;client job="9bac7be1c129ea6ee31f2d71b318120c/127.0.0.1      " config_digest="9bac7be1c129ea6ee31f2d71b318120c"/&gt;&lt;/msg&gt;') to the server for step 8
2011-12-14 22:22:03.228361 [27735/3073944240] client_recovery: receiving 95 bytes from the server |&lt;?xml version="1.0" encoding="UTF-8" ?&gt;&lt;msg level="0" verb="8" step="16"&gt;&lt;answer rc="1"/&gt;&lt;/msg&gt;|
2011-12-14 22:22:03.228544 [27735/3073944240] client_recovery: the server answered LIXA_RC_OBJ_NOT_FOUND; there are no more transactions to recover
2011-12-14 22:22:03.228589 [27735/3073944240] client_recovery/excp=12/ret_cod=0/errno=0
tx_open(): 0
tx_close(): 0
	  </screen></td></tr></tbody>
	</table>
	You can now verify there are no more 
	<emphasis>prepared/in-doubt</emphasis> transactions inside the
	Resource Managers:
	<table frame="box">
	  <thead><tr><td>[Oracle terminal session]</td></tr></thead>
	  <tbody><tr><td><screen>
SQL> select * from dba_pending_transactions;

no rows selected
	  </screen></td></tr></tbody>
	</table>
	<table frame="box">
	  <thead><tr><td>[PostgreSQL terminal session]</td></tr></thead>
	  <tbody><tr><td><screen>
testdb=> select * from pg_prepared_xacts;
 transaction | gid | prepared | owner | database 
-------------+-----+----------+-------+----------
(0 rows)
	  </screen></td></tr></tbody>
	</table>
	<important><para>
	    The automatic (warm) recovery process completed successfully
	    because <command>./example6_pql_ora</command> and
	    <command>/opt/lixa/bin/lixat</command> were associated to 
	    <emphasis>the same job</emphasis> and the LIXA state server
	    (<command>lixad</command>) kept the state of the transaction in
	    the meanwhile.
	</para></important>
	In the next paragraphs you can explore what happens if the previous
	conditions are not satisfied.
      </para>
    </section>
  </section>
  <section>
    <title>Manual (cold) recovery</title>
    <para>
      Manual (cold) recovery uses the information provided by the
      Resource Managers querying them using 
      <function>xa_recover()</function>.
      This type of recovery should be used to resolve some unusual
      situations.
    </para>
    <para>
      If, for any reason, the LIXA state server (<command>lixad</command>)
      forgot the state of a transaction
      <footnote><para>
	  This should never happen: it could be a bug in LIXA project
	  software or it might be the consequence of a 
	  <quote>cold start</quote> (you removed the state files) of
	  <command>lixad</command>
      </para></footnote>
      or the transaction is in state <quote>recovery failed</quote> because
      a previous automatic (warm) recovery failed, you have to manually
      recover the transaction.
      The procedure to recover a <quote>forgotten</quote> transaction is 
      the same you use to recover a <quote>recovery failed</quote> one, 
      but additional server side clean-up is suggested for 
      <quote>recovery failed</quote> transactions.
    </para>
    <section xml:id="Recoverying_forgotten_transactions">
      <title>Recoverying forgotten transactions</title>
      <para>
	This example necessitates of the same environment set-up in
	<xref linkend="Forcing_automatic_recovery"/>; you must start running
	the example program after you enabled the 
	<varname>LIXA_CRASH_POINT</varname> environment variable:
	<table frame="box">
	  <thead><tr><td>[Shell terminal session]</td></tr></thead>
	  <tbody><tr><td><screen>
tiian@ubuntu:~/tmp$ export LIXA_CRASH_POINT=15
tiian@ubuntu:~/tmp$ echo $LIXA_CRASH_POINT
15
tiian@ubuntu:~/tmp$ ./example6_pql_ora insert
Deleting a row from the tables...
Oracle DELETE statement executed!
Aborted
	  </screen></td></tr></tbody>
	</table>
	and check there is a recovery pending transaction inside PostgreSQL
	and Oracle Resource Managers:
	<table frame="box">
	  <thead><tr><td>[Oracle terminal session]</td></tr></thead>
	  <tbody><tr><td><screen>
SQL> select * from dba_pending_transactions;

  FORMATID
----------
GLOBALID
--------------------------------------------------------------------------------
BRANCHID
--------------------------------------------------------------------------------
1279875137
957747F7F37B439EBCEA4146076AD322
9BAC7BE1C129EA6EE31F2D71B318120C
	  </screen></td></tr></tbody>
	</table>
	<table frame="box">
	  <thead><tr><td>[PostgreSQL terminal session]</td></tr></thead>
	  <tbody><tr><td><screen>
testdb=> select * from pg_prepared_xacts;
 transaction |                                    gid                                     |           prepared            | owner | database 
-------------+----------------------------------------------------------------------------+-------------------------------+-------+----------
         877 | 1279875137.957747f7f37b439ebcea4146076ad322.9bac7be1c129ea6ee31f2d71b318120c | 2011-12-14 22:55:14.973443+01 | tiian | testdb
	  </screen></td></tr></tbody>
	</table>
	Then you should stop and cold start the <command>lixad</command> 
	state server:
	<table frame="box">
	  <thead><tr><td>[Shell terminal session]</td></tr></thead>
	  <tbody><tr><td><screen>
tiian@ubuntu:~/tmp$ sudo su - lixa
lixa@ubuntu:~$ ps -ef|grep lixad|grep -v grep
lixa     24437     1  0 21:19 ?        00:00:00 /opt/lixa/sbin/lixad --daemon
lixa@ubuntu:~$ pkill lixad
lixa@ubuntu:~$ ps -ef|grep lixad|grep -v grep
lixa@ubuntu:~$ ls /opt/lixa/var/
lixad_status1_1  lixad_status2_1  lixad_status3_1  README
lixad_status1_2  lixad_status2_2  lixad_status3_2
lixa@ubuntu:~$ rm /opt/lixa/var/lixad_status*
lixa@ubuntu:~$ ls /opt/lixa/var/
README
lixa@ubuntu:~$ /opt/lixa/sbin/lixad --daemon
lixa@ubuntu:~$ ps -ef|grep lixad|grep -v grep
lixa     28594     1  0 23:00 ?        00:00:00 /opt/lixa/sbin/lixad --daemon
lixa@ubuntu:~$ ls /opt/lixa/var/
lixad_status1_1  lixad_status2_1  lixad_status3_1  README
lixad_status1_2  lixad_status2_2  lixad_status3_2  run.pid
lixa@ubuntu:~$ exit
logout
	  </screen></td></tr></tbody>
	</table>
	These are the operations you just performed:
	<itemizedlist mark="bullet">
	  <listitem><para>
	      changed the user from your own to 
	      <systemitem class="username">lixa</systemitem> user
	  </para></listitem>
	  <listitem><para>
	      checked the <command>lixad</command> daemon was running
	  </para></listitem>
	  <listitem><para>
	      stopped the <command>lixad</command> daemon
	  </para></listitem>
	  <listitem><para>
	      checked the <command>lixad</command> daemon was not running
	  </para></listitem>
	  <listitem><para>
	      checked the <command>lixad</command>'s state files
	  </para></listitem>
	  <listitem><para>
	      removed the <command>lixad</command>'s state files
	  </para></listitem>
	  <listitem><para>
	      started the <command>lixad</command> daemon
	  </para></listitem>
	  <listitem><para>
	      checked the new <command>lixad</command>'s state files
	  </para></listitem>
	</itemizedlist>
	Running <command>lixat</command> does <emphasis>not</emphasis>
	automatically recover the transaction:
	<table frame="box">
	  <thead><tr><td>[Shell terminal session]</td></tr></thead>
	  <tbody><tr><td><screen>
tiian@ubuntu:~/tmp$ export LIXA_TRACE_MASK=0x00040000
tiian@ubuntu:~/tmp$ /opt/lixa/bin/lixat 
tx_open(): 0
tx_close(): 0
	  </screen></td></tr></tbody>
	</table>
	<note><para>
	    The program does not produce trace because
	    <quote>client recovery</quote> module is not called (the 
	    state server does not pass information about recovery 
	    pending transactions to the LIXA client library).
	</para></note>
	<table frame="box">
	  <thead><tr><td>[Oracle terminal session]</td></tr></thead>
	  <tbody><tr><td><screen>
SQL> select * from dba_pending_transactions;

  FORMATID
----------
GLOBALID
--------------------------------------------------------------------------------
BRANCHID
--------------------------------------------------------------------------------
1279875137
957747F7F37B439EBCEA4146076AD322
9BAC7BE1C129EA6EE31F2D71B318120C
	  </screen></td></tr></tbody>
	</table>
	<table frame="box">
	  <thead><tr><td>[PostgreSQL terminal session]</td></tr></thead>
	  <tbody><tr><td><screen>
testdb=> select * from pg_prepared_xacts;
 transaction |                                    gid                                     |           prepared            | owner | database 
-------------+----------------------------------------------------------------------------+-------------------------------+-------+----------
         877 | 1279875137.957747f7f37b439ebcea4146076ad322.9bac7be1c129ea6ee31f2d71b318120c | 2011-12-14 22:55:14.973443+01 | tiian | testdb
	  </screen></td></tr></tbody>
	</table>
	The <command>lixar</command> utility program with <option>-p</option>
	option can be used to list the prepared transactions that can not be
	automatically recovered:
	<table frame="box">
	  <thead><tr><td>[Shell terminal session]</td></tr></thead>
	  <tbody><tr><td><screen>
tiian@ubuntu:~/tmp$ /opt/lixa/bin/lixar -p
Execution options:
	- print report = yes
	- transaction(s) will be committed = no
	- transaction(s) will be rolled back = no
	- bypass xid branch qualifier check = no
	- bypass xid format id check = no
	- use TMENDRSCAN flag for last xa_recover call = no

Recovery environment:
LIXA_CONFIG_FILE_ENV_VAR = '(null)'
LIXA_PROFILE_ENV_VAR = 'PQL_STA_ORA_DYN'
LIXA_JOB_ENV_VAR = '(null)'

Resource manager list:
rmid=0, lixa_name='PostgreSQL_stareg', xa_name='PostgreSQL[LIXA]'
rmid=1, lixa_name='OracleXE_dynreg', xa_name='Oracle_XA'

Prepared and in-doubt transaction list:
xid='1279875137.957747f7f37b439ebcea4146076ad322.9bac7be1c129ea6ee31f2d71b318120c': rmid=0 rmid=1 
	  </screen></td></tr></tbody>
	</table>
	it reports some useful information and at the bottom there is the
	list of in-doubt transactions. 
	The transaction is prepared/in-doubt for both Resource Managers;
	sometimes it may be only for a subset of the Resource Managers
	defined by <varname>LIXA_PROFILE</varname>.
	You can manually recover the transaction using
	the <option>-x</option> and <option>-r</option> (rollback) or
	<option>-c</option> (commit):
	<table frame="box">
	  <thead><tr><td>[Shell terminal session]</td></tr></thead>
	  <tbody><tr><td><screen>
tiian@ubuntu:~/tmp$ /opt/lixa/bin/lixar -p -x 1279875137.957747f7f37b439ebcea4146076ad322.9bac7be1c129ea6ee31f2d71b318120c -r
Execution options:
	- print report = yes
	- transaction to commit/rollback = 1279875137.957747f7f37b439ebcea4146076ad322.9bac7be1c129ea6ee31f2d71b318120c
	- transaction(s) will be committed = no
	- transaction(s) will be rolled back = yes
	- bypass xid branch qualifier check = no
	- bypass xid format id check = no
	- use TMENDRSCAN flag for last xa_recover call = no

Recovery environment:
LIXA_CONFIG_FILE_ENV_VAR = '(null)'
LIXA_PROFILE_ENV_VAR = 'PQL_STA_ORA_DYN'
LIXA_JOB_ENV_VAR = '(null)'

Resource manager list:
rmid=0, lixa_name='PostgreSQL_stareg', xa_name='PostgreSQL[LIXA]'
rmid=1, lixa_name='OracleXE_dynreg', xa_name='Oracle_XA'

Prepared and in-doubt transaction list:
xid='1279875137.957747f7f37b439ebcea4146076ad322.9bac7be1c129ea6ee31f2d71b318120c': rmid=0 rmid=1 

Analizing transaction '1279875137.957747f7f37b439ebcea4146076ad322.9bac7be1c129ea6ee31f2d71b318120c':
xa_rollback --&gt; rmid=0, lixa_name='PostgreSQL_stareg', xa_name='PostgreSQL[LIXA]', rc=0
xa_rollback --&gt; rmid=1, lixa_name='OracleXE_dynreg', xa_name='Oracle_XA', rc=0
	  </screen></td></tr></tbody>
	</table>
	You can now verify there are no prepared/in-doubt transactions 
	inside the Resource Managers:
	<table frame="box">
	  <thead><tr><td>[Oracle terminal session]</td></tr></thead>
	  <tbody><tr><td><screen>
SQL> select * from dba_pending_transactions;

no rows selected
	  </screen></td></tr></tbody>
	</table>
	<table frame="box">
	  <thead><tr><td>[PostgreSQL terminal session]</td></tr></thead>
	  <tbody><tr><td><screen>
testdb=> select * from pg_prepared_xacts;
 transaction | gid | prepared | owner | database 
-------------+-----+----------+-------+----------
(0 rows)
	  </screen></td></tr></tbody>
	</table>
	We rolled back the deletion so the rows must be in place:
	<table frame="box">
	  <thead><tr><td>[Oracle terminal session]</td></tr></thead>
	  <tbody><tr><td><screen>
SQL> select * from COUNTRIES where COUNTRY_ID = 'RS';

COUNTR
------
COUNTRY_NAME
--------------------------------------------------------------------------------
 REGION_ID
----------
RS
Repubblica San Marino
	 1
	  </screen></td></tr></tbody>
	</table>
	<table frame="box">
	  <thead><tr><td>[PostgreSQL terminal session]</td></tr></thead>
	  <tbody><tr><td><screen>
testdb=> select * from AUTHORS;
 id | last_name | first_name 
----+-----------+------------
  1 | Foo       | Bar
	  </screen></td></tr></tbody>
	</table>
	You can retrieve some help from <command>lixar</command> with
	<option>-?</option> option:
	<table frame="box">
	  <thead><tr><td>[Shell terminal session]</td></tr></thead>
	  <tbody><tr><td><screen>
tiian@ubuntu:~/tmp$ /opt/lixa/bin/lixar -?
Usage:
  lixar [OPTION...] - LIXA recovery utility

Help Options:
  -?, --help                      Show help options

Application Options:
  -p, --print                     Print a report of all the prepared and in-doubt transactions compatible with current configuration and profile
  -x, --xid                       Select specified transaction for rollback/commit
  -X, --xid-file                  Select specified file as a list of transaction to rollback/commit
  -c, --commit                    Commit prepared &amp; in-doubt transactions
  -r, --rollback                  Rollback prepared &amp; in-doubt transactions
  -v, --version                   Print package info and exit
  -b, --bypass-bqual-check        Bypass xid branch qualifier check
  -B, --bypass-formatid-check     Bypass xid format id check
  -e, --use-tmendrscan-flag       Use TMENDRSCAN flag for last xa_recover call
	  </screen></td></tr></tbody>
	</table>
      </para>
    </section>
    <section>
      <title>Recoverying a <quote>recovery failed</quote> transaction</title>
      <para>
	This example is quite complex because a 
	<quote>recovery failed</quote> transaction is unlikely.
	To create a <quote>recovery failed</quote> transaction we 
	will use a special
	Resource Manager, the <quote>LIXA monkey</quote> one: it's a
	R.M. we can <quote>program</quote> to answer the Transaction Manager
	as we desire. We will emulate an heuristically completed transaction
	to force the LIXA Transaction Manager marking it as
	<quote>recovery failed</quote>.
      </para>
      <para>
	Before we can start, you must set-up the same environment already 
	explained in <xref linkend="Recoverying_forgotten_transactions"/>.
	Open three terminals session and prepare the sessions as shown
	below:
	<table frame="box">
	  <thead><tr><td>[Shell terminal session]</td></tr></thead>
	  <tbody><tr><td><screen>
tiian@ubuntu:~/tmp$ . /usr/lib/oracle/xe/app/oracle/product/10.2.0/server/bin/oracle_env.sh
tiian@ubuntu:~/tmp$ echo $ORACLE_HOME
/usr/lib/oracle/xe/app/oracle/product/10.2.0/server
tiian@ubuntu:~/tmp$ echo $ORACLE_SID
XE
tiian@ubuntu:~/tmp$ export LIXA_PROFILE=MON_STA_PQL_STA_ORA_DYN
tiian@ubuntu:~/tmp$ echo $LIXA_PROFILE
MON_STA_PQL_STA_ORA_DYN
tiian@ubuntu:~/tmp$ echo $LD_LIBRARY_PATH
/usr/lib/oracle/xe/app/oracle/product/10.2.0/server/lib:
tiian@ubuntu:~/tmp$ export LD_LIBRARY_PATH=$LD_LIBRARY_PATH:/opt/lixa/lib
tiian@ubuntu:~/tmp$ echo $LD_LIBRARY_PATH
/usr/lib/oracle/xe/app/oracle/product/10.2.0/server/lib::/opt/lixa/lib
	  </screen></td></tr></tbody>
	</table>
	The specified <varname>LIXA_PROFILE</varname> points to a
	configuration with three Resource Managers: LIXA Monkey (a fake
	R.M.), PostgreSQL (static registration) and Oracle DBMS (dynamic
	registration).
	<table frame="box">
	  <thead><tr><td>[Oracle terminal session]</td></tr></thead>
	  <tbody><tr><td><screen>
tiian@ubuntu:~$ . /usr/lib/oracle/xe/app/oracle/product/10.2.0/server/bin/oracle_env.sh
tiian@ubuntu:~$ sqlplus "hr/hr"

SQL*Plus: Release 10.2.0.1.0 - Production on Ven Dic 16 16:15:23 2011

Copyright (c) 1982, 2005, Oracle.  All rights reserved.


Connesso a:
Oracle Database 10g Express Edition Release 10.2.0.1.0 - Production

SQL> select * from COUNTRIES where COUNTRY_ID = 'RS';

no rows selected
	  </screen></td></tr></tbody>
	</table>
	<table frame="box">
	  <thead><tr><td>[PostgreSQL terminal session]</td></tr></thead>
	  <tbody><tr><td><screen>
tiian@ubuntu:~$ psql testdb
Welcome to psql 8.3.16, the PostgreSQL interactive terminal.

Type:  \copyright for distribution terms
       \h for help with SQL commands
       \? for help with psql commands
       \g or terminate with semicolon to execute query
       \q to quit

testdb=> SELECT * FROM authors;
 id | last_name | first_name 
----+-----------+------------
(0 rows)
	  </screen></td></tr></tbody>
	</table>
	Start the LIXA state server if it's not active:
	<table frame="box">
	  <thead><tr><td>[Shell terminal session]</td></tr></thead>
	  <tbody><tr><td><screen>
tiian@ubuntu:~/tmp$ sudo su - lixa
lixa@ubuntu:~$ /opt/lixa/sbin/lixad --daemon
lixa@ubuntu:~$ ps -ef|grep lixad|grep -v grep
lixa      7127     1  0 22:13 ?        00:00:00 /opt/lixa/sbin/lixad --daemon
lixa@ubuntu:~$ exit
logout
	  </screen></td></tr></tbody>
	</table>
	Before we can start the program execution, we must create a file
	named <filename>monkeyrm.conf</filename> in the current directory
	and put the following content inside it:
	<table frame="box">
	  <thead><tr><td>[Content of file monkeyrm.conf]</td></tr></thead>
	  <tbody><tr><td><screen>
xa_open/0
xa_start/0
xa_end/0
xa_prepare/0
xa_commit/0
xa_close/0
	  </screen></td></tr></tbody>
	</table>
	Now you can execute the program to verify it's running as expected;
	we are tracing the module <quote>client XA switch</quote>
	(see <xref linkend="Tracing_modules"/>) to verify the 
	LIXA Monkey Resource Manager is properly configured:
	<table frame="box">
	  <thead><tr><td>[Shell terminal session]</td></tr></thead>
	  <tbody><tr><td><screen>
tiian@ubuntu:~/tmp$ export LIXA_TRACE_MASK=0x00010000
tiian@ubuntu:~/tmp$ ./example6_pql_ora insert 2>&amp;1 | grep monkey
2011-12-15 22:42:20.709697 [22490/3052672768] lixa_monkeyrm_open: xa_info='monkeyrm.conf', rmid=1, flags=0x0
2011-12-15 22:42:20.710101 [22490/3052672768] lixa_monkeyrm_open: creating new first level hash table...
2011-12-15 22:42:20.713087 [22490/3052672768] lixa_monkeyrm_open/g_hash_table_new_full/monkey_status: 0x804caa0
2011-12-15 22:42:20.713361 [22490/3052672768] lixa_monkeyrm_open: creating new second level hash table for tid=3052672768
2011-12-15 22:42:20.713719 [22490/3052672768] lixa_monkeyrm_open/g_hash_table_new_full/slht: 0x804cac8
2011-12-15 22:42:20.713994 [22490/3052672768] lixa_monkeyrm_open: creating new status block for tid=3052672768, rmid=1
2011-12-15 22:42:20.714248 [22490/3052672768] lixa_monkeyrm_open/g_malloc/mss: 0x804e998
2011-12-15 22:42:20.714521 [22490/3052672768] lixa_monkeyrm_open_init
2011-12-15 22:42:20.714783 [22490/3052672768] lixa_monkeyrm_open_init/g_array_new/mss->records: 0x804c550 
2011-12-15 22:42:20.715139 [22490/3052672768] lixa_monkeyrm_open_init: verb='xa_open'
2011-12-15 22:42:20.715430 [22490/3052672768] lixa_monkeyrm_open_init: appending record verb=1, rc=0
2011-12-15 22:42:20.715691 [22490/3052672768] lixa_monkeyrm_open_init: verb='xa_start'
2011-12-15 22:42:20.715946 [22490/3052672768] lixa_monkeyrm_open_init: appending record verb=3, rc=0
2011-12-15 22:42:20.716340 [22490/3052672768] lixa_monkeyrm_open_init: verb='xa_end'
2011-12-15 22:42:20.716602 [22490/3052672768] lixa_monkeyrm_open_init: appending record verb=4, rc=0
2011-12-15 22:42:20.716864 [22490/3052672768] lixa_monkeyrm_open_init: verb='xa_prepare'
2011-12-15 22:42:20.717123 [22490/3052672768] lixa_monkeyrm_open_init: appending record verb=5, rc=0
2011-12-15 22:42:20.717377 [22490/3052672768] lixa_monkeyrm_open_init: verb='xa_commit'
2011-12-15 22:42:20.717671 [22490/3052672768] lixa_monkeyrm_open_init: appending record verb=6, rc=0
2011-12-15 22:42:20.717937 [22490/3052672768] lixa_monkeyrm_open_init: verb='xa_close'
2011-12-15 22:42:20.718196 [22490/3052672768] lixa_monkeyrm_open_init: appending record verb=2, rc=0
2011-12-15 22:42:20.718519 [22490/3052672768] lixa_monkeyrm_open_init/excp=3/ret_cod=0/errno=0
2011-12-15 22:42:20.718816 [22490/3052672768] lixa_monkeyrm_get_rc
2011-12-15 22:42:20.726862 [22490/3052672768] lixa_monkeyrm_get_rc: verb is 1, XA return code is 0
2011-12-15 22:42:20.727177 [22490/3052672768] lixa_monkeyrm_get_rc/excp=2/ret_cod=0/errno=0
2011-12-15 22:42:20.727429 [22490/3052672768] lixa_monkeyrm_open/excp=4/ret_cod=0/xa_rc=0/errno=0
2011-12-15 22:42:21.022655 [22490/3052672768] lixa_monkeyrm_start: xid='1279875137.7bdcf6c060e14bdba416302661187411.a100c8728292168b21ba7239bffc137d', rmid=1, flags=0x0
2011-12-15 22:42:21.022695 [22490/3052672768] lixa_monkeyrm_get_rc
2011-12-15 22:42:21.022705 [22490/3052672768] lixa_monkeyrm_get_rc: verb is 3, XA return code is 0
2011-12-15 22:42:21.022712 [22490/3052672768] lixa_monkeyrm_get_rc/excp=2/ret_cod=0/errno=0
2011-12-15 22:42:21.022719 [22490/3052672768] lixa_monkeyrm_start/excp=4/ret_cod=0/xa_rc=0/errno=0
2011-12-15 22:42:21.059688 [22490/3052672768] lixa_monkeyrm_end: xid='1279875137.7bdcf6c060e14bdba416302661187411.a100c8728292168b21ba7239bffc137d', rmid=1, flags=0x4000000
2011-12-15 22:42:21.059701 [22490/3052672768] lixa_monkeyrm_get_rc
2011-12-15 22:42:21.059709 [22490/3052672768] lixa_monkeyrm_get_rc: verb is 4, XA return code is 0
2011-12-15 22:42:21.059716 [22490/3052672768] lixa_monkeyrm_get_rc/excp=2/ret_cod=0/errno=0
2011-12-15 22:42:21.059723 [22490/3052672768] lixa_monkeyrm_end/excp=4/ret_cod=0/xa_rc=0/errno=0
2011-12-15 22:42:21.076478 [22490/3052672768] lixa_monkeyrm_prepare: xid='1279875137.7bdcf6c060e14bdba416302661187411.a100c8728292168b21ba7239bffc137d', rmid=1, flags=0x0
2011-12-15 22:42:21.076498 [22490/3052672768] lixa_monkeyrm_get_rc
2011-12-15 22:42:21.076512 [22490/3052672768] lixa_monkeyrm_get_rc: verb is 5, XA return code is 0
2011-12-15 22:42:21.076520 [22490/3052672768] lixa_monkeyrm_get_rc/excp=2/ret_cod=0/errno=0
2011-12-15 22:42:21.076527 [22490/3052672768] lixa_monkeyrm_prepare/excp=4/ret_cod=0/xa_rc=0/errno=0
2011-12-15 22:42:21.098722 [22490/3052672768] lixa_monkeyrm_commit: xid='1279875137.7bdcf6c060e14bdba416302661187411.a100c8728292168b21ba7239bffc137d', rmid=1, flags=0x0
2011-12-15 22:42:21.098747 [22490/3052672768] lixa_monkeyrm_get_rc
2011-12-15 22:42:21.098756 [22490/3052672768] lixa_monkeyrm_get_rc: verb is 6, XA return code is 0
2011-12-15 22:42:21.098764 [22490/3052672768] lixa_monkeyrm_get_rc/excp=2/ret_cod=0/errno=0
2011-12-15 22:42:21.098770 [22490/3052672768] lixa_monkeyrm_commit/excp=4/ret_cod=0/xa_rc=0/errno=0
2011-12-15 22:42:21.102841 [22490/3052672768] lixa_monkeyrm_close: xa_info='', rmid=1, flags=0x0
2011-12-15 22:42:21.102853 [22490/3052672768] lixa_monkeyrm_get_rc
2011-12-15 22:42:21.102862 [22490/3052672768] lixa_monkeyrm_get_rc: verb is 2, XA return code is 0
2011-12-15 22:42:21.102869 [22490/3052672768] lixa_monkeyrm_get_rc/excp=2/ret_cod=0/errno=0
2011-12-15 22:42:21.102877 [22490/3052672768] lixa_monkeyrm_close/excp=4/ret_cod=0/xa_rc=0/errno=0
tiian@ubuntu:~/tmp$ unset LIXA_TRACE_MASK
tiian@ubuntu:~/tmp$ ./example6_pql_ora delete
Deleting a row from the tables...
Oracle DELETE statement executed!
	  </screen></td></tr></tbody>
	</table>
	Don't forget the clean-up step (last command) before performing
	the next steps.
      </para>
      <para>
	To create a <quote>recovery pending</quote> transaction, we are
	going to forcea crash after <function>xa_prepare()</function>
	functions completed successfully:
	<table frame="box">
	  <thead><tr><td>[Shell terminal session]</td></tr></thead>
	  <tbody><tr><td><screen>
tiian@ubuntu:~/tmp$ export LIXA_CRASH_POINT=15
tiian@ubuntu:~/tmp$ echo $LIXA_CRASH_POINT
15
tiian@ubuntu:~/tmp$ ./example6_pql_ora insert
Inserting a row in the tables...
Oracle INSERT statement executed!
Aborted
tiian@ubuntu:~/tmp$ unset LIXA_CRASH_POINT
tiian@ubuntu:~/tmp$ echo $LIXA_CRASH_POINT

	  </screen></td></tr></tbody>
	</table>
	Verify there is a prepared/in-doubt transaction inside Oracle:
	<table frame="box">
	  <thead><tr><td>[Oracle terminal session]</td></tr></thead>
	  <tbody><tr><td><screen>
SQL> select * from dba_pending_transactions;

  FORMATID
----------
GLOBALID
--------------------------------------------------------------------------------
BRANCHID
--------------------------------------------------------------------------------
1279875137
D2F5F0A5C37E485CB44D9FC16E72A33D
68D0E0CCBC6FC4B7FA616DF9AB122395
	  </screen></td></tr></tbody>
	</table>
	Verify there is a prepared/in-doubt transaction inside PostgreSQL:
	<table frame="box">
	  <thead><tr><td>[PostgreSQL terminal session]</td></tr></thead>
	  <tbody><tr><td><screen>
testdb=> select * from pg_prepared_xacts;
 transaction |                                    gid                                     |           prepared            | owner | database 
-------------+----------------------------------------------------------------------------+-------------------------------+-------+----------
         964 | 1279875137.d2f5f0a5c37e485cb44d9fc16e72a33d.68d0e0ccbc6fc4b7fa616df9ab122395 | 2011-12-16 16:38:47.921947+01 | tiian | testdb
	  </screen></td></tr></tbody>
	</table>
	To move the transaction in <quote>recovery failed</quote> status
	we emulate
	an <quote>heuristically rolled back</quote> in the automatic recovery
	step.
	Edit the file <filename>monkeyrm.conf</filename> to code the
	new behavior of the LIXA Monkey R.M.:
	<table frame="box">
	  <thead><tr><td>[Content of file monkeyrm.conf]</td></tr></thead>
	  <tbody><tr><td><screen>
xa_open/0
xa_commit/6
xa_close/0
	  </screen></td></tr></tbody>
	</table>
	Start the <command>lixat</command> utility command to start an
	<quote>automatic (warm) recovery</quote>; trace the
	<quote>client recovery</quote> 
	(see <xref linkend="Tracing_modules"/>) module to understand what
	happens:
	<table frame="box">
	  <thead><tr><td>[Shell terminal session]</td></tr></thead>
	  <tbody><tr><td><screen>
tiian@ubuntu:~/tmp$ export LIXA_TRACE_MASK=0x00040000
tiian@ubuntu:~/tmp$ /opt/lixa/bin/lixat
2011-12-16 16:44:09.970398 [8385/3073862320] client_recovery
2011-12-16 16:44:09.970575 [8385/3073862320] client_recovery: sending 197 bytes ('000191&lt;?xml version="1.0" encoding="UTF-8" ?&gt;&lt;msg level="0" verb="8" step="8"&gt;&lt;client job="68d0e0ccbc6fc4b7fa616df9ab122395/127.0.0.1      " config_digest="68d0e0ccbc6fc4b7fa616df9ab122395"/&gt;&lt;/msg&gt;') to the server for step 8
2011-12-16 16:44:10.007703 [8385/3073862320] client_recovery: receiving 632 bytes from the server |&lt;?xml version="1.0" encoding="UTF-8" ?&gt;&lt;msg level="0" verb="8" step="16"&gt;&lt;answer rc="0"/&gt;&lt;client job="68d0e0ccbc6fc4b7fa616df9ab122395/127.0.0.1      " config_digest="68d0e0ccbc6fc4b7fa616df9ab122395"&gt;&lt;last_verb_step verb="5" step="16"/&gt;&lt;state finished="0" txstate="3" will_commit="1" will_rollback="0" xid="1279875137.d2f5f0a5c37e485cb44d9fc16e72a33d.68d0e0ccbc6fc4b7fa616df9ab122395"/&gt;&lt;/client&gt;&lt;rsrmgrs&gt;&lt;rsrmgr rmid="0" next_verb="0" r_state="1" s_state="33" td_state="10"/&gt;&lt;rsrmgr rmid="1" next_verb="0" r_state="1" s_state="33" td_state="10"/&gt;&lt;rsrmgr rmid="2" next_verb="0" r_state="1" s_state="33" td_state="20"/&gt;&lt;/rsrmgrs&gt;&lt;/msg&gt;|
2011-12-16 16:44:10.008178 [8385/3073862320] client_recovery_analyze
2011-12-16 16:44:10.008229 [8385/3073862320] client_recovery_analyze: the TX was committing
2011-12-16 16:44:10.008242 [8385/3073862320] client_recovery_analyze: rmid=0, r_state=1, s_state=33, td_state=10
2011-12-16 16:44:10.008261 [8385/3073862320] client_recovery_analyze: rmid=1, r_state=1, s_state=33, td_state=10
2011-12-16 16:44:10.008278 [8385/3073862320] client_recovery_analyze: rmid=2, r_state=1, s_state=33, td_state=20
2011-12-16 16:44:10.008303 [8385/3073862320] client_recovery_analyze/excp=1/ret_cod=0/errno=0
2011-12-16 16:44:10.008327 [8385/3073862320] client_recovery: transaction '1279875137.d2f5f0a5c37e485cb44d9fc16e72a33d.68d0e0ccbc6fc4b7fa616df9ab122395' must be committed
2011-12-16 16:44:10.008353 [8385/3073862320] client_recovery_commit
2011-12-16 16:44:10.008388 [8385/3073862320] client_recovery_commit: committing transaction '1279875137.d2f5f0a5c37e485cb44d9fc16e72a33d.68d0e0ccbc6fc4b7fa616df9ab122395'
2011-12-16 16:44:10.008412 [8385/3073862320] client_recovery_commit: xa_commit for rmid=0, name='LIXAmonkey1staRM', xa_name='LIXA Monkey RM (static)'...
2011-12-16 16:44:10.008464 [8385/3073862320] client_recovery_commit: rc=6
2011-12-16 16:44:10.008613 [8385/3073862320] client_recovery_commit: xa_commit for rmid=1, name='PostgreSQL_stareg', xa_name='PostgreSQL[LIXA]'...
2011-12-16 16:44:10.062892 [8385/3073862320] client_recovery_commit: rc=0
2011-12-16 16:44:10.062962 [8385/3073862320] client_recovery_commit: xa_commit for rmid=2, name='OracleXE_dynreg', xa_name='Oracle_XA'...
2011-12-16 16:44:10.275061 [8385/3073862320] client_recovery_commit: rc=0
2011-12-16 16:44:10.275128 [8385/3073862320] client_recovery_commit/excp=1/ret_cod=0/errno=0
2011-12-16 16:44:10.275286 [8385/3073862320] client_recovery: sending 212 bytes ('000206&lt;?xml version="1.0" encoding="UTF-8" ?&gt;&lt;msg level="0" verb="8" step="24"&gt;&lt;recovery failed="1" commit="1"/&gt;&lt;rsrmgrs&gt;&lt;rsrmgr rmid="0" rc="6"/&gt;&lt;rsrmgr rmid="1" rc="0"/&gt;&lt;rsrmgr rmid="2" rc="0"/&gt;&lt;/rsrmgrs&gt;&lt;/msg&gt;') to the server for step 24
2011-12-16 16:44:10.275483 [8385/3073862320] client_recovery: sending 197 bytes ('000191&lt;?xml version="1.0" encoding="UTF-8" ?&gt;&lt;msg level="0" verb="8" step="8"&gt;&lt;client job="68d0e0ccbc6fc4b7fa616df9ab122395/127.0.0.1      " config_digest="68d0e0ccbc6fc4b7fa616df9ab122395"/&gt;&lt;/msg&gt;') to the server for step 8
2011-12-16 16:44:10.315057 [8385/3073862320] client_recovery: receiving 95 bytes from the server |&lt;?xml version="1.0" encoding="UTF-8" ?&gt;&lt;msg level="0" verb="8" step="16"&gt;&lt;answer rc="1"/&gt;&lt;/msg&gt;|
2011-12-16 16:44:10.315261 [8385/3073862320] client_recovery: the server answered LIXA_RC_OBJ_NOT_FOUND; there are no more transactions to recover
2011-12-16 16:44:10.315315 [8385/3073862320] client_recovery/excp=12/ret_cod=0/errno=0
tx_open(): 0
tx_close(): 0
	  </screen></td></tr></tbody>
	</table>
	The trace gives us a lot of information:
	<itemizedlist mark="bullet">
	  <listitem><para>
	      <command>lixat</command> fires an automatic (warm) recovery
	      for transaction XID='1279875137.d2f5f0a5c37e485cb44d9fc16e72a33d.68d0e0ccbc6fc4b7fa616df9ab122395'
	  </para></listitem>
	  <listitem><para>
	      the transaction must be committed because the crash followed
	      a successful <quote>prepare</quote> phase
	  </para></listitem>
	  <listitem><para>
	      first Resource Manager returns 6:
	      <constant>XA_HEURRB</constant> (<quote>the transaction branch 
		has been heuristically rolled back</quote>)
	  </para></listitem>
	  <listitem><para>
	      second and third Resource Managers return 0: XA_OK
	  </para></listitem>
	  <listitem><para>
	      the client send a <quote>recovery failed</quote>
	      message to the state server
	  </para></listitem>
	</itemizedlist>
	<note><para>
	    You could think the LIXA Transaction Manager should have not
	    performed the second and third 
	    <function>xa_commit</function> after a failure with the
	    first Resource Manager. It seems a good idea, but unfortunately
	    it does not add much value because, if applied, it would
	    introduce a behaviour that depends on the order of the
	    operations. The LIXA Transaction Manager tryes to apply a
	    consistent rule: after a successful <function>xa_prepare</function>
	    all the Resource Managers must receive the same command
	    (<function>xa_commit</function>/<function>xa_rollback</function>).
	</para></note>
	You can check the (real) Resource Managers status:
	<table frame="box">
	  <thead><tr><td>[Oracle terminal session]</td></tr></thead>
	  <tbody><tr><td><screen>
SQL> select * from dba_pending_transactions;

no rows selected

SQL> select * from COUNTRIES where COUNTRY_ID = 'RS';

COUNTR
------
COUNTRY_NAME
--------------------------------------------------------------------------------
 REGION_ID
----------
RS
Repubblica San Marino
	 1
	  </screen></td></tr></tbody>
	</table>
	<table frame="box">
	  <thead><tr><td>[PostgreSQL terminal session]</td></tr></thead>
	  <tbody><tr><td><screen>
testdb=> select * from pg_prepared_xacts;
 transaction | gid | prepared | owner | database 
-------------+-----+----------+-------+----------
(0 rows)

testdb=> SELECT * FROM authors;
 id | last_name | first_name 
----+-----------+------------
  1 | Foo       | Bar
	  </screen></td></tr></tbody>
	</table>
	Inspecting the system log you can notify there was a problem:
	<table frame="box">
	  <thead><tr><td>[Shell terminal session]</td></tr></thead>
	  <tbody><tr><td><screen>
tiian@ubuntu:~/tmp$ sudo tail /var/log/daemon.log
Dec 16 16:44:09 ubuntu lixat[8385]: LXC000I this process is starting a new LIXA transaction manager (lixa package version is 0.5.36)
Dec 16 16:44:10 ubuntu lixat[8385]: LXC003C resource manager 'LIXAmonkey1staRM' returned an error (6) while committing (xa_commit) during recovery phase for transaction '1279875137.d2f5f0a5c37e485cb44d9fc16e72a33d.68d0e0ccbc6fc4b7fa616df9ab122395'
Dec 16 16:44:10 ubuntu lixat[8385]: LXC005W unable to recover transaction id '1279875137.d2f5f0a5c37e485cb44d9fc16e72a33d.68d0e0ccbc6fc4b7fa616df9ab122395'; this transaction must be manually recovered and the correlated record(s) must be manually fixed in lixad server status file
Dec 16 16:44:10 ubuntu lixad[8157]: LXD012W a client notified recovery failed condition for the transaction registered in status file 3 and block 1
	  </screen></td></tr></tbody>
	</table>
	there is a critical message (LXC003C) and two warning messages
	(LXC005W, LXD012W). Pay attention the server notifies the problem 
	(LXD012W) as well as the client (LXC005W).
	To inspect the content of the <quote>recovery failed</quote>
	transaction you may dump the state server:
	<table frame="box">
	  <thead><tr><td>[Shell terminal session]</td></tr></thead>
	  <tbody><tr><td><screen>
tiian@ubuntu:~/tmp$ sudo su - lixa
lixa@ubuntu:~$ pkill lixad
lixa@ubuntu:~$ /opt/lixa/sbin/lixad --dump=u >/tmp/bar
lixa@ubuntu:~$ exit
logout
	  </screen></td></tr></tbody>
	</table>
	and inspect the content of file <filename>/tmp/bar</filename>
	<footnote><para>
	    The state server can be analyzed without stopping it
	    (<command>pkill lixad</command>), but it may happen you will
	    not see the current content because the state server 
	    has not yet synchronized
	    the state file(s). If the LIXA state server is processing many
	    transactions per second you will probably see an up-to-date
	    state, but if it was <quote>sleeping</quote> you wouldn't.
	</para></footnote>:
	<table frame="box">
	  <thead><tr><td>[Content of file /tmp/bar]</td></tr></thead>
	  <tbody><tr><td><screen>
========================================================================
Second file ('/opt/lixa/var/lixad_status1_2') will be dumped
Magic number is: 24848 (24848)
Level is: 1 (1)
Last sync timestamp: 2011-12-16T16:38:23.482854+0100
Size: 17 blocks
Used block chain starts at: 16 
Free block chain starts at: 0 (empty chain)
Dumping records following physical order: 0
Dumping records following free block chain: 0
Dumping records following used block chain: 1
------------------------------------------------------------------------

[...] 

------------------------------------------------------------------------
Block: 9, next block in chain: 8
Block type: transaction manager record (transaction header)
	Trnhdr/number of resource managers: 3
	Trnhdr/resource manager blocks are: 10 11 12 
	Trnhdr/arrival time: 2011-12-16T16:26:04.790526+0100
	Trnhdr/local socket address:port is 127.0.0.1:2345
	Trnhdr/peer socket address:port is 127.0.0.1:52251
	Trnhdr/config digest is '68d0e0ccbc6fc4b7fa616df9ab122395'
	Trnhdr/job is '68d0e0ccbc6fc4b7fa616df9ab122395/127.0.0.1      '
	Trnhdr/last (verb, step) are: [ (9,8) (4,8) (4,16) (5,8) (5,16) ]
	Trnhdr/state/finished: 0
	Trnhdr/state/txstate: 3
	Trnhdr/state/will commit: 1
	Trnhdr/state/will rollback: 0
	Trnhdr/state/xid: '1279875137.592cec793be1433d8ffd18574211e0e2.68d0e0ccbc6fc4b7fa616df9ab122395'
	Trnhdr/recoverying block id: 0
	Trnhdr/recovery failed: 1
	Trnhdr/recovery failed time: 2011-12-16T16:29:15.947057+0100
	Trnhdr/recovery commit: 1
------------------------------------------------------------------------
Block: 8, next block in chain: 7
Block type: resource manager record
	Rsrmgr/rmid: 2
	Rsrmgr/state/next_verb: 0
	Rsrmgr/state/xa_r_state: 1
	Rsrmgr/state/dynamic: 0
	Rsrmgr/state/xa_td_state: 10
	Rsrmgr/state/xa_s_state: 33
	Rsrmgr/lixac_conf.xml name: 'LIXAmonkey1staRM'
	Rsrmgr/xa_name: 'LIXA Monkey RM (static)'
	Rsrmgr/xa_open_info: 'monkeyrm.conf'
	Rsrmgr/xa_open_flags: 0x0
	Rsrmgr/xa_open_rc: 0
	Rsrmgr/xa_start_flags: 0x0
	Rsrmgr/xa_start_rc: 0
	Rsrmgr/xa_end_flags: 0x4000000
	Rsrmgr/xa_end_rc: 0
	Rsrmgr/xa_prepare_flags: 0x0
	Rsrmgr/xa_prepare_rc: 0
	Rsrmgr/xa_commit_flags: 0x0
	Rsrmgr/xa_commit_rc: 0
	Rsrmgr/xa_rollback_flags: 0x0
	Rsrmgr/xa_rollback_rc: 0
	Rsrmgr/xa_forget_flags: 0x0
	Rsrmgr/xa_forget_rc: 0
	Rsrmgr/ax_reg_flags: 0x0
	Rsrmgr/ax_reg_rc: 0
	Rsrmgr/ax_unreg_flags: 0x0
	Rsrmgr/ax_unreg_rc: 0
	Rsrmgr/recovery_rc: 6
------------------------------------------------------------------------
Block: 7, next block in chain: 6
Block type: resource manager record
	Rsrmgr/rmid: 1
	Rsrmgr/state/next_verb: 0
	Rsrmgr/state/xa_r_state: 1
	Rsrmgr/state/dynamic: 1
	Rsrmgr/state/xa_td_state: 20
	Rsrmgr/state/xa_s_state: 33
	Rsrmgr/lixac_conf.xml name: 'OracleXE_dynreg'
	Rsrmgr/xa_name: 'Oracle_XA'
	Rsrmgr/xa_open_info: 'Oracle_XA+Acc=P/hr/hr+SesTm=30+LogDir=/tmp+threads=true+DbgFl=7+Loose_Coupling=true'
	Rsrmgr/xa_open_flags: 0x0
	Rsrmgr/xa_open_rc: 0
	Rsrmgr/xa_start_flags: 0x0
	Rsrmgr/xa_start_rc: 0
	Rsrmgr/xa_end_flags: 0x4000000
	Rsrmgr/xa_end_rc: 0
	Rsrmgr/xa_prepare_flags: 0x0
	Rsrmgr/xa_prepare_rc: 0
	Rsrmgr/xa_commit_flags: 0x0
	Rsrmgr/xa_commit_rc: 0
	Rsrmgr/xa_rollback_flags: 0x0
	Rsrmgr/xa_rollback_rc: 0
	Rsrmgr/xa_forget_flags: 0x0
	Rsrmgr/xa_forget_rc: 0
	Rsrmgr/ax_reg_flags: 0x0
	Rsrmgr/ax_reg_rc: 0
	Rsrmgr/ax_unreg_flags: 0x0
	Rsrmgr/ax_unreg_rc: 0
	Rsrmgr/recovery_rc: 0
------------------------------------------------------------------------
Block: 6, next block in chain: 5
Block type: resource manager record
	Rsrmgr/rmid: 0
	Rsrmgr/state/next_verb: 0
	Rsrmgr/state/xa_r_state: 1
	Rsrmgr/state/dynamic: 0
	Rsrmgr/state/xa_td_state: 10
	Rsrmgr/state/xa_s_state: 33
	Rsrmgr/lixac_conf.xml name: 'PostgreSQL_stareg'
	Rsrmgr/xa_name: 'PostgreSQL[LIXA]'
	Rsrmgr/xa_open_info: 'dbname=testdb'
	Rsrmgr/xa_open_flags: 0x0
	Rsrmgr/xa_open_rc: 0
	Rsrmgr/xa_start_flags: 0x0
	Rsrmgr/xa_start_rc: 0
	Rsrmgr/xa_end_flags: 0x4000000
	Rsrmgr/xa_end_rc: 0
	Rsrmgr/xa_prepare_flags: 0x0
	Rsrmgr/xa_prepare_rc: 0
	Rsrmgr/xa_commit_flags: 0x0
	Rsrmgr/xa_commit_rc: 0
	Rsrmgr/xa_rollback_flags: 0x0
	Rsrmgr/xa_rollback_rc: 0
	Rsrmgr/xa_forget_flags: 0x0
	Rsrmgr/xa_forget_rc: 0
	Rsrmgr/ax_reg_flags: 0x0
	Rsrmgr/ax_reg_rc: 0
	Rsrmgr/ax_unreg_flags: 0x0
	Rsrmgr/ax_unreg_rc: 0
	Rsrmgr/recovery_rc: 0
------------------------------------------------------------------------

[...]

========================================================================
First file ('/opt/lixa/var/lixad_status2_1') will be dumped
Magic number is: 24848 (24848)
Level is: 1 (1)
Last sync timestamp: 2011-12-16T16:23:40.512332+0100
Size: 10 blocks
Used block chain starts at: 0 (empty chain)
Free block chain starts at: 1 
Dumping records following physical order: 0
Dumping records following free block chain: 0
Dumping records following used block chain: 1
========================================================================
First file ('/opt/lixa/var/lixad_status3_1') will be dumped
Magic number is: 24848 (24848)
Level is: 1 (1)
Last sync timestamp: 2011-12-16T16:38:47.933099+0100
Size: 10 blocks
Used block chain starts at: 4 
Free block chain starts at: 5 
Dumping records following physical order: 0
Dumping records following free block chain: 0
Dumping records following used block chain: 1
------------------------------------------------------------------------

[...]
	  </screen></td></tr></tbody>
	</table>
	The chain composed of blocks 9 (transaction manager record) and
	8, 7, 6 (resource manager records) keeps the state of the 
	<quote>recovery failed</quote> transaction: 
	<computeroutput>Trnhdr/recovery failed: 1</computeroutput>
      </para>
      <para>
	If <quote>LIXA Monkey RM</quote> Resource Manager was a real
	Resource Manager, you could manually recovery the transaction
	used the procedure shown in 
	<xref linkend="Recoverying_forgotten_transactions"/>.
	Unfortunately the LIXA Monkey RM is a fake Resource Manager and it
	does not save the state anywhere: it is not able to correctly
	answer to <function>xa_recover()</function> and there is no way to
	show this last step.
      </para>
      <para>
	As a final step, to clean-up the <quote>recovery failed</quote>
	state from LIXA state server, you have to recycle it using a special
	option:
	<table frame="box">
	  <thead><tr><td>[Shell terminal session]</td></tr></thead>
	  <tbody><tr><td><screen>
tiian@ubuntu:~/tmp$ sudo su - lixa
lixa@ubuntu:~$ pkill lixad
lixa@ubuntu:~$ /opt/lixa/sbin/lixad --daemon --clean-failed
lixa@ubuntu:~$ pkill lixad<footnote><para>
The LIXA state server is stopped after start-up to guarantee the content
of the state file(s) on the disk are up-to-date before dumping them.
</para></footnote>
lixa@ubuntu:~$ exit
logout
	  </screen></td></tr></tbody>
	</table>
	Dump again the content of the state server:
	<table frame="box">
	  <thead><tr><td>[Shell terminal session]</td></tr></thead>
	  <tbody><tr><td><screen>
tiian@ubuntu:~/tmp$ sudo su - lixa
lixa@ubuntu:~$ /opt/lixa/sbin/lixad --dump=u >/tmp/bar
lixa@ubuntu:~$ exit
logout
	  </screen></td></tr></tbody>
	</table>
	and check the content of the dump file again: the blocks 
	10, 9, 8, 7 should not be used or, if re-used, they should be
	related to a different transaction.
      </para>
      <important><para>
	  <emphasis>Don't use 
	    <option>--clean-failed</option> as a default</emphasis>
	  when starting LIXA state server (<command>lixad</command>):
	  this option should be used only after you inspected the content
	  of the state server and solved any in-doubt transaction.
      </para></important>
      <note><para>
	  Operating this type of recovery can be easier if the LIXA state
	  server is running in <quote>maintenance mode</quote>
	  (see <xref linkend="Maintenance_mode_execution"/>): only
	  <command>lixar</command> can access the online content of the
	  LIXA state server and ordinary clients (Application Program)
	  can not perform transactions. It may be useful using the 
	  state server in <quote>maintenance mode</quote>, but only you
	  can decide if your business rules allows it.
      </para></note>
      <important><para>
	  The LIXA technology <emphasis>does not</emphasis> ask you to:
	  <itemizedlist mark="bullet">
	    <listitem><para>
		recycle the <command>lixad</command> state server to see
		the current status when dumping the content of the state
		server files (<option>--dump</option> option)
	    </para></listitem>
	    <listitem><para>
		start the <command>lixad</command> state server in
		<quote>maintenance mode</quote> when performing
		<quote>manual (cold) recovery</quote>
	    </para></listitem>
	  </itemizedlist>
	  The LIXA technology provides you these functions to simplify the
	  administrative tasks, but deciding which option should be used
	  it's your own responsability. 
      </para></important>
    </section>
    <section xml:id="Recoverying_transaction_associated_different_job">
      <title>Recoverying a transaction associated to a different job</title>
      <para>
	As explained in <xref linkend="Automatic_recovery_concepts"/>,
	the <quote>automatic (warm) recovery</quote> is automatically
	performed by the LIXA Transaction Manager under the condition of
	<quote>Application Program equivalence</quote>
	(see <xref linkend="Application_Program_equivalence"/>).
      </para>
      <para>
	Sometimes you have to perform a <quote>manual (cold) recovery</quote>
	because <quote>Application Program equivalence</quote> is no more
	available. This is a typical scenario:
	<itemizedlist mark="bullet">
	  <listitem><para>
	      an Application Program crashed and its transaction is in
	      <quote>in-doubt/prepared (recovery pending) status</quote>
	  </para></listitem>
	  <listitem><para>
	      the Application Program didn't specify a custom value for
	      the environment variable <varname>LIXA_JOB</varname>
	  </para></listitem>
	  <listitem><para>
	      you changed the content of file
	      <filename>lixac_conf.xml</filename>, for example you added a 
	      new profile
	  </para></listitem>
	  <listitem><para>
	      the MD5 signature of file <filename>lixac_conf.xml</filename>
	      changed, the associated <varname>branch qualifier</varname>
	      changed, new transactions would be associated to a 
	      different <emphasis>job</emphasis>
	  </para></listitem>
	  <listitem><para>
	      automatic (warm) recovery wouldn't be automatically performed
	      and the transaction becomes a 
	      <quote>forgotten</quote> transaction.
	  </para></listitem>
	</itemizedlist>
	Inspecting the list of recovery pending transaction using
	<command>lixar -p</command> does not return the desired transaction...
	What's going on?
      </para>
      <para>
	By default, the <command>lixar</command> utility filters the 
	transactions
	retrieved by the Resource Managers: it keeps only the transactions
	with the same <varname>branch qualifier</varname> of the current
	<command>lixar</command> running instance.
	If you look at <xref linkend="Application_Program_equivalence"/>,
	you will realize that <command>lixar</command> 
	retrieves only the transactions started with 
	the same <filename>lixac_conf.xml</filename>,
	the same $(<varname>LIXA_PROFILE</varname>) and
	the same <function>gethostid()</function>.
	This behaviour helps the system engineer to see only the 
	<quote>relevant</quote> subset of the whole
	<quote>recovery pending</quote> set.
      </para>
      <para>
	If you are looking for <emphasis>all</emphasis> the transactions in
	<quote>recovery pending</quote> status currently kept by the
	Resource Managers associated to the current 
	<varname>LIXA_PROFILE</varname>, you must specify the
	<option>--bypass-bqual-check</option> (<option>-b</option>) option.
      </para>
    </section>
    <section>
      <title>Recoverying a transaction managed by a different Transaction Manager</title>
      <para>
	The LIXA project technology can help you dealing with a different
	Transaction Manager 
	(see <xref linkend="Transaction_Manager_and_Transaction_Monitor"/>) 
	too: the <command>lixar</command> utility program can be used to
	inspect (and manually recover) a transaction managed by a different
	Transaction Manager using two command options together:
	<itemizedlist mark="bullet">
	  <listitem><para>
	      <option>--bypass-bqual-check</option> (<option>-b</option>):
	      to bypass branch qualifier based filtering
	  </para></listitem>
	  <listitem><para>
	      <option>--bypass-formatid-check</option> (<option>-B</option>):
	      to bypass format ID based filtering
	  </para></listitem>
	</itemizedlist>
	If you use the above command options together, 
	<command>lixar</command> utility program will inspect (and eventually
	commit/rollback) any XA transaction known by the Resource Managers
	associated to the current <varname>LIXA_PROFILE</varname>.
      </para>
      <note><para>
	  It's <emphasis>your own</emphasis> responsability to define a
	  LIXA profile that's compatible with the configuration of the
	  third party Transaction Manager used when managing the transaction:
	  it <emphasis>must</emphasis> contain the <emphasis>same</emphasis>
	  Resource Managers in the <emphasis>same</emphasis> order
	  with the <emphasis>same</emphasis> options.
      </para></note>
      <warning><para>
	  LIXA software is libre/free/open source software and you use it
	  <emphasis>exclusively and consciously without any
	  warranty at your own risk</emphasis>.
	  Using LIXA software technology will probably put you in an
	  <emphasis>unsupported</emphasis> state regarding to the
	  third party Transaction Manager supplier.
      </para></warning>
    </section>
    <section>
      <title>Picking up the LIXA format id and branch qualifier</title>
      <para>
	In the previous sections we have dealt with 
	<quote>format id</quote> and <quote>branch qualifier</quote>;
	you could ask 
	<quote>How can I discover the
	  <quote>format id</quote> and the <quote>branch qualifier</quote>
	  branch qualifier associated to my own Application Program?</quote>
      </para>
      <para>
	The easiest way to pick-up them is to use <command>lixat</command>
	utility program using the <emphasis>same</emphasis>
	<varname>LIXA_PROFILE</varname> you use when running your
	Application Program:
	<screen>
tiian@ubuntu:~/src/lixa$ sudo su - lixa
lixa@ubuntu:~$ /opt/lixa/sbin/lixad --daemon
lixa@ubuntu:~$ ps -ef|grep lixad|grep -v grep
lixa      8122     1  0 23:02 ?        00:00:00 /opt/lixa/sbin/lixad --daemon
lixa@ubuntu:~$ exit
logout
tiian@ubuntu:~/src/lixa$ /opt/lixa/bin/lixat -c
tx_open(): 0
tx_begin(): 0
tx_info(): 1
	xid/formatID.gtrid.bqual = 1279875137.56af7a66398f4eca82b8826fe10165ad.9e4c11057107c73366c9fc421eaa85ca
tx_commit(): 0
tx_close(): 0
tiian@ubuntu:~/src/lixa$ /opt/lixa/bin/lixat -c
tx_open(): 0
tx_begin(): 0
tx_info(): 1
	xid/formatID.gtrid.bqual = 1279875137.218f05b733fb4bc1aa3d21eeaf01fbab.9e4c11057107c73366c9fc421eaa85ca
tx_commit(): 0
tx_close(): 0	  
	</screen>
	From the above terminal output:
	<itemizedlist mark="bullet">
	  <listitem><para>
	      <quote>formatID</quote> is constant and the LIXA Transaction
	      Manager uses the exadecimal value 1279875137 (that's the 
	      ASCII sequence of string <quote>LIXA</quote>)
	  </para></listitem>
	  <listitem><para>
	      <quote>branch qualifier</quote> is computed as explained in
	      <xref linkend="Application_Program_equivalence"/> and the
	      value in the above example is
	      <quote>9e4c11057107c73366c9fc421eaa85ca</quote>
	  </para></listitem>
	  <listitem><para>
	      <quote>global transaction id</quote> must be different for
	      any transaction and you can see two different values in the
	      above examples (it's computed using
	      <function>uuid_generate()</function> function).
	  </para></listitem>
	</itemizedlist>
      </para>
      <para>
	If you were interested in retrieving them programmatically
	(from your own C language program) you could use the standard
	<function>tx_info()</function> function that returns a 
	<type>TXINFO</type> struct (<citation>TXspec</citation>).
	Please pay attention the
	<type>XID</type> struct contains <emphasis>binary data</emphasis>
	(it does not contain ASCII data).
      </para>
    </section>
  </section>
</chapter>
