<chapter xml:id="Recovery">
  <title>Recovery</title> 
  <para>
    This chapter explains some advanced concepts that the LIXA system
    administrator should know to solve some complex issues the XA 
    technology could generate.
    LIXA technology provide two type of recovery:
    <itemizedlist mark="bullet">
      <listitem><para>
	  <emphasis>Automatic Recovery</emphasis>: 
	  it happens silently and rolls back or commits
	  the transactions that crashed before a consistent point had been
	  reached
      </para></listitem>
      <listitem><para>
	  <emphasis>Manual Recovery</emphasis>:
	  it is invoked by <command>lixar</command> utility
	  to solve the transactions that cannot be automatically recovered
      </para></listitem>
    </itemizedlist>	
  </para>
  <section>
    <title>Automatic (warm) recovery</title>
    <section>
      <title>Scenario 1: autonoumos rollback</title>
      <para>
	If your environment is configured and runs as designed, when an
	Application Program fails an automatic recovery operation fix the
	problem as soon as possible. Below there is a first trivial
	scenarios:
	<itemizedlist mark="bullet">
	  <listitem>
	    <para>the Application Program crashes before it reaches the
	      <function>xa_prepare()</function> function
	      (called by <function>tx_commit()</function>)
	    </para>
	  </listitem>
	  <listitem>
	    <para>the Resource Managers 
	      <emphasis>autonoumosly</emphasis> roll back the
	      work in progress and the environment is cleaned up</para>
	  </listitem>
	</itemizedlist>	
	the distributed transaction started but it did not initiated the
	two phase commit protocol: there is no relevant difference between
	this scenario and a single Resource Manager (one phase commit)
	scenario. The LIXA Transaction Manager does <emphasis>not</emphasis>
	manage a recovery phase.
	<figure xml:id="recover1">
	  <title>The Application Program crashes before <function>xa_prepare()</function></title>
	  <mediaobject>
	    <imageobject>
	      <imagedata fileref="LIXA_Recovery_01.png"/>
	    </imageobject>
	  </mediaobject>
	</figure>
      </para>
    </section>
    <section>
      <title>Scenario 2: a second Application Program triggers the recovery action</title>
      <para>
	The following scenario is slightly different:
	<itemizedlist mark="bullet">
	  <listitem>
	    <para>the Application Program crashes after it has passed the
	      <function>xa_prepare()</function> function but before it
	      reaches the <function>xa_commit()</function> function
	    </para>
	  </listitem>
	  <listitem>
	    <para>the Resource Managers keep the <emphasis>prepared</emphasis>
	    transaction <quote>in flight</quote> until the Transaction
	    Manager decides the proper recovery action</para>
	  </listitem>
	  <listitem>
	    <para>an <quote>equivalent</quote> Application Program starts 
	      and activates
	      the LIXA Transaction Manager with <function>tx_open()</function>
	    </para>
	  </listitem>
	  <listitem>
	    <para>the LIXA Transaction Manager discovers there is a
	      <emphasis>prepared</emphasis> transaction and establishes that
	      it must commit the transaction
	    </para>
	  </listitem>
	  <listitem>
	    <para>the second Application Program implicitly and inconsciously
	    started the recovery process of a previously crashed
	    Application Program</para>
	  </listitem>
	</itemizedlist>	
	<figure xml:id="recover2">
	  <title>The Application Program crashes after <function>xa_prepare()</function></title>
	  <mediaobject>
	    <imageobject>
	      <imagedata fileref="LIXA_Recovery_02.png"/>
	    </imageobject>
	  </mediaobject>
	</figure>
	The above pattern is the result of the LIXA design: the Transaction
	Manager is not an active component, but it's a passive one and
	is embedded in the Application Program when it links the
	<systemitem class="library">lixac</systemitem> library 
	and activates it with the
	<function>tx_open()</function> function.
      </para>
      <note><para>
	  Depending on the crash time: slightly before the 
	  <emphasis>prepare phase</emphasis>,
	  in the middle of the <emphasis>prepare phase</emphasis>,
	  after the completion of the <emphasis>prepare phase</emphasis>, 
	  the LIXA Transaction Manager chooses a different recovery 
	  operation between
	  <function>xa_commit()</function> and 
	  <function>xa_rollback()</function>.
      </para></note>
    </section>
  </section>
  <section xml:id="Automatic_recovery_concepts">
    <title>Automatic recovery concepts</title>
    <para>
      The above paragraphs explain what's happen when automatic recovery
      starts and completes (rolls back or commits) the transaction marked
      as <quote>recovery pending</quote>.
    </para>
    <para>
      <foreignphrase>
	An <quote>equivalent</quote> Application Program starts and activates
	the LIXA Transaction Manager with <function>tx_open()</function>.
	The LIXA Transaction Manager autonoumosly coordinates the transaction
	completion and the Application Program is not aware of this
	<emphasis>under the covers</emphasis> operation.
      </foreignphrase>
    </para>
    <section>
      <title>Application Program equivalence</title>
      <para>
	From the LIXA Transaction Manager point of view,
	two Application Programs are
	equivalent when they are associated to the same 
	<emphasis>job</emphasis>.
      </para>
      <para>
	The job associated to an Application Program can be:
	<itemizedlist mark="bullet">
	  <listitem>
	    <para>
	      the content of the environment variable 
	      <varname>LIXA_JOB</varname> if it is set
	    </para>
	  </listitem>
	  <listitem>
	    <para>
	      a string computed in this way if the environment variable 
	      <varname>LIXA_JOB</varname> is <emphasis>not</emphasis> set:
	      <para>
		<varname>branch qualifier</varname> + 
		<quote>/</quote> + 
		<systemitem class="ipaddress">IP address</systemitem>
	      </para>
	      where <varname>branch qualifier</varname> is computed as:
	      <para>
		<function>MD5</function>(<filename>lixac_conf.xml</filename> + 
		$(<varname>LIXA_PROFILE</varname>) +
		<function>gethostid()</function>)
	      </para>
	    </para>
	  </listitem>
	</itemizedlist>
	An example of <varname>branch qualifier</varname> is
	<quote>0fc29445b1d4c3f4ed6be2fea20f918b</quote>, while an example of
	job automatically associated to an Application Program is
	<quote>0fc29445b1d4c3f4ed6be2fea20f918b/127.0.0.1</quote>
      </para>
      <note><para>
	  If you don't set the environment variable 
	  <varname>LIXA_JOB</varname> all the Application Programs that
	  meet this requirements:
	  <itemizedlist mark="bullet">
	    <listitem><para>
		they use a config file (<filename>lixac_conf.xml</filename>)
		with the same content
	    </para></listitem>
	    <listitem><para>
		they use a <varname>LIXA_PROFILE</varname> environment variable
		with the same content
	    </para></listitem>
	    <listitem><para>
		they run in a host that returns the same value to
		<function>gethostid()</function> function		
	    </para></listitem>
	    <listitem><para>
		they are calling the LIXA state server from the same 
		IP address	
	    </para></listitem>
	  </itemizedlist>
	  <emphasis>are associated to the same job</emphasis>.
      </para></note>
      <para>
	To pick-up the job associated to an Application Program you can
	activate the trace using the bit associated to the label
	<quote>LIXA_TRACE_MOD_CLIENT_CONFIG</quote>. Take a look to
	<xref linkend="Tracing_modules"/> for more information.
	This is an excerpt from the trace:
	<screen>
[...]	  
2011-12-03 17:00:59.746036 [6021/1078050640] client_config_job
2011-12-03 17:00:59.746073 [6021/1078050640] client_config_job: acquiring exclusive mutex
2011-12-03 17:00:59.746120 [6021/1078050640] client_config_job: 'LIXA_JOB' environment variable not found, computing job string...
2011-12-03 17:00:59.746175 [6021/1078050640] lixa_job_set_source_ip
2011-12-03 17:00:59.746275 [6021/1078050640] lixa_job_set_source_ip/excp=1/ret_cod=0/errno=0
2011-12-03 17:00:59.746339 [6021/1078050640] client_config_job: job value for this process is '0fc29445b1d4c3f4ed6be2fea20f918b/127.0.0.1      '
2011-12-03 17:00:59.746379 [6021/1078050640] client_config_job: releasing exclusive mutex
2011-12-03 17:00:59.746514 [6021/1078050640] client_config_job/excp=3/ret_cod=0/errno=0
[...]
	</screen>
	<important><para>
	    Setting the environment variable <varname>LIXA_JOB</varname>
	    allows you to associate any Application Program to a custom
	    user defined job: this may be interesting if you are using a
	    workload balanced environment, this may be dangerous if you
	    associate Application Programs using a different set of
	    Resource Managers to the same job.
	</para></important>
      </para>
      <para>
	If you don't set <varname>LIXA_JOB</varname> environment variable,
	the default behavior should be strong enought to avoid issues when
	LIXA is used under <quote>standard</quote> conditions.
      </para>
    </section>
    <section xml:id="Forcing_automatic_recovery">
      <title>Forcing automatic recovery</title>
      <para>
	Sometimes you need to force the automatic recovery to happen because
	the crashed Applicaton Program is a <quote>one shot</quote> program
	and you can not execute it a second time due to some functional
	constrain.
      </para>
      <para>
	Any application program meeting the requirements described above can
	be used, <command>lixat</command> utility command too. The following
	example will show you how it works using PostgreSQL and Oracle
	Resource Managers.
      </para>
      <para>
	First of all, you must configure, build and install the LIXA project
	software enabling PostgreSQL, Oracle and crash simulation features:
	<screen>
tiian@ubuntu:~/lixa$ ./configure --with-oracle=/usr/lib/oracle/xe/app/oracle/product/10.2.0/server \
> --with-postgresql-include=/usr/include/postgresql --with-postgresql-lib=/usr/lib \
> --enable-crash
	</screen>
	then you must follow the steps described in 
	<xref linkend="Development_example6_pql_ora"/>
	to prepare the scenario environment.
	Open three different terminal sessions as explained in the above
	example, and try to insert/delete a row:
	<table frame="box">
	  <thead><tr><td>[Shell terminal session]</td></tr></thead>
	  <tbody><tr><td><screen>
tiian@ubuntu:~/tmp$ echo $LIXA_PROFILE
PQL_STA_ORA_DYN
tiian@ubuntu:~/tmp$ echo $ORACLE_HOME
/usr/lib/oracle/xe/app/oracle/product/10.2.0/server
tiian@ubuntu:~/tmp$ echo $ORACLE_SID
XE
tiian@ubuntu:~/tmp$ echo $LD_LIBRARY_PATH
/usr/lib/oracle/xe/app/oracle/product/10.2.0/server/lib::/opt/lixa/lib
tiian@ubuntu:~/tmp$ ./example6_pql_ora insert
Inserting a row in the tables...
Oracle INSERT statement executed!
tiian@ubuntu:~/tmp$ ./example6_pql_ora delete
Deleting a row from the tables...
Oracle DELETE statement executed!
	  </screen></td></tr></tbody>
	</table>
	To simulate a crash after the <function>xa_prepare()</function>
	completed successfully, you can set the environment variable
	<varname>LIXA_CRASH_POINT</varname> to the value
	<constant>LIXA_CRASH_POINT_PREPARE_2</constant>
	(see <filename>src/common/lixa_crash.h</filename>:
	<table frame="box">
	  <thead><tr><td>[Shell terminal session]</td></tr></thead>
	  <tbody><tr><td><screen>
tiian@ubuntu:~/tmp$ export LIXA_CRASH_POINT=15
tiian@ubuntu:~/tmp$ echo $LIXA_CRASH_POINT
15
tiian@ubuntu:~/tmp$ ./example6_pql_ora insert
Inserting a row in the tables...
Oracle INSERT statement executed!
Aborted
	  </screen></td></tr></tbody>
	</table>
	You can check there is a prepared (in-doubt) transaction inside Oracle:
	<table frame="box">
	  <thead><tr><td>[Oracle terminal session]</td></tr></thead>
	  <tbody><tr><td><screen>
SQL> select * from dba_pending_transactions;

  FORMATID
----------
GLOBALID
--------------------------------------------------------------------------------
BRANCHID
--------------------------------------------------------------------------------
1279875137
97DD30A150604AFDBFA5FDC94B611FD5
9BAC7BE1C129EA6EE31F2D71B318120C
	  </screen></td></tr></tbody>
	</table>
	And the same transaction inside PostgreSQL:
	<table frame="box">
	  <thead><tr><td>[PostgreSQL terminal session]</td></tr></thead>
	  <tbody><tr><td><screen>
testdb=> select * from pg_prepared_xacts;
 transaction |                                    gid                                     |           prepared            | owner | database 
-------------+----------------------------------------------------------------------------+-------------------------------+-------+----------
         874 | 4c495841.97dd30a150604afdbfa5fdc94b611fd5.9bac7be1c129ea6ee31f2d71b318120c | 2011-12-14 22:02:50.462682+01 | tiian | testdb
	  </screen></td></tr></tbody>
	</table>
	Noting that the decimal value 1279875137 is expressed as 4c495841 
	in hexadecimal, the information retrieved from the Resource Managers 
	is consistent.
	It is suggested to activate the trace related to the 
	<quote>client recovery</quote>
	module (see <xref linkend="Tracing_modules"/>)
	before running <command>lixat</command> program:
	<table frame="box">
	  <thead><tr><td>[Shell terminal session]</td></tr></thead>
	  <tbody><tr><td><screen>
tiian@ubuntu:~/tmp$ export LIXA_TRACE_MASK=0x00040000
tiian@ubuntu:~/tmp$ /opt/lixa/bin/lixat 
2011-12-14 22:22:01.740634 [27735/3073944240] client_recovery
2011-12-14 22:22:01.740771 [27735/3073944240] client_recovery: sending 197 bytes ('000191&lt;?xml version="1.0" encoding="UTF-8" ?&gt;&lt;msg level="0" verb="8" step="8"&gt;&lt;client job="9bac7be1c129ea6ee31f2d71b318120c/127.0.0.1      " config_digest="9bac7be1c129ea6ee31f2d71b318120c"/&gt;&lt;/msg&gt;') to the server for step 8
2011-12-14 22:22:01.759352 [27735/3073944240] client_recovery: receiving 561 bytes from the server |&lt;?xml version="1.0" encoding="UTF-8" ?&gt;&lt;msg level="0" verb="8" step="16"&gt;&lt;answer rc="0"/&gt;&lt;client job="9bac7be1c129ea6ee31f2d71b318120c/127.0.0.1      " config_digest="9bac7be1c129ea6ee31f2d71b318120c"&gt;&lt;last_verb_step verb="5" step="16"/&gt;&lt;state finished="0" txstate="3" will_commit="1" will_rollback="0" xid="4c495841.97dd30a150604afdbfa5fdc94b611fd5.9bac7be1c129ea6ee31f2d71b318120c"/&gt;&lt;/client&gt;&lt;rsrmgrs&gt;&lt;rsrmgr rmid="0" next_verb="0" r_state="1" s_state="33" td_state="10"/&gt;&lt;rsrmgr rmid="1" next_verb="0" r_state="1" s_state="33" td_state="20"/&gt;&lt;/rsrmgrs&gt;&lt;/msg&gt;|
2011-12-14 22:22:01.759776 [27735/3073944240] client_recovery_analyze
2011-12-14 22:22:01.759857 [27735/3073944240] client_recovery_analyze: the TX was committing
2011-12-14 22:22:01.759873 [27735/3073944240] client_recovery_analyze: rmid=0, r_state=1, s_state=33, td_state=10
2011-12-14 22:22:01.759884 [27735/3073944240] client_recovery_analyze: rmid=1, r_state=1, s_state=33, td_state=20
2011-12-14 22:22:01.759902 [27735/3073944240] client_recovery_analyze/excp=1/ret_cod=0/errno=0
2011-12-14 22:22:01.759921 [27735/3073944240] client_recovery: transaction '4c495841.97dd30a150604afdbfa5fdc94b611fd5.9bac7be1c129ea6ee31f2d71b318120c' must be committed
2011-12-14 22:22:01.759937 [27735/3073944240] client_recovery_commit
2011-12-14 22:22:01.759971 [27735/3073944240] client_recovery_commit: committing transaction '4c495841.97dd30a150604afdbfa5fdc94b611fd5.9bac7be1c129ea6ee31f2d71b318120c'
2011-12-14 22:22:01.759998 [27735/3073944240] client_recovery_commit: xa_commit for rmid=0, name='PostgreSQL_stareg', xa_name='PostgreSQL[LIXA]'...
2011-12-14 22:22:02.143764 [27735/3073944240] client_recovery_commit: rc=0
2011-12-14 22:22:02.143866 [27735/3073944240] client_recovery_commit: xa_commit for rmid=1, name='OracleXE_dynreg', xa_name='Oracle_XA'...
2011-12-14 22:22:03.188211 [27735/3073944240] client_recovery_commit: rc=0
2011-12-14 22:22:03.188272 [27735/3073944240] client_recovery_commit/excp=1/ret_cod=0/errno=0
2011-12-14 22:22:03.188318 [27735/3073944240] client_recovery: sending 187 bytes ('000181&lt;?xml version="1.0" encoding="UTF-8" ?&gt;&lt;msg level="0" verb="8" step="24"&gt;&lt;recovery failed="0" commit="1"/&gt;&lt;rsrmgrs&gt;&lt;rsrmgr rmid="0" rc="0"/&gt;&lt;rsrmgr rmid="1" rc="0"/&gt;&lt;/rsrmgrs&gt;&lt;/msg&gt;') to the server for step 24
2011-12-14 22:22:03.188496 [27735/3073944240] client_recovery: sending 197 bytes ('000191&lt;?xml version="1.0" encoding="UTF-8" ?&gt;&lt;msg level="0" verb="8" step="8"&gt;&lt;client job="9bac7be1c129ea6ee31f2d71b318120c/127.0.0.1      " config_digest="9bac7be1c129ea6ee31f2d71b318120c"/&gt;&lt;/msg&gt;') to the server for step 8
2011-12-14 22:22:03.228361 [27735/3073944240] client_recovery: receiving 95 bytes from the server |&lt;?xml version="1.0" encoding="UTF-8" ?&gt;&lt;msg level="0" verb="8" step="16"&gt;&lt;answer rc="1"/&gt;&lt;/msg&gt;|
2011-12-14 22:22:03.228544 [27735/3073944240] client_recovery: the server answered LIXA_RC_OBJ_NOT_FOUND; there are no more transactions to recover
2011-12-14 22:22:03.228589 [27735/3073944240] client_recovery/excp=12/ret_cod=0/errno=0
tx_open(): 0
tx_close(): 0
	  </screen></td></tr></tbody>
	</table>
	You can now verify there are no more 
	<emphasis>prepared/in-doubt</emphasis> transactions inside the
	Resource Managers:
	<table frame="box">
	  <thead><tr><td>[Oracle terminal session]</td></tr></thead>
	  <tbody><tr><td><screen>
SQL> select * from dba_pending_transactions;

no rows selected
	  </screen></td></tr></tbody>
	</table>
	<table frame="box">
	  <thead><tr><td>[PostgreSQL terminal session]</td></tr></thead>
	  <tbody><tr><td><screen>
testdb=> select * from pg_prepared_xacts;
 transaction | gid | prepared | owner | database 
-------------+-----+----------+-------+----------
(0 rows)
	  </screen></td></tr></tbody>
	</table>
	<important><para>
	    The automatic (warm) recovery process completed successfully
	    because <command>./example6_pql_ora</command> and
	    <command>/opt/lixa/bin/lixat</command> were associated to 
	    <emphasis>the same job</emphasis> and the LIXA state server
	    (<command>lixad</command>) kept the state of the transaction in
	    the meanwhile.
	</para></important>
	In the next paragraphs you can explore what happens if the previous
	conditions are not satisfied.
      </para>
    </section>
  </section>
  <section>
    <title>Manual (cold) recovery</title>
    <para>
      If, for any reason, the LIXA state server (<command>lixad</command>)
      forgot the state of a transaction
      <footnote><para>
	  This should never happen: it could be a bug in LIXA project
	  software or it might be the consequence of a 
	  <quote>cold start</quote> (you removed the state files) of
	  <command>lixad</command>
      </para></footnote>
      or the transaction is in state <quote>recovery failed</quote> because
      a previous automatic (warm) recovery failed, you have to manually
      recover the transaction.
      The procedure to recover a <quote>forgotten</quote> transaction is 
      the same you use to recover a <quote>recovery failed</quote> one, 
      but additional server side clean-up is suggested for 
      <quote>recovery failed</quote> transactions.
    </para>
    <section>
      <title>Recoverying a forgotten transaction</title>
      <para>
	This example necessitates of the same environment set-up in
	<xref linkend="Forcing_automatic_recovery"/>; you must start running
	the example program after you enabled the 
	<varname>LIXA_CRASH_POINT</varname> environment variable:
	<table frame="box">
	  <thead><tr><td>[Shell terminal session]</td></tr></thead>
	  <tbody><tr><td><screen>
tiian@ubuntu:~/tmp$ export LIXA_CRASH_POINT=15
tiian@ubuntu:~/tmp$ echo $LIXA_CRASH_POINT
15
tiian@ubuntu:~/tmp$ ./example6_pql_ora insert
Deleting a row from the tables...
Oracle DELETE statement executed!
Aborted
	  </screen></td></tr></tbody>
	</table>
	and check there is a recovery pending transaction inside PostgreSQL
	and Oracle Resource Managers:
	<table frame="box">
	  <thead><tr><td>[Oracle terminal session]</td></tr></thead>
	  <tbody><tr><td><screen>
SQL> select * from dba_pending_transactions;

  FORMATID
----------
GLOBALID
--------------------------------------------------------------------------------
BRANCHID
--------------------------------------------------------------------------------
1279875137
957747F7F37B439EBCEA4146076AD322
9BAC7BE1C129EA6EE31F2D71B318120C
	  </screen></td></tr></tbody>
	</table>
	<table frame="box">
	  <thead><tr><td>[PostgreSQL terminal session]</td></tr></thead>
	  <tbody><tr><td><screen>
testdb=> select * from pg_prepared_xacts;
 transaction |                                    gid                                     |           prepared            | owner | database 
-------------+----------------------------------------------------------------------------+-------------------------------+-------+----------
         877 | 4c495841.957747f7f37b439ebcea4146076ad322.9bac7be1c129ea6ee31f2d71b318120c | 2011-12-14 22:55:14.973443+01 | tiian | testdb
	  </screen></td></tr></tbody>
	</table>
	Then you should stop and cold start the <command>lixad</command> 
	state server:
	<table frame="box">
	  <thead><tr><td>[Shell terminal session]</td></tr></thead>
	  <tbody><tr><td><screen>
tiian@ubuntu:~/tmp$ sudo su - lixa
lixa@ubuntu:~$ ps -ef|grep lixad|grep -v grep
lixa     24437     1  0 21:19 ?        00:00:00 /opt/lixa/sbin/lixad --daemon
lixa@ubuntu:~$ pkill lixad
lixa@ubuntu:~$ ps -ef|grep lixad|grep -v grep
lixa@ubuntu:~$ ls /opt/lixa/var/
lixad_status1_1  lixad_status2_1  lixad_status3_1  README
lixad_status1_2  lixad_status2_2  lixad_status3_2
lixa@ubuntu:~$ rm /opt/lixa/var/lixad_status*
lixa@ubuntu:~$ ls /opt/lixa/var/
README
lixa@ubuntu:~$ /opt/lixa/sbin/lixad --daemon
lixa@ubuntu:~$ ps -ef|grep lixad|grep -v grep
lixa     28594     1  0 23:00 ?        00:00:00 /opt/lixa/sbin/lixad --daemon
lixa@ubuntu:~$ ls /opt/lixa/var/
lixad_status1_1  lixad_status2_1  lixad_status3_1  README
lixad_status1_2  lixad_status2_2  lixad_status3_2  run.pid
lixa@ubuntu:~$ exit
logout
	  </screen></td></tr></tbody>
	</table>
	These are the operations you just performed:
	<itemizedlist mark="bullet">
	  <listitem><para>
	      changed the user from your own to 
	      <systemitem class="username">lixa</systemitem> user
	  </para></listitem>
	  <listitem><para>
	      checked the <command>lixad</command> daemon was running
	  </para></listitem>
	  <listitem><para>
	      stopped the <command>lixad</command> daemon
	  </para></listitem>
	  <listitem><para>
	      checked the <command>lixad</command> daemon was not running
	  </para></listitem>
	  <listitem><para>
	      checked the <command>lixad</command>'s state files
	  </para></listitem>
	  <listitem><para>
	      removed the <command>lixad</command>'s state files
	  </para></listitem>
	  <listitem><para>
	      started the <command>lixad</command> daemon
	  </para></listitem>
	  <listitem><para>
	      checked the new <command>lixad</command>'s state files
	  </para></listitem>
	</itemizedlist>
	Running <command>lixat</command> does <emphasis>not</emphasis>
	automatically recover the transaction:
	<table frame="box">
	  <thead><tr><td>[Shell terminal session]</td></tr></thead>
	  <tbody><tr><td><screen>
tiian@ubuntu:~/tmp$ export LIXA_TRACE_MASK=0x00040000
tiian@ubuntu:~/tmp$ /opt/lixa/bin/lixat 
tx_open(): 0
tx_close(): 0
	  </screen></td></tr></tbody>
	</table>
	<note><para>
	    The program does not produce trace because
	    <quote>client recovery</quote> module is not called (the 
	    state server does not pass information about recovery 
	    pending transactions to the LIXA client library).
	</para></note>
	<table frame="box">
	  <thead><tr><td>[Oracle terminal session]</td></tr></thead>
	  <tbody><tr><td><screen>
SQL> select * from dba_pending_transactions;

  FORMATID
----------
GLOBALID
--------------------------------------------------------------------------------
BRANCHID
--------------------------------------------------------------------------------
1279875137
957747F7F37B439EBCEA4146076AD322
9BAC7BE1C129EA6EE31F2D71B318120C
	  </screen></td></tr></tbody>
	</table>
	<table frame="box">
	  <thead><tr><td>[PostgreSQL terminal session]</td></tr></thead>
	  <tbody><tr><td><screen>
testdb=> select * from pg_prepared_xacts;
 transaction |                                    gid                                     |           prepared            | owner | database 
-------------+----------------------------------------------------------------------------+-------------------------------+-------+----------
         877 | 4c495841.957747f7f37b439ebcea4146076ad322.9bac7be1c129ea6ee31f2d71b318120c | 2011-12-14 22:55:14.973443+01 | tiian | testdb
	  </screen></td></tr></tbody>
	</table>
	The <command>lixar</command> utility program with <option>-p</option>
	option can be used to list the prepared transactions that can not be
	automatically recovered:
	<table frame="box">
	  <thead><tr><td>[Shell terminal session]</td></tr></thead>
	  <tbody><tr><td><screen>
tiian@ubuntu:~/tmp$ /opt/lixa/bin/lixar -p
Execution options:
	- print report = yes
	- transaction(s) will be committed = no
	- transaction(s) will be rolled back = no
	- bypass xid branch qualifier check = no
	- bypass xid format id check = no
	- use TMENDRSCAN flag for last xa_recover call = no

Recovery environment:
LIXA_CONFIG_FILE_ENV_VAR = '(null)'
LIXA_PROFILE_ENV_VAR = 'PQL_STA_ORA_DYN'
LIXA_JOB_ENV_VAR = '(null)'

Resource manager list:
rmid=0, lixa_name='PostgreSQL_stareg', xa_name='PostgreSQL[LIXA]'
rmid=1, lixa_name='OracleXE_dynreg', xa_name='Oracle_XA'

Prepared and in-doubt transaction list:
xid='4c495841.957747f7f37b439ebcea4146076ad322.9bac7be1c129ea6ee31f2d71b318120c': rmid=0 rmid=1 
	  </screen></td></tr></tbody>
	</table>
	it reports some useful information and at the bottom there is the
	list of in-doubt transactions. 
	The transaction is prepared/in-doubt for both Resource Managers;
	sometimes it may be only for a subset of the Resource Managers
	defined by <varname>LIXA_PROFILE</varname>.
	You can manually recover the transaction using
	the <option>-x</option> and <option>-r</option> (rollback) or
	<option>-c</option> (commit):
	<table frame="box">
	  <thead><tr><td>[Shell terminal session]</td></tr></thead>
	  <tbody><tr><td><screen>
tiian@ubuntu:~/tmp$ /opt/lixa/bin/lixar -p -x 4c495841.957747f7f37b439ebcea4146076ad322.9bac7be1c129ea6ee31f2d71b318120c -r
Execution options:
	- print report = yes
	- transaction to commit/rollback = 4c495841.957747f7f37b439ebcea4146076ad322.9bac7be1c129ea6ee31f2d71b318120c
	- transaction(s) will be committed = no
	- transaction(s) will be rolled back = yes
	- bypass xid branch qualifier check = no
	- bypass xid format id check = no
	- use TMENDRSCAN flag for last xa_recover call = no

Recovery environment:
LIXA_CONFIG_FILE_ENV_VAR = '(null)'
LIXA_PROFILE_ENV_VAR = 'PQL_STA_ORA_DYN'
LIXA_JOB_ENV_VAR = '(null)'

Resource manager list:
rmid=0, lixa_name='PostgreSQL_stareg', xa_name='PostgreSQL[LIXA]'
rmid=1, lixa_name='OracleXE_dynreg', xa_name='Oracle_XA'

Prepared and in-doubt transaction list:
xid='4c495841.957747f7f37b439ebcea4146076ad322.9bac7be1c129ea6ee31f2d71b318120c': rmid=0 rmid=1 

Analizing transaction '4c495841.957747f7f37b439ebcea4146076ad322.9bac7be1c129ea6ee31f2d71b318120c':
xa_rollback --&gt; rmid=0, lixa_name='PostgreSQL_stareg', xa_name='PostgreSQL[LIXA]', rc=0
xa_rollback --&gt; rmid=1, lixa_name='OracleXE_dynreg', xa_name='Oracle_XA', rc=0
	  </screen></td></tr></tbody>
	</table>
	You can now verify there are no prepared/in-doubt transactions 
	inside the Resource Managers:
	<table frame="box">
	  <thead><tr><td>[Oracle terminal session]</td></tr></thead>
	  <tbody><tr><td><screen>
SQL> select * from dba_pending_transactions;

no rows selected
	  </screen></td></tr></tbody>
	</table>
	<table frame="box">
	  <thead><tr><td>[PostgreSQL terminal session]</td></tr></thead>
	  <tbody><tr><td><screen>
testdb=> select * from pg_prepared_xacts;
 transaction | gid | prepared | owner | database 
-------------+-----+----------+-------+----------
(0 rows)
	  </screen></td></tr></tbody>
	</table>
	We rolled back the deletion so the rows must be in place:
	<table frame="box">
	  <thead><tr><td>[Oracle terminal session]</td></tr></thead>
	  <tbody><tr><td><screen>
SQL> select * from COUNTRIES where COUNTRY_ID = 'RS';

COUNTR
------
COUNTRY_NAME
--------------------------------------------------------------------------------
 REGION_ID
----------
RS
Repubblica San Marino
	 1
	  </screen></td></tr></tbody>
	</table>
	<table frame="box">
	  <thead><tr><td>[PostgreSQL terminal session]</td></tr></thead>
	  <tbody><tr><td><screen>
testdb=> select * from AUTHORS;
 id | last_name | first_name 
----+-----------+------------
  1 | Foo       | Bar
	  </screen></td></tr></tbody>
	</table>
	You can retrieve some help from <command>lixar</command> with
	<option>-?</option> option:
	<table frame="box">
	  <thead><tr><td>[Shell terminal session]</td></tr></thead>
	  <tbody><tr><td><screen>
tiian@ubuntu:~/tmp$ /opt/lixa/bin/lixar -?
Usage:
  lixar [OPTION...] - LIXA recovery utility

Help Options:
  -?, --help                      Show help options

Application Options:
  -p, --print                     Print a report of all the prepared and in-doubt transactions compatible with current configuration and profile
  -x, --xid                       Select specified transaction for rollback/commit
  -X, --xid-file                  Select specified file as a list of transaction to rollback/commit
  -c, --commit                    Commit prepared &amp; in-doubt transactions
  -r, --rollback                  Rollback prepared &amp; in-doubt transactions
  -v, --version                   Print package info and exit
  -b, --bypass-bqual-check        Bypass xid branch qualifier check
  -B, --bypass-formatid-check     Bypass xid format id check
  -e, --use-tmendrscan-flag       Use TMENDRSCAN flag for last xa_recover call
	  </screen></td></tr></tbody>
	</table>
      </para>
    </section>
  </section>
  @@@ how to programmatically pick-up the branch qualifier?! @@@
</chapter>
