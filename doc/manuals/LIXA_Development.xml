<chapter xml:id="Development">
  <title>Developing C Application Programs</title>
  <para>
    This chapter explains how you can develop your own C application
    using the libraries and the tools supplied by LIXA project.
  </para>
  <para>
    LIXA project ships some example C programs you can find in 
    directory
    <filename>/opt/lixa/share/doc/lixa-X.Y.Z/examples/</filename> after
    software installation (see <xref linkend="Installation"/>).
  </para>
  <note><para>
    This chapter is focused on the C programming language. The COBOL 
    programming language is addressed by another dedicated chapter.
  </para></note>
  <section>
    <title>The TX (Transaction Demarcation) Specification</title>
    <para>
      LIXA project adopts the standard described in 
      <citation>TXspec</citation> as the API you should use when developing
      an Application Program.
    </para>
    <para>
      The API is very easy, it supplies C functions and COBOL routines.
      The following C example can be briefly explained:
      <programlisting>
/* include this header: it's the header associated to The TX (Transaction
   Demarcation) Specification */
#include &lt;tx.h&gt;

/* your stuff */

int main(int argc, char *argv[])
{
        /* use an int variable to pick-up function return code */
        int rc;
        
        /* use tx_open() to open ALL the Resource Managers associated to
           the current LIXA_PROFILE */
        if (TX_OK != (rc = tx_open()))
                /* this is an error, manage it! */

        /* put your stuff here ... */

        /* this function delimits the transaction begin */
        if (TX_OK != (rc = tx_begin()))
                /* this is an error, manage it! */

        /* put your commands about the Resource Managers here ... */

        /* this function commits the modification operated by the
           Resource Managers */
        if (TX_OK != (rc = tx_commit()))
                /* this is an error, manage it! */
        /* you can use tx_rollback() instead of tx_commit() if you decide
           the work must be rolled back */

        /* put here other transactions if you need them (loops are possible
           too) */

        /* use tx_close() to close ALL the Resource Managers associated to
           the current LIXA_PROFILE */
}
      </programlisting>
      These are the available C functions (the descriptions come from
      <citation>TXspec</citation>):
      <itemizedlist mark="bullet">
	<listitem><para>
	    <function>tx_begin</function>: begin a global transaction
	</para></listitem>
	<listitem><para>
	    <function>tx_close</function>: close a set of resource managers
 	</para></listitem>
	<listitem><para>
	    <function>tx_commit</function>: commit a global transaction
	</para></listitem>
	<listitem><para>
	    <function>tx_info</function>: return global transaction information
	</para></listitem>
	<listitem><para>
	    <function>tx_open</function>: open a set of resource managers
	</para></listitem>
	<listitem><para>
	    <function>tx_rollback</function>: roll back a global transaction
	</para></listitem>
	<listitem><para>
	    <function>tx_set_commit_return</function>: set 
	    <parameter class="function">commit_return</parameter> 
	    characteristic
	</para></listitem>
	<listitem><para>
	    <function>tx_set_transaction_control</function>: set
	    <parameter class="function">transaction_control</parameter> 
	    characteristic
	</para></listitem>
	<listitem><para>
	    <function>tx_set_transaction_timeout</function>: set
	    <parameter class="function">transaction_timeout</parameter> 
	    characteristic
	</para></listitem>
      </itemizedlist>
      Refer to <citation>TXspec</citation> for the complete description.
    </para>
    <section>
      <title>Access to the resource managers</title>
      <para>
	A program developed for TX (Transaction Demarcation) Specification
	<emphasis>must</emphasis> access the resource managers coordinated by
	the transaction manager using specific functions.
	Unfortunately, the TX Specification does <emphasis>not</emphasis>
	specify a standard unified method to access a coordinated resource
	manager. 
      </para>
      <para>
	Tipically, every resource manager provides its own specific
	function(s) to retrieve one or more <emphasis>connection 
	  handler(s)</emphasis>. Once you have got the right connection
	handler(s), you can use the resource manager as you use without a
	transaction manager.
      </para>
      <para>
	The supplied examples (see <filename>doc/examples</filename> directory)
	show the functions that must be used to
	retrieve the connection handler(s) necessary to interact with
	the resource managers.
      </para>
      <note><para>
	  Special attention must be payed to <emphasis>commit</emphasis> and
	  <emphasis>rollback</emphasis> operations: a well designed program
	  developed for TX (Transaction Demarcation) Specification must not
	  specify the resource manager native version of 
	  <emphasis>commit</emphasis> and <emphasis>rollback</emphasis> 
	  operations.
	  If your software violates this rule, your environment will
	  generate warning conditions related to euristically completed
	  transaction. If your software forces a resource manager to
	  <emphasis>commit</emphasis> or <emphasis>rollback</emphasis> 
	  outside the control of the transaction manager, the transaction
	  manager will not be able to perform the opposite operation if
	  asked to do it. These situations tend to generate inconsistencies.
      </para></note>
    </section>
  </section>
  <section>
    <title>LIXA library linkage</title>
    <para>
      The examples showed in this chapter use these linkage options:
      <option>-Wl,-rpath -Wl,/opt/lixa/lib</option>
      dynamically generated by 
      <command>/opt/lixa/bin/lixa-config -d</command>
      (<command>/opt/lixa/bin/lixa-config --ldflags</command>).
      The options are specific to <command>gcc</command> and 
      <command>ld</command> Linux linker.
      Alternatively you can avoid these options and set
      <varname>LD_LIBRARY_PATH</varname> environment variable.
    </para>
  </section>
  <section>
    <title>The first example</title>
    <figure xml:id="develop1">
      <title>Deploy model of an example with two dummy resource managers</title>
      <mediaobject>
	<imageobject>
	  <imagedata fileref="../images/LIXA_Development_1.png"/>
	</imageobject>
      </mediaobject>
    </figure>
    <para>
      Create a working directory in a place you are comfortable with:
      <table frame="box">
	<thead><tr><td>[Shell terminal session]</td></tr></thead>
	<tbody><tr><td><screen>
tiian@ubuntu:~$ cd
tiian@ubuntu:~$ mkdir tmp
tiian@ubuntu:~$ cd tmp
tiian@ubuntu:~/tmp$
	</screen></td></tr></tbody>
      </table>
    </para>
    <para>
      Copy file <filename>example1.c</filename> in your working dir:
      <table frame="box">
	<thead><tr><td>[Shell terminal session]</td></tr></thead>
	<tbody><tr><td><screen>
tiian@ubuntu:~/tmp$ cp /opt/lixa/share/doc/lixa-X.Y.Z/examples/example1.c .
	</screen></td></tr></tbody>
      </table>
      Substitute <quote>lixa-X.Y.Z</quote> with the actual version of
      the software you installed.
    </para>
    <para>
      Compile and link the C example program:
      <table frame="box">
	<thead><tr><td>[Shell terminal session]</td></tr></thead>
	<tbody><tr><td><screen>
tiian@ubuntu:~/tmp$ gcc example1.c $(/opt/lixa/bin/lixa-config -c -f -l -d) -o example1
	</screen></td></tr></tbody>
      </table>
      Check the output of the linker:
      <table frame="box">
	<thead><tr><td>[Shell terminal session]</td></tr></thead>
	<tbody><tr><td><screen>
tiian@ubuntu:~/tmp$ ldd example1
        linux-gate.so.1 =>  (0xb773f000)
        liblixac.so.0 => /opt/lixa/lib/liblixac.so.0 (0xb7724000)
        libc.so.6 => /lib/tls/i686/cmov/libc.so.6 (0xb75d0000)
        libgmodule-2.0.so.0 => /usr/lib/libgmodule-2.0.so.0 (0xb75cb000)
        libdl.so.2 => /lib/tls/i686/cmov/libdl.so.2 (0xb75c7000)
        libgthread-2.0.so.0 => /usr/lib/libgthread-2.0.so.0 (0xb75c2000)
        librt.so.1 => /lib/tls/i686/cmov/librt.so.1 (0xb75b9000)
        libglib-2.0.so.0 => /usr/lib/libglib-2.0.so.0 (0xb7508000)
        libxml2.so.2 => /usr/lib/libxml2.so.2 (0xb73e8000)
        liblixab.so.0 => /opt/lixa/lib/liblixab.so.0 (0xb73d4000)
        libpthread.so.0 => /lib/tls/i686/cmov/libpthread.so.0 (0xb73bc000)
        /lib/ld-linux.so.2 (0xb7740000)
        libpcre.so.3 => /usr/lib/libpcre.so.3 (0xb7395000)
        libz.so.1 => /usr/lib/libz.so.1 (0xb7380000)
        libm.so.6 => /lib/tls/i686/cmov/libm.so.6 (0xb735b000)
        libuuid.so.1 => /lib/libuuid.so.1 (0xb7356000)
	</screen></td></tr></tbody>
      </table>
      Now you are ready to start your first application:
      <table frame="box">
	<thead><tr><td>[Shell terminal session]</td></tr></thead>
	<tbody><tr><td><screen>
tiian@ubuntu:~/tmp$ ./example1
tx_open(): -7
	</screen></td></tr></tbody>
      </table>
      The <function>tx_open()</function> function returned the value 
      <quote>-7</quote> (<constant>TX_FAIL</constant>) 
      because the state server is not running.
      Start the state server (see <xref linkend="Background_execution"/>)
      and try again:
      <table frame="box">
	<thead><tr><td>[Shell terminal session (Ubuntu)]</td></tr></thead>
	<tbody><tr><td><screen>
tiian@ubuntu:~/tmp$ sudo su - lixa
lixa@ubuntu:~$ /opt/lixa/sbin/lixad --daemon
lixa@ubuntu:~$ exit
logout
tiian@ubuntu:~/tmp$ ps -ef|grep lixad|grep -v grep
lixa     12866     1  0 21:35 ?        00:00:00 /opt/lixa/sbin/lixad --daemon
tiian@ubuntu:~/tmp$ ./example1
tx_open(): 0
tx_begin(): 0
tx_commit(): 0
tx_begin(): 0
tx_rollback(): 0
tx_close(): 0
	</screen></td></tr></tbody>
      </table>
      Your first program has connected to the state server and has performed
      two dummy distributed transactions: <emphasis>commit</emphasis> and 
      <emphasis>rollback</emphasis>.
    </para>
    <section xml:id="first_example_details">
      <title>Some details about the example</title>
      <para>
	You have not specified a specific profile:
	<table frame="box">
	  <thead><tr><td>[Shell terminal session]</td></tr></thead>
	  <tbody><tr><td><screen>
tiian@ubuntu:~/tmp$ echo $LIXA_PROFILE
	  </screen></td></tr></tbody>
	</table>
	The LIXA client library used the default one, the first listed in
	<filename>etc/lixac_conf.xml</filename>. If you inspected the 
	configuration file <filename>/opt/lixa/etc/lixac_conf.xml</filename> 
	you would see something like this:
	<table frame="box">
	  <thead><tr><td>[Shell terminal session]</td></tr></thead>
	  <tbody><tr><td><screen>
tiian@ubuntu:~/tmp$ cat /opt/lixa/etc/lixac_conf.xml
&lt;?xml version="1.0" encoding="UTF-8" ?&gt;
&lt;client&gt;
  &lt;sttsrvs&gt;
    &lt;sttsrv name="local_1" domain="AF_INET" address="127.0.0.1" port="2345" /&gt;
[...]
    &lt;rsrmgr name="LIXAdummyRM" switch_file="/opt/lixa/lib/switch_lixa_dummyrm.so" xa_open_info="dummy open string" xa_close_info="dummy close string" /&gt;
[...]
  &lt;profiles&gt;
    &lt;profile name="CF05"&gt;
      &lt;sttsrvs&gt;
        &lt;sttsrv&gt;local_1&lt;/sttsrv&gt;
      &lt;/sttsrvs&gt;
      &lt;rsrmgrs&gt;
        &lt;rsrmgr&gt;LIXAdummyRM&lt;/rsrmgr&gt;
        &lt;rsrmgr&gt;LIXAdummyRM&lt;/rsrmgr&gt;
      &lt;/rsrmgrs&gt;
    &lt;/profile&gt;
    &lt;profile name="GT71"&gt;
[...]
  &lt;/profiles&gt;
&lt;/client&gt;
	  </screen></td></tr></tbody>
	</table>
	The default profile is named <quote>CF05</quote> and lists two
	resource managers of the same type: <quote>LIXAdummyRM</quote>;
	the related switch file is the file 
	<filename>/opt/lixa/lib/switch_lixa_dummyrm.so</filename>.
	The dummy resource managers supplied by the LIXA project is
	a special trivial resource managers: it ever returns
	<constant>XA_OK</constant>. If you are interested in LIXA dummy
	Resource Manager implementation, take a look to the source file
	<filename>src/client/switch/lixa/lixa_dummyrm.c</filename>.
	To verify that the program is using the dummy resource manager,
	execute it with <varname>LIXA_TRACE_MASK</varname> environment
	variable set to <constant>0x00008000</constant>:
	<table frame="box">
	  <thead><tr><td>[Shell terminal session]</td></tr></thead>
	  <tbody><tr><td><screen>
tiian@ubuntu:~/tmp$ export LIXA_TRACE_MASK=0x00008000
tiian@ubuntu:~/tmp$ ./example1
[...]
2011-04-05 22:07:59.953844 [29359/3073444096] client_config_load_switch
2011-04-05 22:07:59.953875 [29359/3073444096] client_config_load_switch: resource manager # 0, name='LIXAdummyRM', switch_file='/opt/lixa/lib/switch_lixa_dummyrm.so'
2011-04-05 22:07:59.954220 [29359/3073444096] client_config_load_switch: module address 0x804e410, function lixa_get_xa_switch found at address 0xb76dd790
2011-04-05 22:07:59.954254 [29359/3073444096] client_config_load_switch: lixa_getxa_switch()->name = 'lixa_dummyrm', lixa_get_xa_switch()->flags = 0
2011-04-05 22:07:59.954279 [29359/3073444096] client_config_load_switch: resource manager dynamically registers: false
2011-04-05 22:07:59.954302 [29359/3073444096] client_config_load_switch: resource manager does not support association migration: false
2011-04-05 22:07:59.954325 [29359/3073444096] client_config_load_switch: resource manager supports asynchronous operations: false
2011-04-05 22:07:59.954348 [29359/3073444096] client_config_load_switch: resource manager # 1, name='LIXAdummyRM', switch_file='/opt/lixa/lib/switch_lixa_dummyrm.so'
2011-04-05 22:07:59.954379 [29359/3073444096] client_config_load_switch: module address 0x804e410, function lixa_get_xa_switch found at address 0xb76dd790
2011-04-05 22:07:59.954405 [29359/3073444096] client_config_load_switch: lixa_getxa_switch()->name = 'lixa_dummyrm', lixa_get_xa_switch()->flags = 0
2011-04-05 22:07:59.954429 [29359/3073444096] client_config_load_switch: resource manager dynamically registers: false
2011-04-05 22:07:59.954451 [29359/3073444096] client_config_load_switch: resource manager does not support association migration: false
2011-04-05 22:07:59.954474 [29359/3073444096] client_config_load_switch: resource manager supports asynchronous operations: false
[...]
tx_open(): 0
tx_begin(): 0
tx_commit(): 0
tx_begin(): 0
tx_rollback(): 0
2011-04-05 22:08:00.128531 [29359/3073444096] client_unconfig
2011-04-05 22:08:00.128883 [29359/3073444096] client_unconfig: acquiring exclusive mutex
2011-04-05 22:08:00.129174 [29359/3073444096] client_config_unload_switch
2011-04-05 22:08:00.129399 [29359/3073444096] client_config_unload_switch: resource manager # 0, defined in config as 'LIXAdummyRM', module address 0x804e410, xa_switch->name='lixa_dummyrm', xa_switch->flags=0
2011-04-05 22:08:00.129594 [29359/3073444096] client_config_unload_switch: resource manager # 1, defined in config as 'LIXAdummyRM', module address 0x804e410, xa_switch->name='lixa_dummyrm', xa_switch->flags=0
2011-04-05 22:08:00.129852 [29359/3073444096] client_config_unload_switch/excp=1/ret_cod=0/errno=0
2011-04-05 22:08:00.130024 [29359/3073444096] client_unconfig/xmlCleanupParser
2011-04-05 22:08:00.130215 [29359/3073444096] client_unconfig: releasing exclusive mutex
2011-04-05 22:08:00.130371 [29359/3073444096] client_unconfig/excp=2/ret_cod=0/errno=0
tx_close(): 0
	  </screen></td></tr></tbody>
	</table>
      </para>
    </section>
  </section>
  <section xml:id="Development_example2_ora">
    <title>An example with Oracle Database Server</title>
    <figure xml:id="develop2">
      <title>Deploy model of an example with Oracle Database Server</title>
      <mediaobject>
	<imageobject>
	  <imagedata fileref="../images/LIXA_Development_2.png"/>
	</imageobject>
      </mediaobject>
    </figure>
    <para>
      Using a real Resource Manager, like a DBMS, requires some extra effort
      because you have to set-up the environment needed by the Resource
      Manager. The example explained in this section was developed using two
      different configurations: 
      <itemizedlist mark="bullet">
	<listitem><para>
	  Oracle Database 10g Release 2 (10.2) Express Edition using a
	  <emphasis>local</emphasis> connection
	</para></listitem>
	<listitem><para>
	  Oracle Database 12c Release 1 (12.1) Standard Edition using a
	  <emphasis>remote (SqlNet)</emphasis> connection
	</para></listitem>
      </itemizedlist>
      If you used a different configuration, you might need to fix some of the
      details shown by these examples.
      <note><para>
	  If you did not yet installed the software provided by Oracle,
	  please refer to the official Oracle site to download the
	  software and to pick-up the information necessary to install 
	  and configure
	  the database. This manual does not give you information related
	  to Oracle technology: it is assumed you already installed and
	  configured the database.
      </para></note>
      <important><para>
      The LIXA software must be configured to support the Oracle Database
      Server resource manager as explained in 
      <xref linkend="Linking_third_party_resource_managers"/>.
      </para></important>
    </para>
    <section xml:id="Development_setup_Oracle_environment">
      <title>Set-up the Oracle environment (server side)</title>
      <section>
	<title>Start-up the Oracle server</title>
	<para>
	  If the database server was not running, you could start it
	  with these commands
	  <footnote><para>
	    Oracle 12c Standard Edition provides a different startup script,
	    see official documentation
	  </para></footnote> :
	  <screen>
tiian@ubuntu:~/tmp$ sudo /etc/init.d/oracle-xe enable
tiian@ubuntu:~/tmp$ sudo /etc/init.d/oracle-xe start
Starting Oracle Net Listener.
Starting Oracle Database 10g Express Edition Instance.
	  </screen>
	  on some systems, like Ubuntu 10.04, you would use somethig like
	  this:
	  <screen>
tiian@ubuntu:~/tmp$ sudo service oracle-xe enable
tiian@ubuntu:~/tmp$ sudo service oracle-xe start
Starting Oracle Net Listener.
Starting Oracle Database 11g Express Edition Instance.
	  </screen>
	</para>
      </section>
      <section>
	<title>Create the XA related views</title>
	<para>
	  First of all you must be able to connect as <quote>SYSDBA</quote>
	  from a terminal session; the commands below show what happens when
	  I connect to the Oracle server using the user 
	  <systemitem class="username">sys</systemitem> with password
	  <quote>oracle</quote>
	  <footnote><para>
	      I put this line (Oracle 10.2 32 bit)
	      <computeroutput>. /usr/lib/oracle/xe/app/oracle/product/10.2.0/server/bin/oracle_env.sh</computeroutput>
	      or this line (Oracle 11.2 64 bit)
	      <computeroutput>. /u01/app/oracle/product/11.2.0/xe/bin/oracle_env.sh</computeroutput>
	      in the file <filename>$HOME/.profile</filename> of the
	      <systemitem class="username">oracle</systemitem> user to set-up
	      the default administration environment; it complains about
	      two shell errors, but for the sake of our example it's
	      safe.
	  </para></footnote>
	  <footnote><para>
	      If you got some errors like these:
	      <screen>
/usr/lib/oracle/xe/app/oracle/product/10.2.0/server/bin/nls_lang.sh: 114: [[: not found
/usr/lib/oracle/xe/app/oracle/product/10.2.0/server/bin/nls_lang.sh: 114: [[: not found
	      </screen>
	      you could edit the file <filename>/usr/lib/oracle/xe/app/oracle/product/10.2.0/server/bin/nls_lang.sh</filename> and substitute 
	      <computeroutput>#!/bin/sh</computeroutput> with
	      <computeroutput>#!/bin/bash</computeroutput> in the first row as explained 
	      here:
	      <link xlink:href="http://forums.oracle.com/forums/thread.jspa?messageID=1542334">http://forums.oracle.com/forums/thread.jspa?messageID=1542334</link>
	  </para></footnote>:
	  <screen>
tiian@ubuntu:~$ sudo su - oracle
oracle@ubuntu:~$ echo $ORACLE_HOME
/usr/lib/oracle/xe/app/oracle/product/10.2.0/server
oracle@ubuntu:~$ sqlplus "sys/oracle as sysdba"

SQL*Plus: Release 10.2.0.1.0 - Production on Thu Apr 7 22:23:56 2011

Copyright (c) 1982, 2005, Oracle.  All rights reserved.


Connected to:
Oracle Database 10g Express Edition Release 10.2.0.1.0 - Production

SQL> exit
Disconnected from Oracle Database 10g Express Edition Release 10.2.0.1.0 - Production
	  </screen>
	  You must check the file <filename>xaview.sql</filename>:
	  <screen>
oracle@ubuntu:~$ ls -la $ORACLE_HOME/rdbms/admin/xaview.sql
-rw-r--r-- 1 oracle dba 1754 2006-02-24 06:18 /usr/lib/oracle/xe/app/oracle/product/10.2.0/server/rdbms/admin/xaview.sql
	  </screen>
	  It contains the SQL instructions necessary to create two specific
	  system views that could be not defined in your database; the
	  following commands are related to a database that contains
	  the desired views:
	  <screen>
oracle@ubuntu:~$ sqlplus "sys/oracle as sysdba"

SQL*Plus: Release 10.2.0.1.0 - Production on Thu Apr 7 22:32:45 2011

Copyright (c) 1982, 2005, Oracle.  All rights reserved.


Connected to:
Oracle Database 10g Express Edition Release 10.2.0.1.0 - Production

SQL> select * from v$pending_xatrans$;

no rows selected

SQL> select * from v$xatrans$;

no rows selected

SQL> exit
Disconnected from Oracle Database 10g Express Edition Release 10.2.0.1.0 - Production
	  </screen>
	  If the command failed the views would be not defined and you
	  would get something like this:
	  <screen>
oracle@ubuntu:~$ sqlplus "sys/oracle as sysdba"

SQL*Plus: Release 10.2.0.1.0 - Production on Fri Apr 29 22:20:01 2011

Copyright (c) 1982, 2005, Oracle.  All rights reserved.


Connected to:
Oracle Database 10g Express Edition Release 10.2.0.1.0 - Production

SQL> select * from v$pending_xatrans$;
select * from v$pending_xatrans$
              *
ERROR at line 1:
ORA-00942: table or view does not exist


SQL> select * from v$xatrans$;
select * from v$xatrans$
              *
ERROR at line 1:
ORA-00942: table or view does not exist


SQL> exit
Disconnected from Oracle Database 10g Express Edition Release 10.2.0.1.0 - Production
	  </screen>
	  you can create them with a command like this:
	  <screen>
oracle@ubuntu:~$ cat $ORACLE_HOME/rdbms/admin/xaview.sql | sqlplus "sys/oracle as sysdba"

SQL*Plus: Release 10.2.0.1.0 - Production on Fri Apr 29 22:25:48 2011

Copyright (c) 1982, 2005, Oracle.  All rights reserved.


Connected to:
Oracle Database 10g Express Edition Release 10.2.0.1.0 - Production

SQL> SQL> SQL> SQL> SQL> SQL> SQL> SQL> SQL> SQL> SQL> SQL> SQL> SQL> SQL> SQL> SQL> SQL> SQL> SQL> SQL> SQL> SQL> SQL> SQL> SQL> SQL> SQL> SQL> DROP VIEW v$xatrans$
*
ERROR at line 1:
ORA-00942: table or view does not exist


SQL> DROP VIEW v$pending_xatrans$
*
ERROR at line 1:
ORA-00942: table or view does not exist


SQL> SQL> SQL>   2    3    4    5    6    7    8
View created.

SQL> SQL> SQL> SQL>   2    3    4    5    6    7    8    9   10   11
View created.

SQL> SQL> SQL> Disconnected from Oracle Database 10g Express Edition Release 10.2.0.1.0 - Production
	  </screen>
	</para>
      </section>
      <note><para>
	All the above statements remain valid for Oracle 12c Standard Edition
	with the exception of the paths. Here's a default path installation
	example:
	<screen>
[oracle@centos7-oracle12 ~]$ ls -la $ORACLE_HOME/rdbms/admin/xaview.sql
-rw-r--r--. 1 oracle oinstall 1941 Apr 21  2011 /u01/app/oracle/product/12.1.0/dbhome_1/rdbms/admin/xaview.sql
	</screen>
      </para></note>
      <section>
	<title>Authorize the XA related views</title>
	<para>
	  The example programs supplied by the LIXA project are designed
	  to use the 
	  <systemitem class="username">hr</systemitem> user; you 
	  <emphasis>must</emphasis> grant
	  the necessary privileges to all the users you want to use for
	  your Application Programs. The below commands show how to grant
	  the necessary privileges to
	  <systemitem class="username">hr</systemitem>:
	  <screen>
oracle@ubuntu:~$ sqlplus "sys/oracle as sysdba"

SQL*Plus: Release 10.2.0.1.0 - Production on Thu Apr 7 22:44:44 2011

Copyright (c) 1982, 2005, Oracle.  All rights reserved.


Connected to:
Oracle Database 10g Express Edition Release 10.2.0.1.0 - Production

SQL> grant select on dba_pending_transactions to hr;

Grant succeeded.

SQL> grant select on v$pending_xatrans$ to hr;

Grant succeeded.

SQL> grant select on v$xatrans$ to hr;

Grant succeeded.

SQL> exit
Disconnected from Oracle Database 10g Express Edition Release 10.2.0.1.0 - Production
	  </screen>
	</para>
	<note><para>
	    If the user
	    <systemitem class="username">hr</systemitem> did not exist and
	    the above commands failed,
	    you should read Oracle documentation and pick-up the necessary
	    information to create it.
	</para></note>
      </section>
      <section>
	<title>Unlock <quote><systemitem class="username">hr</systemitem></quote> Oracle user</title>
	<para>
	  The example programs supplied by the LIXA project are designed
	  to use the 
	  <systemitem class="username">hr</systemitem> user; it might be 
	  <emphasis>locked</emphasis> after Oracle software installation.
	  The below commands show how to unlock it:
	  <screen>
oracle@ubuntu:~$ sqlplus "sys/oracle as sysdba"

SQL*Plus: Release 10.2.0.1.0 - Production on Thu Apr 7 22:44:44 2011

Copyright (c) 1982, 2005, Oracle.  All rights reserved.


Connected to:
Oracle Database 10g Express Edition Release 10.2.0.1.0 - Production

SQL> ALTER USER hr ACCOUNT UNLOCK;

User altered.

SQL> ALTER USER hr IDENTIFIED BY hr;

User altered.

SQL> exit
Disconnected from Oracle Database 10g Express Edition Release 10.2.0.1.0 - Production
	  </screen>
	  You may perform the same operation using the graphical (web based)
	  interface.
	</para>
      </section>
    </section>
    <section xml:id="Development_start_LIXA_server">
      <title>Start the LIXA state server</title>
      <para>
	Start the state server as shown below:
	<screen>
tiian@ubuntu:~$ sudo su - lixa
lixa@ubuntu:~$ /opt/lixa/sbin/lixad --daemon
lixa@ubuntu:~$ ps -ef|grep lixad|grep -v grep
lixa      6787     1  0 17:36 ?        00:00:00 /opt/lixa/sbin/lixad --daemon
lixa@ubuntu:~$ exit
logout
	</screen>
      </para>
    </section>
    <section>
      <title>Configure Oracle Listener (network config. only)</title>
      <note><para>
	If you want to access your database instance from a different system,
	you have to configure at least a <emphasis>listener</emphasis>.
      </para></note>
      <warning><para>
	Many recent Linux distributions, CentOS 7.x for example, automatically
	enable an internal firewall to prevent undesired accesses. If your
	firewall configuration does not allow Oracle traffic, you have no
	way to reach your database instance from a different system.
      </para></warning>
      <para>
	Here's a very basic example that accepts incoming connection from
	any network interface (IP address 0.0.0.0):
	<screen>
[oracle@centos7-oracle12 ~]$ cat $ORACLE_HOME/network/admin/listener.ora

LISTENER =
  (DESCRIPTION_LIST =
    (DESCRIPTION =
      (ADDRESS = (PROTOCOL = TCP)(HOST = 0.0.0.0)(PORT = 1521))
      (ADDRESS = (PROTOCOL = IPC)(KEY = EXTPROC1521))
    )
  )
	</screen>
	You can check that the listener is accepting connection with this
	command:
	<screen>
[oracle@centos7-oracle12 ~]$ netstat -unta | grep 1521 | grep LISTEN
tcp        0      0 0.0.0.0:1521            0.0.0.0:*               LISTEN     
	</screen>
	and you can check a connection from a different system with something
	like this (adjust your IP address, port and Global Database Name):
	<screen>
tiian@ubuntu1404-64:~$ sqlplus hr/hr@192.168.122.81:1521/orcl.brenta.org

SQL*Plus: Release 12.1.0.2.0 Production on Fri Jan 13 21:50:46 2017

Copyright (c) 1982, 2014, Oracle.  All rights reserved.

Last Successful login time: Fri Jan 13 2017 21:36:05 +01:00

Connected to:
Oracle Database 12c Standard Edition Release 12.1.0.2.0 - 64bit Production

SQL> exit
Disconnected from Oracle Database 12c Standard Edition Release 12.1.0.2.0 - 64bit Production
	</screen>
      </para>
    </section>
    <section>
      <title>Install and configure Oracle Instant Client (network config. only)
      </title>
      <note><para>
	If you want to execute your Application Program in a system different
	from the system that hosts the database instance, you have to
	install and configure Oracle Instant Client.
      </para></note>
      <para>
	Oracle Instant Client must be retrieved from Oracle portal. These are
	the suggested packages if you want to use LIXA:
	<screen>
instantclient-basic-linux.x64-12.1.0.2.0.zip
instantclient-precomp-linux.x64-12.1.0.2.0.zip
instantclient-sdk-linux.x64-12.1.0.2.0.zip
instantclient-sqlplus-linux.x64-12.1.0.2.0.zip
	</screen>
	For the Linux operating system you can choose between ".rpm" packages
	and ".zip" archives: feel free to install the packages as you prefer.
	Just an example, here's the final layout of a tested configuration
	for Ubuntu 14.04:
	<screen>
tiian@ubuntu1404-64:~/lixa$ find /opt/oracle/ | sort
/opt/oracle/
/opt/oracle/instantclient_12_1
/opt/oracle/instantclient_12_1/adrci
/opt/oracle/instantclient_12_1/BASIC_README
/opt/oracle/instantclient_12_1/cobsqlintf.o
/opt/oracle/instantclient_12_1/genezi
/opt/oracle/instantclient_12_1/glogin.sql
/opt/oracle/instantclient_12_1/libclntshcore.so.12.1
/opt/oracle/instantclient_12_1/libclntsh.so
/opt/oracle/instantclient_12_1/libclntsh.so.12.1
/opt/oracle/instantclient_12_1/libipc1.so
/opt/oracle/instantclient_12_1/libmql1.so
/opt/oracle/instantclient_12_1/libnnz12.so
/opt/oracle/instantclient_12_1/libocci.so
/opt/oracle/instantclient_12_1/libocci.so.12.1
/opt/oracle/instantclient_12_1/libociei.so
/opt/oracle/instantclient_12_1/libocijdbc12.so
/opt/oracle/instantclient_12_1/libons.so
/opt/oracle/instantclient_12_1/liboramysql12.so
/opt/oracle/instantclient_12_1/libsqlplusic.so
/opt/oracle/instantclient_12_1/libsqlplus.so
/opt/oracle/instantclient_12_1/network
/opt/oracle/instantclient_12_1/network/admin
/opt/oracle/instantclient_12_1/network/admin/tnsnames.ora
/opt/oracle/instantclient_12_1/ojdbc6.jar
/opt/oracle/instantclient_12_1/ojdbc7.jar
/opt/oracle/instantclient_12_1/precomp
/opt/oracle/instantclient_12_1/precomp/admin
/opt/oracle/instantclient_12_1/precomp/admin/pcbcfg.cfg
/opt/oracle/instantclient_12_1/precomp/admin/pcscfg.cfg
/opt/oracle/instantclient_12_1/PRECOMP_README
/opt/oracle/instantclient_12_1/sdk
/opt/oracle/instantclient_12_1/sdk/admin
/opt/oracle/instantclient_12_1/sdk/admin/oraaccess.xsd
/opt/oracle/instantclient_12_1/sdk/demo
/opt/oracle/instantclient_12_1/sdk/demo/cdemo81.c
/opt/oracle/instantclient_12_1/sdk/demo/demo.mk
/opt/oracle/instantclient_12_1/sdk/demo/demo_proc_ic.mk
/opt/oracle/instantclient_12_1/sdk/demo/demo_procob_ic.mk
/opt/oracle/instantclient_12_1/sdk/demo/occidemod.sql
/opt/oracle/instantclient_12_1/sdk/demo/occidemo.sql
/opt/oracle/instantclient_12_1/sdk/demo/occidml.cpp
/opt/oracle/instantclient_12_1/sdk/demo/occiobj.cpp
/opt/oracle/instantclient_12_1/sdk/demo/occiobj.typ
/opt/oracle/instantclient_12_1/sdk/demo/oraaccess.xml
/opt/oracle/instantclient_12_1/sdk/demo/procdemo.pc
/opt/oracle/instantclient_12_1/sdk/demo/procobdemo.pco
/opt/oracle/instantclient_12_1/sdk/demo/setuporamysql.sh
/opt/oracle/instantclient_12_1/sdk/include
/opt/oracle/instantclient_12_1/sdk/include/ldap.h
/opt/oracle/instantclient_12_1/sdk/include/nzerror.h
/opt/oracle/instantclient_12_1/sdk/include/nzt.h
/opt/oracle/instantclient_12_1/sdk/include/occiAQ.h
/opt/oracle/instantclient_12_1/sdk/include/occiCommon.h
/opt/oracle/instantclient_12_1/sdk/include/occiControl.h
/opt/oracle/instantclient_12_1/sdk/include/occiData.h
/opt/oracle/instantclient_12_1/sdk/include/occi.h
/opt/oracle/instantclient_12_1/sdk/include/occiObjects.h
/opt/oracle/instantclient_12_1/sdk/include/oci1.h
/opt/oracle/instantclient_12_1/sdk/include/oci8dp.h
/opt/oracle/instantclient_12_1/sdk/include/ociap.h
/opt/oracle/instantclient_12_1/sdk/include/ociapr.h
/opt/oracle/instantclient_12_1/sdk/include/ocidef.h
/opt/oracle/instantclient_12_1/sdk/include/ocidem.h
/opt/oracle/instantclient_12_1/sdk/include/ocidfn.h
/opt/oracle/instantclient_12_1/sdk/include/ociextp.h
/opt/oracle/instantclient_12_1/sdk/include/oci.h
/opt/oracle/instantclient_12_1/sdk/include/ocikpr.h
/opt/oracle/instantclient_12_1/sdk/include/ocixmldb.h
/opt/oracle/instantclient_12_1/sdk/include/ocixstream.h
/opt/oracle/instantclient_12_1/sdk/include/odci.h
/opt/oracle/instantclient_12_1/sdk/include/oraca.h
/opt/oracle/instantclient_12_1/sdk/include/oratypes.h
/opt/oracle/instantclient_12_1/sdk/include/orid.h
/opt/oracle/instantclient_12_1/sdk/include/ori.h
/opt/oracle/instantclient_12_1/sdk/include/orl.h
/opt/oracle/instantclient_12_1/sdk/include/oro.h
/opt/oracle/instantclient_12_1/sdk/include/ort.h
/opt/oracle/instantclient_12_1/sdk/include/sql2oci.h
/opt/oracle/instantclient_12_1/sdk/include/sqlapr.h
/opt/oracle/instantclient_12_1/sdk/include/sqlca.h
/opt/oracle/instantclient_12_1/sdk/include/sqlcpr.h
/opt/oracle/instantclient_12_1/sdk/include/sqlda.h
/opt/oracle/instantclient_12_1/sdk/include/sqlkpr.h
/opt/oracle/instantclient_12_1/sdk/include/sqlucs2.h
/opt/oracle/instantclient_12_1/sdk/include/xa.h
/opt/oracle/instantclient_12_1/sdk/ott
/opt/oracle/instantclient_12_1/sdk/ottclasses.zip
/opt/oracle/instantclient_12_1/sdk/proc
/opt/oracle/instantclient_12_1/sdk/procob
/opt/oracle/instantclient_12_1/sdk/rtsora
/opt/oracle/instantclient_12_1/sdk/SDK_README
/opt/oracle/instantclient_12_1/sqlplus
/opt/oracle/instantclient_12_1/SQLPLUS_README
/opt/oracle/instantclient_12_1/uidrvci
/opt/oracle/instantclient_12_1/xstreams.jar
	</screen>
	If your installation layout is different, adjust the following steps
	as necessary.
      </para>
      <para>
	Some environment variables can be very handy and I suggest you to use
	at least three. You can create a simple shell script like this one:
	<screen>
#!/bin/sh
export LD_LIBRARY_PATH=/opt/oracle/instantclient_12_1:$LD_LIBRARY_PATH
export PATH=/opt/oracle/instantclient_12_1:/opt/oracle/instantclient_12_1/sdk:$PATH
export ORACLE_HOME=/opt/oracle/instantclient_12_1
	</screen>
	and use it when needed with the shell sourcing:
	<screen>
tiian@ubuntu1404-64:~$ . ./oracle_env.sh 
tiian@ubuntu1404-64:~$ echo $LD_LIBRARY_PATH
/opt/oracle/instantclient_12_1:
tiian@ubuntu1404-64:~$ echo $PATH
/opt/oracle/instantclient_12_1:/opt/oracle/instantclient_12_1/sdk:/usr/local/sbin:/usr/local/bin:/usr/sbin:/usr/bin:/sbin:/bin:/usr/games:/usr/local/games
tiian@ubuntu1404-64:~$ echo $ORACLE_HOME
/opt/oracle/instantclient_12_1
	</screen>
	A possible option to configure a remote database is based on the 
	"tnsnames.ora" file. It should be put at path 
	<screen>
	$ORACLE_HOME/network/admin/tnsnames.ora
	</screen>
	Here's an example:
	<screen>
lixa_ora_db=
  (DESCRIPTION=
     (ADDRESS=(PROTOCOL=tcp)(HOST=centos7-oracle12.brenta.org)(PORT=1521))
     (CONNECT_DATA=
        (SERVICE_NAME=orcl.brenta.org)))
	</screen>
	<note><para>
	  Configuring Oracle networking feature requires a little bit of
	  experience: be patient and consult official documentation and
	  user group forums to obtain a right configuration.
	</para></note>
      </para>
      <para>
	The final step is the configuration check. If everything is OK, you
	should obtain something like this:
	<screen>
tiian@ubuntu1404-64:~$ sqlplus hr/hr@lixa_ora_db

SQL*Plus: Release 12.1.0.2.0 Production on Fri Jan 13 21:36:05 2017

Copyright (c) 1982, 2014, Oracle.  All rights reserved.

Last Successful login time: Fri Jan 13 2017 21:35:16 +01:00

Connected to:
Oracle Database 12c Standard Edition Release 12.1.0.2.0 - 64bit Production

SQL> select * from COUNTRIES where COUNTRY_ID = 'RS';

no rows selected

SQL> exit
Disconnected from Oracle Database 12c Standard Edition Release 12.1.0.2.0 - 64bit Production
	</screen>
      </para>
    </section>
    <section>
      <title>Build the client program</title>
      <para>
	Prepare the client (Application Program) using the below commands
	(<command>gcc</command> command was splitted on several lines 
	using <command>\</command> to help readability, but you may use
	a single line):
	<screen>
tiian@ubuntu:~$ mkdir tmp
tiian@ubuntu:~$ cd tmp
tiian@ubuntu:~/tmp$ cp /opt/lixa/share/doc/lixa-X.Y.Z/examples/example2_ora.c .
tiian@ubuntu:~/tmp$ gcc example2_ora.c $(/opt/lixa/bin/lixa-config -c -f -l -d) \
> -I/usr/lib/oracle/xe/app/oracle/product/10.2.0/server/rdbms/public \
> -L/usr/lib/oracle/xe/app/oracle/product/10.2.0/server/lib -l clntsh -l nnz10 \
> -o example2_ora
	</screen>
	If you are using Oracle XE 11.2 the commands might be something like
	these:
	<screen>
tiian@ubuntu:~$ mkdir tmp
tiian@ubuntu:~$ cd tmp
tiian@ubuntu:~/tmp$ cp /opt/lixa/share/doc/lixa-X.Y.Z/examples/example2_ora.c .
tiian@ubuntu:~/tmp$ gcc example2_ora.c $(/opt/lixa/bin/lixa-config -c -f -l -d) \
> -I/u01/app/oracle/product/11.2.0/xe/rdbms/public/ \
> -L/u01/app/oracle/product/11.2.0/xe/lib/ -l clntsh -l nnz11 \
> -o example2_ora
	</screen>
	If you are using Oracle Instant Client the paths are slightly 
	different:
	<screen>
tiian@ubuntu1404-64:/tmp$ cp /opt/lixa/share/doc/lixa-X.Y.Z/examples/example2_ora.c .
tiian@ubuntu1404-64:/tmp$ gcc example2_ora.c $(/opt/lixa/bin/lixa-config -c -f -l -d) \
> -I /opt/oracle/instantclient_12_1/sdk/include/ \
> -L /opt/oracle/instantclient_12_1/ -l clntsh -l nnz12 \
> -o example2_ora
	</screen>
	Verify the executable produced by <command>gcc</command>:
	<screen>
tiian@ubuntu:~/tmp$ ldd example2_ora
        linux-gate.so.1 =>  (0xb7709000)
        liblixac.so.0 => /opt/lixa/lib/liblixac.so.0 (0xb76ee000)
        libclntsh.so.10.1 => not found
        libnnz10.so => not found
        libc.so.6 => /lib/tls/i686/cmov/libc.so.6 (0xb7590000)
        libgmodule-2.0.so.0 => /usr/lib/libgmodule-2.0.so.0 (0xb758c000)
        libdl.so.2 => /lib/tls/i686/cmov/libdl.so.2 (0xb7588000)
        libgthread-2.0.so.0 => /usr/lib/libgthread-2.0.so.0 (0xb7583000)
        librt.so.1 => /lib/tls/i686/cmov/librt.so.1 (0xb7579000)
        libglib-2.0.so.0 => /usr/lib/libglib-2.0.so.0 (0xb74c8000)
        libxml2.so.2 => /usr/lib/libxml2.so.2 (0xb73a8000)
        liblixab.so.0 => /opt/lixa/lib/liblixab.so.0 (0xb7393000)
        libm.so.6 => /lib/tls/i686/cmov/libm.so.6 (0xb736e000)
        libpthread.so.0 => /lib/tls/i686/cmov/libpthread.so.0 (0xb7356000)
        /lib/ld-linux.so.2 (0xb770a000)
        libpcre.so.3 => /usr/lib/libpcre.so.3 (0xb732e000)
        libz.so.1 => /usr/lib/libz.so.1 (0xb7319000)
        libuuid.so.1 => /lib/libuuid.so.1 (0xb7315000)
	</screen>
      </para>
    </section>
    <section>
      <title>Set-up LIXA environment</title>
      <para>
	There are three unresolved references that can be fixed setting up
	the environment properly:
	<screen>
tiian@ubuntu:~/tmp$ echo $LD_LIBRARY_PATH

tiian@ubuntu:~/tmp$ export LD_LIBRARY_PATH=/usr/lib/oracle/xe/app/oracle/product/10.2.0/server/lib

tiian@ubuntu:~/tmp$ echo $LD_LIBRARY_PATH
/usr/lib/oracle/xe/app/oracle/product/10.2.0/server/lib
	</screen>
	Check again the executable:
	<screen>
tiian@ubuntu:~/tmp$ ldd example2_ora
        linux-gate.so.1 =>  (0xb76f9000)
        liblixac.so.0 => /opt/lixa/lib/liblixac.so.0 (0xb76de000)
        libclntsh.so.10.1 => /usr/lib/oracle/xe/app/oracle/product/10.2.0/server/lib/libclntsh.so.10.1 (0xb692a000)
        libnnz10.so => /usr/lib/oracle/xe/app/oracle/product/10.2.0/server/lib/libnnz10.so (0xb6724000)
        libc.so.6 => /lib/tls/i686/cmov/libc.so.6 (0xb65c7000)
        libgmodule-2.0.so.0 => /usr/lib/libgmodule-2.0.so.0 (0xb65c3000)
        libdl.so.2 => /lib/tls/i686/cmov/libdl.so.2 (0xb65bf000)
        libgthread-2.0.so.0 => /usr/lib/libgthread-2.0.so.0 (0xb65ba000)
        librt.so.1 => /lib/tls/i686/cmov/librt.so.1 (0xb65b0000)
        libglib-2.0.so.0 => /usr/lib/libglib-2.0.so.0 (0xb64ff000)
        libxml2.so.2 => /usr/lib/libxml2.so.2 (0xb63df000)
        liblixab.so.0 => /opt/lixa/lib/liblixab.so.0 (0xb63ca000)
        libm.so.6 => /lib/tls/i686/cmov/libm.so.6 (0xb63a5000)
        libpthread.so.0 => /lib/tls/i686/cmov/libpthread.so.0 (0xb638d000)
        libnsl.so.1 => /lib/tls/i686/cmov/libnsl.so.1 (0xb6374000)
        /lib/ld-linux.so.2 (0xb76fa000)
        libpcre.so.3 => /usr/lib/libpcre.so.3 (0xb634d000)
        libz.so.1 => /usr/lib/libz.so.1 (0xb6338000)
        libuuid.so.1 => /lib/libuuid.so.1 (0xb6334000)
	</screen>
	Set-up the necessary environment variables.
	Here's an example for Oracle XE 10.2 using a local connection and the
	SID identifier:
	<screen>
tiian@ubuntu:~/tmp$ echo $LIXA_PROFILE

tiian@ubuntu:~/tmp$ export LIXA_PROFILE=ORA_DYN
tiian@ubuntu:~/tmp$ echo $LIXA_PROFILE
ORA_DYN

tiian@ubuntu:~/tmp$ echo $ORACLE_HOME

tiian@ubuntu:~/tmp$ export ORACLE_HOME=/usr/lib/oracle/xe/app/oracle/product/10.2.0/server
tiian@ubuntu:~/tmp$ echo $ORACLE_HOME
/usr/lib/oracle/xe/app/oracle/product/10.2.0/server

tiian@ubuntu:~/tmp$ echo $PATH
/usr/local/sbin:/usr/local/bin:/usr/sbin:/usr/bin:/sbin:/bin:/usr/games
tiian@ubuntu:~/tmp$ export PATH=$PATH:$ORACLE_HOME/bin
tiian@ubuntu:~/tmp$ echo $PATH
/usr/local/sbin:/usr/local/bin:/usr/sbin:/usr/bin:/sbin:/bin:/usr/games:/usr/lib/oracle/xe/app/oracle/product/10.2.0/server/bin

tiian@ubuntu:~/tmp$ echo $ORACLE_SID

tiian@ubuntu:~/tmp$ export ORACLE_SID=XE
tiian@ubuntu:~/tmp$ echo $ORACLE_SID
XE
	</screen>
	Here's an example for Oracle Instant Client 12.1 using a remote
	connection and the service name (see above for tnsnames.ora);
	<screen>
tiian@ubuntu1404-64:/tmp$ echo $PATH
/opt/oracle/instantclient_12_1:/opt/oracle/instantclient_12_1/sdk:/usr/local/sbin:/usr/local/bin:/usr/sbin:/usr/bin:/sbin:/bin:/usr/games:/usr/local/games
tiian@ubuntu1404-64:/tmp$ echo $LD_LIBRARY_PATH
/opt/oracle/instantclient_12_1:
tiian@ubuntu1404-64:/tmp$ echo $ORACLE_HOME
/opt/oracle/instantclient_12_1
tiian@ubuntu1404-64:/tmp$ export LIXA_PROFILE=ORAOCI_DYN
tiian@ubuntu1404-64:/tmp$ echo $LIXA_PROFILE
ORAOCI_DYN
	</screen>

	It is suggested to set the necessary environment variables in your 
	profile if you are going to execute the programs many times.
	This is the list of the suggested variables:
	<varname>LD_LIBRARY_PATH</varname>,
	<varname>LIXA_PROFILE</varname>,
	<varname>ORACLE_HOME</varname>,
	<varname>ORACLE_SID</varname>.
	<important><para>
	    the third and fourth variables can be
	    set sourcing <filename>oracle_env.sh</filename> script: it's
	    installed in the Oracle's <filename>bin</filename> directory or
	    alternatively you have to edit your own as explained above.
	</para></important>
      </para>
    </section>
    <section>
      <title>Check the data table before execution</title>
      <para>
	Execute the below commands:
	<screen>
tiian@ubuntu:~$ sqlplus "hr/hr"<footnote><para>
  use <screen>sqlplus hr/hr@lixa_ora_db</screen> in the event that you are 
  using a remote connection as explained above
</para></footnote>

SQL*Plus: Release 10.2.0.1.0 - Production on Thu Apr 14 22:04:55 2011

Copyright (c) 1982, 2005, Oracle.  All rights reserved.


Connected to:
Oracle Database 10g Express Edition Release 10.2.0.1.0 - Production

SQL> select * from COUNTRIES where COUNTRY_ID = 'RS';

no rows selected

SQL> exit
Disconnected from Oracle Database 10g Express Edition Release 10.2.0.1.0 - Production
	</screen>
	That's OK because the table does not contain the row we 
	are going to insert.
      </para>
    </section>
    <section>
      <title>Some checks before program execution</title>
      <para>
	We set <varname>LIXA_PROFILE</varname> to value
	<quote>ORA_DYN</quote>, looking at
	<filename>/opt/lixa/etc/lixac_conf.xml</filename>:
	<screen>
    &lt;profile name="ORA_DYN"&gt;
      &lt;sttsrvs&gt;
        &lt;sttsrv&gt;local_1&lt;/sttsrv&gt;
      &lt;/sttsrvs&gt;
      &lt;rsrmgrs&gt;
        &lt;rsrmgr&gt;OracleXE_dynreg&lt;/rsrmgr&gt;
      &lt;/rsrmgrs&gt;
    &lt;/profile&gt;
	</screen>
	the profile references the Resource Manager named
	<quote>OracleXE_dynreg</quote>, looking again at the config file:
	<screen>
    &lt;rsrmgr name="OracleXE_dynreg" switch_file="/opt/lixa/lib/switch_oracle_dynreg.so" xa_open_info="Oracle_XA+Acc=P/hr/hr+SesTm=30+LogDir=/tmp+threads=true+DbgFl=7+Loose_Coupling=true" xa_close_info="" /&gt;
	</screen>
	we can discover that our application will access the Oracle
	database using <systemitem class="username">hr</systemitem>
	user and writing the trace file to directory <filename>/tmp</filename>
	(see <constant>LogDir</constant>)
	<footnote><para>
	    The content of <constant>xa_open_info</constant> string is
	    described in chapter 15 "Developing Applications with Oracle XA"
	    of the "Oracle Database Application Developer's Guide"
	    manual; please refer to the documentation published by
	    Oracle Corporation for further details.
	</para></footnote>. Verify no trace file exists:
	<screen>
tiian@ubuntu:~/tmp$ ls -la /tmp/xa*
ls: cannot access /tmp/xa*: No such file or directory
	</screen>
      </para>
    </section>
    <section>
      <title>Program execution (dynamic registration)</title>
      <para>
	Execute the client program as shown below:
	<screen>
tiian@ubuntu:~/tmp$ ./example2_ora
INSERT statement executed!
First arg is not 'DELETE', bypassing DELETE statement...
	</screen>
	Check the table after program execution:
	<screen>
tiian@ubuntu:~/tmp$ sqlplus "hr/hr"

SQL*Plus: Release 10.2.0.1.0 - Production on Sun Apr 10 10:34:23 2011

Copyright (c) 1982, 2005, Oracle.  All rights reserved.


Connected to:
Oracle Database 10g Express Edition Release 10.2.0.1.0 - Production

SQL> select * from COUNTRIES where COUNTRY_ID = 'RS';

CO COUNTRY_NAME                              REGION_ID
-- ---------------------------------------- ----------
RS Repubblica San Marino                             1

SQL> exit
Disconnected from Oracle Database 10g Express Edition Release 10.2.0.1.0 - Production
	</screen>
	The example program <filename>example2_ora</filename> inserted a
	row in table <constant>COUNTRIES</constant>. Take a look to the
	trace produced by the Oracle client library:
	<screen>
tiian@ubuntu:~/tmp$ ls -la /tmp/xa*
-rw-r--r-- 1 tiian tiian 1723 2011-04-10 10:33 /tmp/xa_NULL04102011.trc
tiian@ubuntu:~/tmp$ cat /tmp/xa_NULL04102011.trc

ORACLE XA: Version 10.2.0.1.0. RM name = 'Oracle_XA'.

103352.5300.3057182448.0:
xaoopen: xa_info=Oracle_XA+Acc=P/hr/hr+SesTm=30+LogDir=/tmp+threads=true+DbgFl=7+Loose_Coupling=true,rmid=0,flags=0x0

103352.5300.3057182448.0:
xaolgn_help: version#: 169869568 banner: Oracle Database 10g Express Edition Release 10.2.0.1.0 - Production

103352.5300.3057182448.0:
xaolgn: sqlxrc/sqlxss completed

103352.5300.3057182448.0:
xaolgn2: return XA_OK

103352.5300.3057182448.0:
xaoopen: xaolgn completed

103352.5300.3057182448.0:
xaoopen: return 0

103352.5300.3057182448.0:
ax_reg: xid=0x494c4158-8c6122ac9fd0477ebfe5f650e21a3539-a154ad9214d0544a3abbd33c8c2ba36f, rmid=0, flags=0x0

103352.5300.3057182448.0:
OCITransStart: Attempting

103352.5300.3057182448.0:
OCITransStart: Succeeded

103352.5300.3057182448.0:
xaodynpo 2: rmid=0, state=3

103352.5300.3057182448.0:
xaoend: xid=0x494c4158-8c6122ac9fd0477ebfe5f650e21a3539-a154ad9214d0544a3abbd33c8c2ba36f, rmid=0, flags=0x4000000

103352.5300.3057182448.0:
OCITransDetach: Attempting

103352.5300.3057182448.0:
OCITransDetach: Succeeded

103352.5300.3057182448.0:
xaoend: return 0

103352.5300.3057182448.0:
xaocommit: xid=0x494c4158-8c6122ac9fd0477ebfe5f650e21a3539-a154ad9214d0544a3abbd33c8c2ba36f, rmid=0, flags=0x40000000

103352.5300.3057182448.0:
OCITransCommit: Attempting

103352.5300.3057182448.0:
xaodynpo 2: rmid=0, state=1

103352.5300.3057182448.0:
OCITransCommit: Succeeded

103352.5300.3057182448.0:
xaocommit: rtn 0

103352.5300.3057182448.0:
xaoclose: xa_info=, rmid=0, flags=0x0

103352.5300.3057182448.0:
OCIServerDetach: Attempting

103352.5300.3057182448.0:
OCIServerDetach: Succeeded

103352.5300.3057182448.0:
xaoclose: rtn 0
	</screen>
	The <function>ax_reg</function> function was called because the
	dynamic registration configuration was used 
	(<constant>LIXA_PROFILE=ORA_DYN</constant>). 
	Now you can remove
	the inserted record using the same program:
	<screen>
tiian@ubuntu:~/tmp$ ./example2_ora delete
First arg is 'delete', bypassing INSERT statement...
DELETE statement executed!
	</screen>
	Check the content of the table again:
	<screen>
tiian@ubuntu:~/tmp$ sqlplus "hr/hr"

SQL*Plus: Release 10.2.0.1.0 - Production on Sun Apr 10 10:40:25 2011

Copyright (c) 1982, 2005, Oracle.  All rights reserved.


Connected to:
Oracle Database 10g Express Edition Release 10.2.0.1.0 - Production

SQL> select * from COUNTRIES where COUNTRY_ID = 'RS';

no rows selected

SQL> exit
Disconnected from Oracle Database 10g Express Edition Release 10.2.0.1.0 - Production
	</screen>
	The row was deleted. Please remove the trace file before a new
	execution:
	<screen>
tiian@ubuntu:~/tmp$ rm /tmp/xa_NULL04102011.trc
	</screen>
      </para>
    </section>
    <section>
      <title>Program execution (static registration)</title>
      <para>
	Switch from dynamic registration to static registration (local
	connection):
	<screen>
tiian@ubuntu:~/tmp$ echo $LIXA_PROFILE
ORA_DYN
tiian@ubuntu:~/tmp$ export LIXA_PROFILE=ORA_STA
tiian@ubuntu:~/tmp$ echo $LIXA_PROFILE
ORA_STA
	</screen>
	Here's the equivalent for the network connection using Oracle
	Instant Client:
	<screen>
tiian@ubuntu1404-64:/tmp$ echo $LIXA_PROFILE
ORAOCI_DYN
tiian@ubuntu1404-64:/tmp$ export LIXA_PROFILE=ORAOCI_STA
tiian@ubuntu1404-64:/tmp$ echo $LIXA_PROFILE
ORAOCI_STA	  
	</screen>
	Execute the program again:
	<screen>
tiian@ubuntu:~/tmp$ ./example2_ora
INSERT statement executed!
First arg is not 'DELETE', bypassing DELETE statement...
tiian@ubuntu:~/tmp$ sqlplus "hr/hr"

SQL*Plus: Release 10.2.0.1.0 - Production on Sun Apr 10 10:53:05 2011

Copyright (c) 1982, 2005, Oracle.  All rights reserved.


Connected to:
Oracle Database 10g Express Edition Release 10.2.0.1.0 - Production

SQL> select * from COUNTRIES where COUNTRY_ID = 'RS';

CO COUNTRY_NAME                              REGION_ID
-- ---------------------------------------- ----------
RS Repubblica San Marino                             1

SQL> exit
Disconnected from Oracle Database 10g Express Edition Release 10.2.0.1.0 - Production
	</screen>
	Inspect the produced trace file:
	<screen>
tiian@ubuntu:~/tmp$ ls -la /tmp/xa_*
-rw-r--r-- 1 tiian tiian 1661 2011-04-10 10:52 /tmp/xa_NULL04102011.trc
tiian@ubuntu:~/tmp$ cat /tmp/xa_NULL04102011.trc

ORACLE XA: Version 10.2.0.1.0. RM name = 'Oracle_XA'.

105236.5392.3057456880.0:
xaoopen: xa_info=Oracle_XA+Acc=P/hr/hr+SesTm=30+LogDir=/tmp+threads=true+DbgFl=7+Loose_Coupling=true,rmid=0,flags=0x0

105236.5392.3057456880.0:
xaolgn_help: version#: 169869568 banner: Oracle Database 10g Express Edition Release 10.2.0.1.0 - Production

105236.5392.3057456880.0:
xaolgn: sqlxrc/sqlxss completed

105236.5392.3057456880.0:
xaolgn: return XA_OK

105236.5392.3057456880.0:
xaoopen: xaolgn completed

105236.5392.3057456880.0:
xaoopen: return 0

105236.5392.3057456880.0:
xaostart: xid=0x494c4158-6119154810784a87b0d0aa83ea497a72-55263ef9237e27f8ae34f46936ce295d, rmid=0, flags=0x0

105236.5392.3057456880.0:
OCITransStart: Attempting

105236.5392.3057456880.0:
OCITransStart: Succeeded

105236.5392.3057456880.0:
xaostart: return XA_OK

105236.5392.3057456880.0:
xaoend: xid=0x494c4158-6119154810784a87b0d0aa83ea497a72-55263ef9237e27f8ae34f46936ce295d, rmid=0, flags=0x4000000

105236.5392.3057456880.0:
OCITransDetach: Attempting

105236.5392.3057456880.0:
OCITransDetach: Succeeded

105236.5392.3057456880.0:
xaoend: return 0

105236.5392.3057456880.0:
xaocommit: xid=0x494c4158-6119154810784a87b0d0aa83ea497a72-55263ef9237e27f8ae34f46936ce295d, rmid=0, flags=0x40000000

105236.5392.3057456880.0:
OCITransCommit: Attempting

105236.5392.3057456880.0:
OCITransCommit: Succeeded

105236.5392.3057456880.0:
xaocommit: rtn 0

105236.5392.3057456880.0:
xaoclose: xa_info=, rmid=0, flags=0x0

105236.5392.3057456880.0:
OCIServerDetach: Attempting

105236.5392.3057456880.0:
OCIServerDetach: Succeeded

105236.5392.3057456880.0:
xaoclose: rtn 0
	</screen>
	The <function>xa_start (xaostart)</function> function was called 
	because the static registration configuration was used 
	(<constant>LIXA_PROFILE=ORA_STA</constant>). 
	Remove the inserted row again:
	<screen>
tiian@ubuntu:~/tmp$ ./example2_ora delete
First arg is 'delete', bypassing INSERT statement...
DELETE statement executed!
tiian@ubuntu:~/tmp$ sqlplus "hr/hr"

SQL*Plus: Release 10.2.0.1.0 - Production on Sun Apr 10 11:01:32 2011

Copyright (c) 1982, 2005, Oracle.  All rights reserved.


Connected to:
Oracle Database 10g Express Edition Release 10.2.0.1.0 - Production

SQL> select * from COUNTRIES where COUNTRY_ID = 'RS';

no rows selected

SQL> exit
Disconnected from Oracle Database 10g Express Edition Release 10.2.0.1.0 - Production
	</screen>
	You have successfully executed an Application Program that uses Oracle
	Database Server as a Resource Manager.
      </para>
    </section>
  </section>
  <section xml:id="Development_example3_db2">
    <title>An example with IBM DB2 DBMS</title>
    <figure xml:id="develop3">
      <title>Deploy model of an example with IBM DB2 DBMS</title>
      <mediaobject>
	<imageobject>
	  <imagedata fileref="../images/LIXA_Development_3.png"/>
	</imageobject>
      </mediaobject>
    </figure>
    <para>
      This example was developed using DB2 Express-C 9.7 for Linux (Ubuntu).
      If you were using a different version you would need to adapt some
      commands to your environment.
    </para>
    <note><para>
	If you did not yet installed the software provided by IBM,
	please refer to the official IBM site to download the
	software and to pick-up the information necessary to install 
	and configure
	the database. This manual does not give you information related
	to IBM DB2 technology: it is assumed you already installed and
	configured the database.
    </para></note>
    <important><para>
	The LIXA software must be configured to support the IBM DB2
	server resource manager as explained in 
	<xref linkend="Linking_third_party_resource_managers"/>.
    </para></important>
    <section xml:id="Development_setup_DB2_environment">
      <title>Set-up DB2 environment</title>
      <section>
	<title>Start-up the DB2 server</title>
	<para>
	  If your server didn't start-up automatically at boot time, you
	  could start it with the following commands:
	  <screen>
tiian@ubuntu:~$ ps -ef | grep db2 | grep -v grep
tiian@ubuntu:~$ sudo /etc/init.d/db2exc start
  * Starting DAS:                       done.
  * Instance db2inst1 ( db2c_db2inst1 ):        done.
  * Activating database SAMPLE          done.
tiian@ubuntu:~$ ps -ef | grep db2 | grep -v grep
dasusr1  22959     1  0 10:54 pts/2    00:00:00 /home/dasusr1/das/adm/db2dasrrm
root     23190     1  2 10:54 pts/2    00:00:00 db2wdog                         
db2inst1 23192 23190  4 10:54 pts/2    00:00:01 db2sysc                         
root     23193 23192  0 10:54 pts/2    00:00:00 db2ckpwd                        
root     23194 23192  0 10:54 pts/2    00:00:00 db2ckpwd                        
root     23195 23192  0 10:54 pts/2    00:00:00 db2ckpwd                        
db2inst1 23206 23190  2 10:54 pts/2    00:00:00 db2acd   ,0,0,0,1,0,0,0,1,0,8a6614,14,1e014,2,0,1,11fd0,0x12600000,0x12600000,1600000,740002,2,a0800d
	  </screen>
	  Switch to user <systemitem class="username">db2inst1</systemitem>,
	  try to connect to database <quote>SAMPLE</quote>:
	  <screen>
tiian@ubuntu:~$ sudo su - db2inst1
db2inst1@ubuntu:~$ db2
(c) Copyright IBM Corporation 1993,2007
Command Line Processor for DB2 Client 9.7.1

You can issue database manager commands and SQL statements from the command
prompt. For example:
    db2 => connect to sample
    db2 => bind sample.bnd

For general help, type: ?.
For command help, type: ? command, where command can be
the first few keywords of a database manager command. For example:
 ? CATALOG DATABASE for help on the CATALOG DATABASE command
 ? CATALOG          for help on all of the CATALOG commands.

To exit db2 interactive mode, type QUIT at the command prompt. Outside
interactive mode, all commands must be prefixed with 'db2'.
To list the current command option settings, type LIST COMMAND OPTIONS.

For more detailed help, refer to the Online Reference Manual.

db2 => connect to sample

   Database Connection Information

 Database server        = DB2/LINUX 9.7.1
 SQL authorization ID   = DB2INST1
 Local database alias   = SAMPLE

	  </screen>
	  Check the tables <quote>ORG</quote> and <quote>DEPT</quote> exist
	  and contain some data:
	  <screen>
db2 => select * from ORG

DEPTNUMB DEPTNAME       MANAGER DIVISION   LOCATION
-------- -------------- ------- ---------- -------------
      10 Head Office        160 Corporate  New York
      15 New England         50 Eastern    Boston
      20 Mid Atlantic        10 Eastern    Washington
      38 South Atlantic      30 Eastern    Atlanta
      42 Great Lakes        100 Midwest    Chicago
      51 Plains             140 Midwest    Dallas
      66 Pacific            270 Western    San Francisco
      84 Mountain           290 Western    Denver

  8 record(s) selected.

db2 => select * from DEPT

DEPTNO DEPTNAME                             MGRNO  ADMRDEPT LOCATION
------ ------------------------------------ ------ -------- ----------------
A00    SPIFFY COMPUTER SERVICE DIV.         000010 A00      -
B01    PLANNING                             000020 A00      -
C01    INFORMATION CENTER                   000030 A00      -
D01    DEVELOPMENT CENTER                   -      A00      -
D11    MANUFACTURING SYSTEMS                000060 D01      -
D21    ADMINISTRATION SYSTEMS               000070 D01      -
E01    SUPPORT SERVICES                     000050 A00      -
E11    OPERATIONS                           000090 E01      -
E21    SOFTWARE SUPPORT                     000100 E01      -
F22    BRANCH OFFICE F2                     -      E01      -
G22    BRANCH OFFICE G2                     -      E01      -
H22    BRANCH OFFICE H2                     -      E01      -
I22    BRANCH OFFICE I2                     -      E01      -
J22    BRANCH OFFICE J2                     -      E01      -

  14 record(s) selected.

	  </screen>
	  OK, the <quote>ORG</quote> and <quote>DEPT</quote>
	  tables are populated. 
	  If something went wrong, you should refer to IBM DB2
	  documentation to fix the issue before the next step because
	  you would not be able to execute the sample program without a
	  basic running installation.
	</para>
      </section>
      <section xml:id="Development_setup_DB2_user_customization">
	<title>User customization</title>
	<para>
	  We want to execute our example program with a generic user,
	  not just using <systemitem class="username">db2inst1</systemitem>
	  because that's the system user dedicated to the database
	  instance execution. The commands below explain as the generic
	  user <systemitem class="username">tiian</systemitem> (my own 
	  user) can be used instead of 
	  <systemitem class="username">db2inst1</systemitem>.
	</para>
	<para>
	  Grant <constant>DBADM</constant> privilege to the user
	  <systemitem class="username">tiian</systemitem>:
	  <screen>
db2 => grant DBADM on database to user tiian
DB20000I  The SQL command completed successfully.
	  </screen>
	  <constant>DBADM</constant> is not the lowest authorization
	  level necessary to execute our example, but for the sake of 
	  this example it's a <quote>good enought</quote> choice.
	</para>
	<para>
	  Add something like the 4 lines below to your
	  <filename>$HOME/.profile</filename> or equivalent profile
	  configuration:
	  <screen>
# The following three lines have been added by IBM DB2 instance utilities.
if [ -f /home/db2inst1/sqllib/db2profile ]; then
    . /home/db2inst1/sqllib/db2profile
fi
	  </screen>
	  Then login again and check your environment:
	  <screen>
tiian@ubuntu:~$ env|grep -i db2
DB2INSTANCE=db2inst1
LD_LIBRARY_PATH=/home/db2inst1/sqllib/lib32
PATH=/usr/local/sbin:/usr/local/bin:/usr/sbin:/usr/bin:/sbin:/bin:/usr/games:/home/db2inst1/sqllib/bin:/home/db2inst1/sqllib/adm:/home/db2inst1/sqllib/misc:/home/db2inst1/sqllib/db2tss/bin
CLASSPATH=/home/db2inst1/sqllib/java/db2java.zip:/home/db2inst1/sqllib/java/db2jcc.jar:/home/db2inst1/sqllib/java/sqlj.zip:/home/db2inst1/sqllib/function:/home/db2inst1/sqllib/java/db2jcc_license_cu.jar:.
	  </screen>
	  As shown above,
	  <varname>DB2INSTANCE</varname>, <varname>LD_LIBRARY_PATH</varname>,
	  <varname>PATH</varname> variables should refer to DB2 stuff too.
	  Connect to the database using your own user instead of
	  <systemitem class="username">db2inst1</systemitem>:
	  <screen>
tiian@ubuntu:~$ db2
(c) Copyright IBM Corporation 1993,2007
Command Line Processor for DB2 Client 9.7.1

You can issue database manager commands and SQL statements from the command
prompt. For example:
    db2 => connect to sample
    db2 => bind sample.bnd

For general help, type: ?.
For command help, type: ? command, where command can be
the first few keywords of a database manager command. For example:
 ? CATALOG DATABASE for help on the CATALOG DATABASE command
 ? CATALOG          for help on all of the CATALOG commands.

To exit db2 interactive mode, type QUIT at the command prompt. Outside
interactive mode, all commands must be prefixed with 'db2'.
To list the current command option settings, type LIST COMMAND OPTIONS.

For more detailed help, refer to the Online Reference Manual.

db2 => connect to sample

   Database Connection Information

 Database server        = DB2/LINUX 9.7.1
 SQL authorization ID   = TIIAN
 Local database alias   = SAMPLE

db2 => select * from DB2INST1.ORG

DEPTNUMB DEPTNAME       MANAGER DIVISION   LOCATION
-------- -------------- ------- ---------- -------------
      10 Head Office        160 Corporate  New York
      15 New England         50 Eastern    Boston
      20 Mid Atlantic        10 Eastern    Washington
      38 South Atlantic      30 Eastern    Atlanta
      42 Great Lakes        100 Midwest    Chicago
      51 Plains             140 Midwest    Dallas
      66 Pacific            270 Western    San Francisco
      84 Mountain           290 Western    Denver

  8 record(s) selected.

db2 => select * from DB2INST1.DEPT

DEPTNO DEPTNAME                             MGRNO  ADMRDEPT LOCATION
------ ------------------------------------ ------ -------- ----------------
A00    SPIFFY COMPUTER SERVICE DIV.         000010 A00      -
B01    PLANNING                             000020 A00      -
C01    INFORMATION CENTER                   000030 A00      -
D01    DEVELOPMENT CENTER                   -      A00      -
D11    MANUFACTURING SYSTEMS                000060 D01      -
D21    ADMINISTRATION SYSTEMS               000070 D01      -
E01    SUPPORT SERVICES                     000050 A00      -
E11    OPERATIONS                           000090 E01      -
E21    SOFTWARE SUPPORT                     000100 E01      -
F22    BRANCH OFFICE F2                     -      E01      -
G22    BRANCH OFFICE G2                     -      E01      -
H22    BRANCH OFFICE H2                     -      E01      -
I22    BRANCH OFFICE I2                     -      E01      -
J22    BRANCH OFFICE J2                     -      E01      -

  14 record(s) selected.

db2 => quit
DB20000I  The QUIT command completed successfully.
	  </screen>
	  You have just verified that a generic user, like
	  <systemitem class="username">tiian</systemitem>	
	  in the example above, can connect to the database and execute
	  some query.
	</para>
      </section>
    </section>
    <section>
      <title>Start the LIXA state server</title>
      <para>
	Start the state server as shown below:
	<screen>
tiian@ubuntu:~$ sudo su - lixa
lixa@ubuntu:~$ /opt/lixa/sbin/lixad --daemon
lixa@ubuntu:~$ exit
logout
tiian@ubuntu:~$ ps -ef|grep lixad|grep -v grep
lixa     12866     1  0 21:35 ?        00:00:00 /opt/lixa/sbin/lixad --daemon
	</screen>
      </para>
    </section>
    <section>
      <title>Build the client program</title>
      <para>
	Prepare the client (Application Program) using the below commands
	(<command>gcc</command> command was splitted on several lines 
	using <command>\</command> to help readability, but you may use
	a single line):
	<screen>
tiian@ubuntu:~$ mkdir tmp
tiian@ubuntu:~$ cd tmp
tiian@ubuntu:~/tmp$ cp /opt/lixa/share/doc/lixa-X.Y.Z/examples/example3_db2.c .
tiian@ubuntu:~/tmp$ gcc example3_db2.c $(/opt/lixa/bin/lixa-config -c -f -l -d) \
> -I/opt/ibm/db2/V9.7/include -L/opt/ibm/db2/V9.7/lib32/ -ldb2 -o example3_db2
	</screen>
	Verify the executable produced by <command>gcc</command>:
	<screen>
tiian@ubuntu:~/tmp$ ldd example3_db2
        linux-gate.so.1 =>  (0xb775f000)
        liblixac.so.0 => /opt/lixa/lib/liblixac.so.0 (0xb7744000)
        libdb2.so.1 => /home/db2inst1/sqllib/lib32/libdb2.so.1 (0xb6212000)
        libc.so.6 => /lib/tls/i686/cmov/libc.so.6 (0xb60b4000)
        libgmodule-2.0.so.0 => /usr/lib/libgmodule-2.0.so.0 (0xb60b0000)
        libdl.so.2 => /lib/tls/i686/cmov/libdl.so.2 (0xb60ac000)
        libgthread-2.0.so.0 => /usr/lib/libgthread-2.0.so.0 (0xb60a7000)
        librt.so.1 => /lib/tls/i686/cmov/librt.so.1 (0xb609e000)
        libglib-2.0.so.0 => /usr/lib/libglib-2.0.so.0 (0xb5fed000)
        libxml2.so.2 => /usr/lib/libxml2.so.2 (0xb5ecc000)
        liblixab.so.0 => /opt/lixa/lib/liblixab.so.0 (0xb5eb9000)
        libpthread.so.0 => /lib/tls/i686/cmov/libpthread.so.0 (0xb5ea1000)
        libcrypt.so.1 => /lib/tls/i686/cmov/libcrypt.so.1 (0xb5e6e000)
        libpam.so.0 => /lib/libpam.so.0 (0xb5e64000)
        libm.so.6 => /lib/tls/i686/cmov/libm.so.6 (0xb5e3f000)
        libdb2dascmn.so.1 => /home/db2inst1/sqllib/lib32/libdb2dascmn.so.1 (0xb5e12000)
        libdb2g11n.so.1 => /home/db2inst1/sqllib/lib32/libdb2g11n.so.1 (0xb57a4000)
        libdb2genreg.so.1 => /home/db2inst1/sqllib/lib32/libdb2genreg.so.1 (0xb5763000)
        libdb2install.so.1 => /home/db2inst1/sqllib/lib32/libdb2install.so.1 (0xb5758000)
        libdb2locale.so.1 => /home/db2inst1/sqllib/lib32/libdb2locale.so.1 (0xb5745000)
        libdb2osse.so.1 => /home/db2inst1/sqllib/lib32/libdb2osse.so.1 (0xb5440000)
        libdb2osse_db2.so.1 => /home/db2inst1/sqllib/lib32/libdb2osse_db2.so.1 (0xb53d0000)
        libdb2trcapi.so.1 => /home/db2inst1/sqllib/lib32/libdb2trcapi.so.1 (0xb53bc000)
        libstdc++.so.6 => /usr/lib/libstdc++.so.6 (0xb52c9000)
        libgcc_s.so.1 => /lib/libgcc_s.so.1 (0xb52be000)
        /lib/ld-linux.so.2 (0xb7760000)
        libpcre.so.3 => /usr/lib/libpcre.so.3 (0xb5297000)
        libz.so.1 => /usr/lib/libz.so.1 (0xb5282000)
        libuuid.so.1 => /lib/libuuid.so.1 (0xb527d000)
	</screen>
      </para>
    </section>
    <section>
      <title>Set-up LIXA environment</title>
      <para>
	Set-up the <varname>LIXA_PROFILE</varname> environment variable:
	<screen>
tiian@ubuntu:~/tmp$ echo $LIXA_PROFILE

tiian@ubuntu:~/tmp$ export LIXA_PROFILE=DB2_DYN
tiian@ubuntu:~/tmp$ echo $LIXA_PROFILE
DB2_DYN
	</screen>
	No additional DB2 variables are needed because they are automatically
	set at login (see <xref linkend="Development_setup_DB2_environment"/>).
      </para>
    </section>
    <section>
      <title>Some checks before program execution</title>
      <para>
	We set <varname>LIXA_PROFILE</varname> to value
	<quote>DB2_DYN</quote>, looking at
	<filename>/opt/lixa/etc/lixac_conf.xml</filename>:
	<screen>
    &lt;profile name="DB2_DYN"&gt;
      &lt;sttsrvs&gt;
        &lt;sttsrv&gt;local_1&lt;/sttsrv&gt;
      &lt;/sttsrvs&gt;
      &lt;rsrmgrs&gt;
        &lt;rsrmgr&gt;IBMDB2_dynreg&lt;/rsrmgr&gt;
      &lt;/rsrmgrs&gt;
    &lt;/profile&gt;
	</screen>
	the profile references the Resource Manager named
	<quote>IBMDB2_dynreg</quote>, looking again at the config file:
	<screen>
    &lt;rsrmgr name="IBMDB2_dynreg" switch_file="/opt/lixa/lib/switch_ibmdb2_dynreg.so" xa_open_info="axlib=/opt/lixa/lib/liblixac.so,db=sample,tpm=lixa" xa_close_info="" /&gt;
	</screen>
	we can discover how the DB2 database is configured for XA
	<footnote><para>
	    The content of <constant>xa_open_info</constant> string is
	    documented at IBM Infocenter: search the string
	    <quote>xa_open string formats</quote> in the documentation
	    relevant to your installed version; this is a link
	    <link xlink:href="http://publib.boulder.ibm.com/infocenter/db2luw/v9r7/topic/com.ibm.db2.luw.admin.2pc.doc/doc/r0005080.html">
	      http://publib.boulder.ibm.com/infocenter/db2luw/v9r7/topic/com.ibm.db2.luw.admin.2pc.doc/doc/r0005080.html
	    </link>
	    but it may change in the future.
	</para></footnote>.
      </para>
    </section>
    <section>
      <title>Program execution (dynamic registration)</title>
      <para>
	It is suggested to open two different terminals: the first one
	connected to <quote>SAMPLE</quote> DB2 database and the second
	one pointing to the directory where the compiled program
	<filename>example3_db2</filename> lives.
	First teminal session:
	<screen>
tiian@ubuntu:~$ db2
(c) Copyright IBM Corporation 1993,2007
Command Line Processor for DB2 Client 9.7.1

You can issue database manager commands and SQL statements from the command
prompt. For example:
    db2 => connect to sample
    db2 => bind sample.bnd

For general help, type: ?.
For command help, type: ? command, where command can be
the first few keywords of a database manager command. For example:
 ? CATALOG DATABASE for help on the CATALOG DATABASE command
 ? CATALOG          for help on all of the CATALOG commands.

To exit db2 interactive mode, type QUIT at the command prompt. Outside
interactive mode, all commands must be prefixed with 'db2'.
To list the current command option settings, type LIST COMMAND OPTIONS.

For more detailed help, refer to the Online Reference Manual.

db2 => connect to SAMPLE

   Database Connection Information

 Database server        = DB2/LINUX 9.7.1
 SQL authorization ID   = TIIAN
 Local database alias   = SAMPLE

	</screen>
	Second teminal session:
	<screen>
tiian@ubuntu:~/tmp$ ls -la
total 28
drwxr-xr-x  2 tiian tiian  4096 2011-04-22 16:26 .
drwxr-xr-x 40 tiian tiian  4096 2011-04-18 22:55 ..
-rwxr-xr-x  1 tiian tiian 11030 2011-04-22 16:26 example3_db2
-rw-r--r--  1 tiian tiian  5898 2011-04-22 16:23 example3_db2.c
	</screen>
	Check the content of <quote>DB2INST1.ORG</quote> table before
	program execution:
	<screen>
db2 => select * from DB2INST1.ORG

DEPTNUMB DEPTNAME       MANAGER DIVISION   LOCATION
-------- -------------- ------- ---------- -------------
      10 Head Office        160 Corporate  New York
      15 New England         50 Eastern    Boston
      20 Mid Atlantic        10 Eastern    Washington
      38 South Atlantic      30 Eastern    Atlanta
      42 Great Lakes        100 Midwest    Chicago
      51 Plains             140 Midwest    Dallas
      66 Pacific            270 Western    San Francisco
      84 Mountain           290 Western    Denver

  8 record(s) selected.

	</screen>
	Execute the program:
	<screen>
tiian@ubuntu:~/tmp$ ./example3_db2 insert org
	</screen>
	Check the content of the table again:
	<screen>
db2 => select * from DB2INST1.ORG

DEPTNUMB DEPTNAME       MANAGER DIVISION   LOCATION
-------- -------------- ------- ---------- -------------
      10 Head Office        160 Corporate  New York
      15 New England         50 Eastern    Boston
      20 Mid Atlantic        10 Eastern    Washington
      38 South Atlantic      30 Eastern    Atlanta
      42 Great Lakes        100 Midwest    Chicago
      51 Plains             140 Midwest    Dallas
      66 Pacific            270 Western    San Francisco
      84 Mountain           290 Western    Denver
     150 Europe             231 R&amp;D        Mojan

  9 record(s) selected.

	</screen>
	The example program inserted the last row! You can execute it again
	<screen>
tiian@ubuntu:~/tmp$ ./example3_db2 insert org
	</screen>
	and it inserts another row:
	<screen>
db2 => select * from DB2INST1.ORG

DEPTNUMB DEPTNAME       MANAGER DIVISION   LOCATION
-------- -------------- ------- ---------- -------------
      10 Head Office        160 Corporate  New York
      15 New England         50 Eastern    Boston
      20 Mid Atlantic        10 Eastern    Washington
      38 South Atlantic      30 Eastern    Atlanta
      42 Great Lakes        100 Midwest    Chicago
      51 Plains             140 Midwest    Dallas
      66 Pacific            270 Western    San Francisco
      84 Mountain           290 Western    Denver
     150 Europe             231 R&amp;D        Mojan
     150 Europe             231 R&amp;D        Mojan

  10 record(s) selected.

	</screen>
	Because there is no an unique constraint on this table; if you
	want to check an error while inserting, use <quote>DEPT</quote>
	table instead.
	<screen>
db2 => select * from DB2INST1.DEPT

DEPTNO DEPTNAME                             MGRNO  ADMRDEPT LOCATION
------ ------------------------------------ ------ -------- ----------------
A00    SPIFFY COMPUTER SERVICE DIV.         000010 A00      -
B01    PLANNING                             000020 A00      -
C01    INFORMATION CENTER                   000030 A00      -
D01    DEVELOPMENT CENTER                   -      A00      -
D11    MANUFACTURING SYSTEMS                000060 D01      -
D21    ADMINISTRATION SYSTEMS               000070 D01      -
E01    SUPPORT SERVICES                     000050 A00      -
E11    OPERATIONS                           000090 E01      -
E21    SOFTWARE SUPPORT                     000100 E01      -
F22    BRANCH OFFICE F2                     -      E01      -
G22    BRANCH OFFICE G2                     -      E01      -
H22    BRANCH OFFICE H2                     -      E01      -
I22    BRANCH OFFICE I2                     -      E01      -
J22    BRANCH OFFICE J2                     -      E01      -

  14 record(s) selected.

	</screen>
	Try to insert the same row twice:
	<screen>
tiian@ubuntu:~/tmp$ ./example3_db2 insert dept
tiian@ubuntu:~/tmp$ ./example3_db2 insert dept
Unable to execute the SQL statement ('INSERT INTO DB2INST1.DEPT (DEPTNO, DEPTNAME, ADMRDEPT) VALUES('Z99', 'RESEARCH &amp; DEVELOPMENT', 'E01')'): -1
	</screen>
	Check the table content:
	<screen>
db2 => select * from DB2INST1.DEPT

DEPTNO DEPTNAME                             MGRNO  ADMRDEPT LOCATION
------ ------------------------------------ ------ -------- ----------------
A00    SPIFFY COMPUTER SERVICE DIV.         000010 A00      -
B01    PLANNING                             000020 A00      -
C01    INFORMATION CENTER                   000030 A00      -
D01    DEVELOPMENT CENTER                   -      A00      -
D11    MANUFACTURING SYSTEMS                000060 D01      -
D21    ADMINISTRATION SYSTEMS               000070 D01      -
E01    SUPPORT SERVICES                     000050 A00      -
E11    OPERATIONS                           000090 E01      -
E21    SOFTWARE SUPPORT                     000100 E01      -
F22    BRANCH OFFICE F2                     -      E01      -
G22    BRANCH OFFICE G2                     -      E01      -
H22    BRANCH OFFICE H2                     -      E01      -
I22    BRANCH OFFICE I2                     -      E01      -
J22    BRANCH OFFICE J2                     -      E01      -
Z99    RESEARCH &amp; DEVELOPMENT               -      E01      -

  15 record(s) selected.

	</screen>
	Only one record was inserted. As a final step, clean up both the
	tables:
	<screen>
tiian@ubuntu:~/tmp$ ./example3_db2 delete dept
tiian@ubuntu:~/tmp$ ./example3_db2 delete org
	</screen>
	and check the tables were cleaned-up:
	<screen>
db2 => select * from DB2INST1.DEPT

DEPTNO DEPTNAME                             MGRNO  ADMRDEPT LOCATION
------ ------------------------------------ ------ -------- ----------------
A00    SPIFFY COMPUTER SERVICE DIV.         000010 A00      -
B01    PLANNING                             000020 A00      -
C01    INFORMATION CENTER                   000030 A00      -
D01    DEVELOPMENT CENTER                   -      A00      -
D11    MANUFACTURING SYSTEMS                000060 D01      -
D21    ADMINISTRATION SYSTEMS               000070 D01      -
E01    SUPPORT SERVICES                     000050 A00      -
E11    OPERATIONS                           000090 E01      -
E21    SOFTWARE SUPPORT                     000100 E01      -
F22    BRANCH OFFICE F2                     -      E01      -
G22    BRANCH OFFICE G2                     -      E01      -
H22    BRANCH OFFICE H2                     -      E01      -
I22    BRANCH OFFICE I2                     -      E01      -
J22    BRANCH OFFICE J2                     -      E01      -

  14 record(s) selected.

db2 => select * from DB2INST1.ORG

DEPTNUMB DEPTNAME       MANAGER DIVISION   LOCATION
-------- -------------- ------- ---------- -------------
      10 Head Office        160 Corporate  New York
      15 New England         50 Eastern    Boston
      20 Mid Atlantic        10 Eastern    Washington
      38 South Atlantic      30 Eastern    Atlanta
      42 Great Lakes        100 Midwest    Chicago
      51 Plains             140 Midwest    Dallas
      66 Pacific            270 Western    San Francisco
      84 Mountain           290 Western    Denver

  8 record(s) selected.

	</screen>
	To verify the LIXA Transaction Manager and DB2 Resource Manager
	are using the dynamic transaction registration, you can inspect
	the trace produced by the LIXA client library:
	<screen>
tiian@ubuntu:~/tmp$ export LIXA_TRACE_MASK=0x00002000
tiian@ubuntu:~/tmp$ echo $LIXA_TRACE_MASK
0x00002000
tiian@ubuntu:~/tmp$ ./example3_db2 insert dept 2>&amp;1 | grep ax_reg
2011-04-22 22:08:40.650458 [6654/3039381232] ax_reg: rmid=0, xid=0xbfcd65d0, flags=0x0
2011-04-22 22:08:40.650858 [6654/3039381232] ax_reg: the application program has started a transaction (TX states S3); this XID '1279875137.9a73b024b7ab4018915b54761d3dcd79.e41205820a9c722218578c0eeec6a27c' will be returned
2011-04-22 22:08:40.651156 [6654/3039381232] ax_reg: sending 153 bytes to the server for step 8
2011-04-22 22:08:40.651316 [6654/3039381232] ax_reg/excp=7/ret_cod=0/errno=2
	</screen>
	I don't know how you can retrieve the same information on the
	DB2 side, but there probably is a way to do it. Clean-up again
	the table...
	<screen>
tiian@ubuntu:~/tmp$ ./example3_db2 delete dept
	</screen>
      </para>
    </section>
    <section>
      <title>Program execution (static registration)</title>
      <para>
	If you desire static transaction registration instead of the
	dynamic one, you can switch the <varname>LIXA_PROFILE</varname>:
	<screen>
tiian@ubuntu:~/tmp$ export LIXA_PROFILE=DB2_STA
tiian@ubuntu:~/tmp$ echo $LIXA_PROFILE
DB2_STA
tiian@ubuntu:~/tmp$ export LIXA_TRACE_MASK=0x00002000
tiian@ubuntu:~/tmp$ echo $LIXA_TRACE_MASK
0x00002000
	</screen>
	you can verify in file
	<filename>/opt/lixa/etc/lixac_conf.xml</filename>
	that <quote>DB2_STA</quote> is associated to static registration.
	Execute the program:
	<screen>
tiian@ubuntu:~/tmp$ ./example3_db2 insert dept 2>&amp;1 | grep xa_start
2011-04-22 22:19:45.717003 [6745/3038836464] lixa_xa_start
[...]
2011-04-22 22:19:45.758075 [6745/3038836464] lixa_xa_start: xa_start_entry(xid, 0, 0x0) = 0
2011-04-22 22:19:45.758321 [6745/3038836464] lixa_xa_start: sending 210 bytes to the server for step 24
2011-04-22 22:19:45.758681 [6745/3038836464] lixa_xa_start/excp=10/ret_cod=0/errno=2
	</screen>
	Check the content of the table:
	<screen>
db2 => select * from DB2INST1.DEPT

DEPTNO DEPTNAME                             MGRNO  ADMRDEPT LOCATION
------ ------------------------------------ ------ -------- ----------------
A00    SPIFFY COMPUTER SERVICE DIV.         000010 A00      -
B01    PLANNING                             000020 A00      -
C01    INFORMATION CENTER                   000030 A00      -
D01    DEVELOPMENT CENTER                   -      A00      -
D11    MANUFACTURING SYSTEMS                000060 D01      -
D21    ADMINISTRATION SYSTEMS               000070 D01      -
E01    SUPPORT SERVICES                     000050 A00      -
E11    OPERATIONS                           000090 E01      -
E21    SOFTWARE SUPPORT                     000100 E01      -
F22    BRANCH OFFICE F2                     -      E01      -
G22    BRANCH OFFICE G2                     -      E01      -
H22    BRANCH OFFICE H2                     -      E01      -
I22    BRANCH OFFICE I2                     -      E01      -
J22    BRANCH OFFICE J2                     -      E01      -
Z99    RESEARCH &amp; DEVELOPMENT               -      E01      -

  15 record(s) selected.

	</screen>
	And clean the table again:
	<screen>
tiian@ubuntu:~/tmp$ unset LIXA_TRACE_MASK
tiian@ubuntu:~/tmp$ ./example3_db2 delete dept
	</screen>
      </para>
    </section>
  </section>
  <section>
    <title>An example with Oracle and IBM DB2</title>
    <figure xml:id="develop4">
      <title>Deploy model of an example showing a distributed transaction with Oracle and IBM DB2</title>
      <mediaobject>
	<imageobject>
	  <imagedata fileref="../images/LIXA_Development_4.png"/>
	</imageobject>
      </mediaobject>
    </figure>
    <para>
      This example should be considered a milestone because it shows as
      you can implement DTP (Distributed Transaction Processing) with two
      Resource Managers (Oracle Database Server and IBM DB2 DBMS)
      coordinated by the LIXA Transaction Manager.
      It's strongly suggested you have played with the
      examples previously shown in this chapter (see
      <xref linkend="Development"/>) before starting this more complex one.
    </para>
    <note>
      <para>
	If you did not yet installed the software provided by Oracle,
	please refer to the official Oracle site to download the
	software and to pick-up the information necessary to install 
	and configure
	the database. This manual does not give you information related
	to Oracle technology: it is assumed you already installed and
	configured the database.
      </para>
      <para>
	If you did not yet installed the software provided by IBM,
	please refer to the official IBM site to download the
	software and to pick-up the information necessary to install 
	and configure
	the database. This manual does not give you information related
	to IBM DB2 technology: it is assumed you already installed and
	configured the database.
      </para>
    </note>
    <important>
      <para>
	The LIXA software must be configured to support the Oracle Database
	Server and the IBM DB2 resource managers as explained in 
	<xref linkend="Linking_third_party_resource_managers"/>.
	As a little hint, you should configure LIXA as below:
	<screen>
./configure --with-oracle=/usr/lib/oracle/xe/app/oracle/product/10.2.0/server --with-ibmdb2=/opt/ibm/db2/V9.7
	</screen>
	Please don't forget you must compile and install every time you
	re-configure.
      </para>
    </important>
    <para>
      Please follow the instructions explained 
      <itemizedlist mark="bullet">
	<listitem><para>
	    in <xref linkend="Development_setup_Oracle_environment"/>
	    to set-up a running environment for Oracle Database Server
	</para></listitem>
	<listitem><para>
	    in <xref linkend="Development_setup_DB2_environment"/>
	    to set-up a running environment for IBM DB2 server
	</para></listitem>
	<listitem><para>
	    in <xref linkend="Development_start_LIXA_server"/>
	    to start up the LIXA state server
	</para></listitem>
      </itemizedlist>
    </para>
    <section>
      <title>Build the client program</title>
      <para>
	Prepare the client (Application Program) using the below commands
	(<command>gcc</command> command was splitted on several lines 
	using <command>\</command> to help readability, but you may use
	a single line):
	<screen>
tiian@ubuntu:~$ mkdir tmp
tiian@ubuntu:~$ cd tmp
tiian@ubuntu:~/tmp$ cp /opt/lixa/share/doc/lixa-X.Y.Z/examples/example4_ora_db2.c .
tiian@ubuntu:~/tmp$ gcc example4_ora_db2.c $(/opt/lixa/bin/lixa-config -c -f -l -d) \
> -I/usr/lib/oracle/xe/app/oracle/product/10.2.0/server/rdbms/public \
> -L/usr/lib/oracle/xe/app/oracle/product/10.2.0/server/lib -l clntsh -l nnz10 \
> -I/opt/ibm/db2/V9.7/include -L/opt/ibm/db2/V9.7/lib32/ -ldb2 -o example4_ora_db2
	</screen>
	Verify the executable produced by <command>gcc</command>:
	<screen>
tiian@ubuntu:~/tmp$ ldd example4_ora_db2
        linux-gate.so.1 =>  (0xb770e000)
        liblixac.so.0 => /opt/lixa/lib/liblixac.so.0 (0xb76f3000)
        libclntsh.so.10.1 => not found
        libnnz10.so => not found
        libdb2.so.1 => /usr/lib/libdb2.so.1 (0xb61b2000)
        libc.so.6 => /lib/tls/i686/cmov/libc.so.6 (0xb6063000)
        libgmodule-2.0.so.0 => /usr/lib/libgmodule-2.0.so.0 (0xb605f000)
        libdl.so.2 => /lib/tls/i686/cmov/libdl.so.2 (0xb605b000)
        libgthread-2.0.so.0 => /usr/lib/libgthread-2.0.so.0 (0xb6055000)
        librt.so.1 => /lib/tls/i686/cmov/librt.so.1 (0xb604c000)
        libglib-2.0.so.0 => /usr/lib/libglib-2.0.so.0 (0xb5f9b000)
        libxml2.so.2 => /usr/lib/libxml2.so.2 (0xb5e7b000)
        liblixab.so.0 => /opt/lixa/lib/liblixab.so.0 (0xb5e66000)
        libm.so.6 => /lib/tls/i686/cmov/libm.so.6 (0xb5e41000)
        libpthread.so.0 => /lib/tls/i686/cmov/libpthread.so.0 (0xb5e28000)
        libcrypt.so.1 => /lib/tls/i686/cmov/libcrypt.so.1 (0xb5df6000)
        libpam.so.0 => /lib/libpam.so.0 (0xb5dec000)
        libdb2dascmn.so.1 => /opt/ibm/db2/V9.7/lib32/libdb2dascmn.so.1 (0xb5dbe000)
        libdb2g11n.so.1 => /opt/ibm/db2/V9.7/lib32/libdb2g11n.so.1 (0xb5750000)
        libdb2genreg.so.1 => /opt/ibm/db2/V9.7/lib32/libdb2genreg.so.1 (0xb5710000)
        libdb2install.so.1 => /opt/ibm/db2/V9.7/lib32/libdb2install.so.1 (0xb5705000)
        libdb2locale.so.1 => /opt/ibm/db2/V9.7/lib32/libdb2locale.so.1 (0xb56f2000)
        libdb2osse.so.1 => /opt/ibm/db2/V9.7/lib32/libdb2osse.so.1 (0xb53ec000)
        libdb2osse_db2.so.1 => /opt/ibm/db2/V9.7/lib32/libdb2osse_db2.so.1 (0xb537c000)
        libdb2trcapi.so.1 => /opt/ibm/db2/V9.7/lib32/libdb2trcapi.so.1 (0xb5369000)
        libstdc++.so.6 => /usr/lib/libstdc++.so.6 (0xb5276000)
        libgcc_s.so.1 => /lib/libgcc_s.so.1 (0xb526b000)
        /lib/ld-linux.so.2 (0xb770f000)
        libpcre.so.3 => /usr/lib/libpcre.so.3 (0xb5243000)
        libz.so.1 => /usr/lib/libz.so.1 (0xb522e000)
        libuuid.so.1 => /lib/libuuid.so.1 (0xb522a000)
	</screen>
      </para>
    </section>
    <section>
      <title>Set-up LIXA environment</title>
      <para>
	There are three unresolved references that can be fixed setting up
	the environment properly; you can fix the environment manually or
	using these scripts supplied by Oracle and IBM:
	<filename>/home/db2inst1/sqllib/db2profile</filename> and
	<filename>/usr/lib/oracle/xe/app/oracle/product/10.2.0/server/bin/oracle_env.sh</filename>
	<screen>
tiian@ubuntu:~$ echo $LD_LIBRARY_PATH

tiian@ubuntu:~$ . /home/db2inst1/sqllib/db2profile
tiian@ubuntu:~$ . /usr/lib/oracle/xe/app/oracle/product/10.2.0/server/bin/oracle_env.sh
tiian@ubuntu:~$ echo $LD_LIBRARY_PATH
/usr/lib/oracle/xe/app/oracle/product/10.2.0/server/lib:/home/db2inst1/sqllib/lib32
	</screen>
	Check again the executable:
	<screen>
tiian@ubuntu:~/tmp$ ldd example4_ora_db2
        linux-gate.so.1 =>  (0xb777f000)
        liblixac.so.0 => /opt/lixa/lib/liblixac.so.0 (0xb7764000)
        libclntsh.so.10.1 => /usr/lib/oracle/xe/app/oracle/product/10.2.0/server/lib/libclntsh.so.10.1 (0xb69b0000)
        libnnz10.so => /usr/lib/oracle/xe/app/oracle/product/10.2.0/server/lib/libnnz10.so (0xb67aa000)
        libdb2.so.1 => /home/db2inst1/sqllib/lib32/libdb2.so.1 (0xb5278000)
        libc.so.6 => /lib/tls/i686/cmov/libc.so.6 (0xb511b000)
        libgmodule-2.0.so.0 => /usr/lib/libgmodule-2.0.so.0 (0xb5117000)
        libdl.so.2 => /lib/tls/i686/cmov/libdl.so.2 (0xb5113000)
        libgthread-2.0.so.0 => /usr/lib/libgthread-2.0.so.0 (0xb510d000)
        librt.so.1 => /lib/tls/i686/cmov/librt.so.1 (0xb5104000)
        libglib-2.0.so.0 => /usr/lib/libglib-2.0.so.0 (0xb5053000)
        libxml2.so.2 => /usr/lib/libxml2.so.2 (0xb4f33000)
        liblixab.so.0 => /opt/lixa/lib/liblixab.so.0 (0xb4f1e000)
        libm.so.6 => /lib/tls/i686/cmov/libm.so.6 (0xb4ef9000)
        libpthread.so.0 => /lib/tls/i686/cmov/libpthread.so.0 (0xb4ee0000)
        libnsl.so.1 => /lib/tls/i686/cmov/libnsl.so.1 (0xb4ec8000)
        libcrypt.so.1 => /lib/tls/i686/cmov/libcrypt.so.1 (0xb4e95000)
        libpam.so.0 => /lib/libpam.so.0 (0xb4e8b000)
        libdb2dascmn.so.1 => /home/db2inst1/sqllib/lib32/libdb2dascmn.so.1 (0xb4e5e000)
        libdb2g11n.so.1 => /home/db2inst1/sqllib/lib32/libdb2g11n.so.1 (0xb47f0000)
        libdb2genreg.so.1 => /home/db2inst1/sqllib/lib32/libdb2genreg.so.1 (0xb47b0000)
        libdb2install.so.1 => /home/db2inst1/sqllib/lib32/libdb2install.so.1 (0xb47a4000)
        libdb2locale.so.1 => /home/db2inst1/sqllib/lib32/libdb2locale.so.1 (0xb4791000)
        libdb2osse.so.1 => /home/db2inst1/sqllib/lib32/libdb2osse.so.1 (0xb448c000)
        libdb2osse_db2.so.1 => /home/db2inst1/sqllib/lib32/libdb2osse_db2.so.1 (0xb441c000)
        libdb2trcapi.so.1 => /home/db2inst1/sqllib/lib32/libdb2trcapi.so.1 (0xb4409000)
        libstdc++.so.6 => /usr/lib/libstdc++.so.6 (0xb4315000)
        libgcc_s.so.1 => /lib/libgcc_s.so.1 (0xb430a000)
        /lib/ld-linux.so.2 (0xb7780000)
        libpcre.so.3 => /usr/lib/libpcre.so.3 (0xb42e3000)
        libz.so.1 => /usr/lib/libz.so.1 (0xb42ce000)
        libuuid.so.1 => /lib/libuuid.so.1 (0xb42ca000)
	</screen>
	Set-up the necessary environment variables:
	<screen>
tiian@ubuntu:~/tmp$ echo $LIXA_PROFILE

tiian@ubuntu:~/tmp$ export LIXA_PROFILE=ORA_DYN_DB2_DYN
tiian@ubuntu:~/tmp$ echo $LIXA_PROFILE
ORA_DYN_DB2_SYN
	</screen>
	The below environment variables were set by the previous sourced
	script; take a look to them:
	<screen>
tiian@ubuntu:~/tmp$ echo $ORACLE_HOME
/usr/lib/oracle/xe/app/oracle/product/10.2.0/server
tiian@ubuntu:~/tmp$ echo $PATH
/usr/lib/oracle/xe/app/oracle/product/10.2.0/server/bin:/usr/local/sbin:/usr/local/bin:/usr/sbin:/usr/bin:/sbin:/bin:/usr/games:/home/db2inst1/sqllib/bin:/home/db2inst1/sqllib/adm:/home/db2inst1/sqllib/misc:/home/db2inst1/sqllib/db2tss/bin
tiian@ubuntu:~/tmp$ echo $ORACLE_SID
XE
	</screen>
	It is suggested to set the necessary environment variables in your 
	profile if you are going to execute the programs many times.
	This is the list of the suggested variables:
	<varname>LD_LIBRARY_PATH</varname>,
	<varname>LIXA_PROFILE</varname>,
	<varname>ORACLE_HOME</varname>,
	<varname>ORACLE_SID</varname>,
	<varname>PATH</varname>.
      </para>
    </section>
    <section>
      <title>Some checks before program execution</title>
      <para>
	We set <varname>LIXA_PROFILE</varname> to value
	<quote>ORA_DYN_DB2_DYN</quote>, looking at
	<filename>/opt/lixa/etc/lixac_conf.xml</filename>:
	<screen>
    &lt;profile name="ORA_DYN_DB2_DYN"&gt;
      &lt;sttsrvs&gt;
        &lt;sttsrv&gt;local_1&lt;/sttsrv&gt;
      &lt;/sttsrvs&gt;
      &lt;rsrmgrs&gt;
        &lt;rsrmgr&gt;OracleXE_dynreg&lt;/rsrmgr&gt;
        &lt;rsrmgr&gt;IBMDB2_stareg&lt;/rsrmgr&gt;
      &lt;/rsrmgrs&gt;
    &lt;/profile&gt;
	</screen>
	the profile references two Resource Managers:
	<quote>OracleXE_dynreg</quote> and <quote>IBMDB2_stareg</quote>, 
	looking again at the config file:
	<screen>
    &lt;rsrmgr name="OracleXE_dynreg" switch_file="/opt/lixa/lib/switch_oracle_dynreg.so" xa_open_info="Oracle_XA+Acc=P/hr/hr+SesTm=30+LogDir=/tmp+threads=true+DbgFl=7+Loose_Coupling=true" xa_close_info="" /&gt;
    &lt;rsrmgr name="IBMDB2_dynreg" switch_file="/opt/lixa/lib/switch_ibmdb2_dynreg.so" xa_open_info="axlib=/opt/lixa/lib/liblixac.so,db=sample,tpm=lixa" xa_close_info="" /&gt;
	</screen>
	we can discover how our application will access the resource
	managers
	<footnote>
	  <para>
	    The content of <constant>xa_open_info</constant> string is
	    described in chapter 15 "Developing Applications with Oracle XA"
	    of the "Oracle Database Application Developer's Guide"
	    manual; please refer to the documentation published by
	    Oracle Corporation for further details.
	  </para>
	  <para>
	    The content of <constant>xa_open_info</constant> string is
	    documented at IBM Infocenter: search the string
	    <quote>xa_open string formats</quote> in the documentation
	    relevant to your installed version; this is a link
	    <link xlink:href="http://publib.boulder.ibm.com/infocenter/db2luw/v9r7/topic/com.ibm.db2.luw.admin.2pc.doc/doc/r0005080.html">
	      http://publib.boulder.ibm.com/infocenter/db2luw/v9r7/topic/com.ibm.db2.luw.admin.2pc.doc/doc/r0005080.html
	    </link>
	    but it may change in the future.
	  </para>
	</footnote>. 
	Verify no (Oracle) trace file exists:
	<screen>
tiian@ubuntu:~/tmp$ ls -la /tmp/xa*
ls: cannot access /tmp/xa*: No such file or directory
	</screen>
      </para>
    </section>
    <section>
      <title>Program execution (dynamic registration)</title>
      <para>
	It is suggested to open three different terminals: 
	the first one connected to <quote>SAMPLE</quote> DB2 database,
	the second one connected to Oracle database and the
	third one pointing to the directory where the compiled program 
	example4_ora_db2 lives.
	<table frame="box">
	  <thead><tr><td>[IBM DB2 terminal session]</td></tr></thead>
	  <tbody><tr><td><screen>
tiian@ubuntu:~$ . /home/db2inst1/sqllib/db2profile
tiian@ubuntu:~$ db2
(c) Copyright IBM Corporation 1993,2007
Command Line Processor for DB2 Client 9.7.1

You can issue database manager commands and SQL statements from the command
prompt. For example:
    db2 => connect to sample
    db2 => bind sample.bnd

For general help, type: ?.
For command help, type: ? command, where command can be
the first few keywords of a database manager command. For example:
 ? CATALOG DATABASE for help on the CATALOG DATABASE command
 ? CATALOG          for help on all of the CATALOG commands.

To exit db2 interactive mode, type QUIT at the command prompt. Outside
interactive mode, all commands must be prefixed with 'db2'.
To list the current command option settings, type LIST COMMAND OPTIONS.

For more detailed help, refer to the Online Reference Manual.

db2 => connect to SAMPLE

   Database Connection Information

 Database server        = DB2/LINUX 9.7.1
 SQL authorization ID   = TIIAN
 Local database alias   = SAMPLE

db2 =>
	  </screen></td></tr></tbody>
	</table>
	<table frame="box">
	  <thead><tr><td>[Oracle terminal session]</td></tr></thead>
	  <tbody><tr><td><screen>
tiian@ubuntu:~$ . /usr/lib/oracle/xe/app/oracle/product/10.2.0/server/bin/oracle_env.sh
tiian@ubuntu:~$ sqlplus "hr/hr"                                                 
SQL*Plus: Release 10.2.0.1.0 - Production on Tue May 3 21:52:06 2011

Copyright (c) 1982, 2005, Oracle.  All rights reserved.


Connected to:
Oracle Database 10g Express Edition Release 10.2.0.1.0 - Production

SQL>
	  </screen></td></tr></tbody>
	</table>
	<table frame="box">
	  <thead><tr><td>[Shell terminal session]</td></tr></thead>
	  <tbody><tr><td><screen>
tiian@ubuntu:~/tmp$ ls -la
total 36
drwxr-xr-x  2 tiian tiian  4096 2011-05-03 21:53 .
drwxr-xr-x 40 tiian tiian  4096 2011-05-03 21:04 ..
-rwxr-xr-x  1 tiian tiian 14422 2011-05-02 21:53 example4_ora_db2
-rw-r--r--  1 tiian tiian 11892 2011-05-02 21:52 example4_ora_db2.c
	  </screen></td></tr></tbody>
	</table>
	Check the content of the Oracle table (<quote>COUNTRIES</quote>):
	<table frame="box">
	  <thead><tr><td>[Oracle terminal session]</td></tr></thead>
	  <tbody><tr><td><screen>
SQL> select * from COUNTRIES where COUNTRY_ID = 'RS';

no rows selected
	  </screen></td></tr></tbody>
	</table>
	Check the content of the DB2 tables (<quote>DB2INST1.ORG</quote> and
	<quote>DB2INST1.DEPT</quote>):
	<table frame="box">
	  <thead><tr><td>[IBM DB2 terminal session]</td></tr></thead>
	  <tbody><tr><td><screen>
db2 => select * from DB2INST1.ORG where DEPTNUMB = 150

DEPTNUMB DEPTNAME       MANAGER DIVISION   LOCATION
-------- -------------- ------- ---------- -------------

  0 record(s) selected.

db2 => select * from DB2INST1.DEPT where DEPTNO='Z99'

DEPTNO DEPTNAME                             MGRNO  ADMRDEPT LOCATION
------ ------------------------------------ ------ -------- ----------------

  0 record(s) selected.
	  </screen></td></tr></tbody>
	</table>
	<command>example4_ora_db2</command> program accepts some arguments
	you can tune to experiment different transactions:
	<itemizedlist mark="bullet">
	  <listitem><para>
	      <option>iorg</option>: insert a row into 
	      <quote>DB2INST1.ORG</quote> table
	  </para></listitem>
	  <listitem><para>
	      <option>dorg</option>: delete rows from 
	      <quote>DB2INST1.ORG</quote> table
	  </para></listitem>
	  <listitem><para>
	      <option>idept</option>: insert a row into 
	      <quote>DB2INST1.DEPT</quote> table
	  </para></listitem>
	  <listitem><para>
	      <option>ddept</option>: delete rows from 
	      <quote>DB2INST1.DEPT</quote> table
	  </para></listitem>
	  <listitem><para>
	      <option>icountries</option>: insert a row into 
	      <quote>COUNTRIES</quote> table
	  </para></listitem>
	  <listitem><para>
	      <option>dcountries</option>: delete rows from 
	      <quote>COUNTRIES</quote> table
	  </para></listitem>
	  <listitem><para>
	      <option>rollback</option>: force a transaction rollback (the
	      default behavior is commit)
	  </para></listitem>
	</itemizedlist>
	Insert a row in all the tables and check the contents of the tables
	after the transaction execution:
	<table frame="box">
	  <thead><tr><td>[Third terminal session]</td></tr></thead>
	  <tbody><tr><td><screen>
tiian@ubuntu:~/tmp$ ./example4_ora_db2 iorg icountries idept
INSERT INTO DB2INST1.ORG executed!
INSERT INTO COUNTRIES executed!
INSERT INTO DB2INST1.DEPT executed!
COMMIT performed!
	  </screen></td></tr></tbody>
	</table>
	Now you can verify the content of the tables after the transaction:
	<table frame="box">
	  <thead><tr><td>[Oracle terminal session]</td></tr></thead>
	  <tbody><tr><td><screen>
SQL> select * from COUNTRIES where COUNTRY_ID = 'RS';

CO COUNTRY_NAME                              REGION_ID
-- ---------------------------------------- ----------
RS Repubblica San Marino                             1
	  </screen></td></tr></tbody>
	</table>
	<table frame="box">
	  <thead><tr><td>[IBM DB2 terminal session]</td></tr></thead>
	  <tbody><tr><td><screen>
db2 => select * from DB2INST1.ORG where DEPTNUMB = 150

DEPTNUMB DEPTNAME       MANAGER DIVISION   LOCATION
-------- -------------- ------- ---------- -------------
     150 Europe             231 R&amp;D        Mojan

  1 record(s) selected.

db2 =>  select * from DB2INST1.DEPT where DEPTNO='Z99'

DEPTNO DEPTNAME                             MGRNO  ADMRDEPT LOCATION
------ ------------------------------------ ------ -------- ----------------
Z99    RESEARCH &amp; DEVELOPMENT               -      E01      -

  1 record(s) selected.
	  </screen></td></tr></tbody>
	</table>
	With the opposite command you can remove the rows from the tables:
	<table frame="box">
	  <thead><tr><td>[Shell terminal session]</td></tr></thead>
	  <tbody><tr><td><screen>
tiian@ubuntu:~/tmp$ ./example4_ora_db2 dorg dcountries ddept
DELETE FROM DB2INST1.ORG executed!
DELETE FROM COUNTRIES executed!
DELETE FROM DB2INST1.DEPT executed!
COMMIT performed!
	  </screen></td></tr></tbody>
	</table>
	and check the content of the tables again:
	<table frame="box">
	  <thead><tr><td>[Oracle terminal session]</td></tr></thead>
	  <tbody><tr><td><screen>
SQL> select * from COUNTRIES where COUNTRY_ID = 'RS';

no rows selected
	  </screen></td></tr></tbody>
	</table>
	<table frame="box">
	  <thead><tr><td>[IBM DB2 terminal session]</td></tr></thead>
	  <tbody><tr><td><screen>
db2 => select * from DB2INST1.ORG where DEPTNUMB = 150

DEPTNUMB DEPTNAME       MANAGER DIVISION   LOCATION
-------- -------------- ------- ---------- -------------

  0 record(s) selected.

db2 => select * from DB2INST1.DEPT where DEPTNO='Z99'

DEPTNO DEPTNAME                             MGRNO  ADMRDEPT LOCATION
------ ------------------------------------ ------ -------- ----------------

  0 record(s) selected.
	  </screen></td></tr></tbody>
	</table>
	This sequence shows what happens trying to insert a duplicated row
	in a table that does not allow duplicates:
	<table frame="box">
	  <thead><tr><td>[Shell terminal session]</td></tr></thead>
	  <tbody><tr><td><screen>
tiian@ubuntu:~/tmp$ ./example4_ora_db2 iorg icountries idept
INSERT INTO DB2INST1.ORG executed!
INSERT INTO COUNTRIES executed!
INSERT INTO DB2INST1.DEPT executed!
COMMIT performed!
tiian@ubuntu:~/tmp$ ./example4_ora_db2 iorg icountries idept
INSERT INTO DB2INST1.ORG executed!
OCIStmtExecute/Error while executing INSERT statement; ocirc = -1
ROLLBACK performed!
	  </screen></td></tr></tbody>
	</table>
	Verify that table <quote>DB2INST1.ORG</quote> contains only one row
	because the second transaction was rolled back after the error
	occurred while inserting a duplicated row in <quote>COUNTRIES</quote>
	table:
	<table frame="box">
	  <thead><tr><td>[IBM DB2 terminal session]</td></tr></thead>
	  <tbody><tr><td><screen>
db2 => select * from DB2INST1.ORG where DEPTNUMB = 150

DEPTNUMB DEPTNAME       MANAGER DIVISION   LOCATION
-------- -------------- ------- ---------- -------------
     150 Europe             231 R&amp;D        Mojan

  1 record(s) selected.
	  </screen></td></tr></tbody>
	</table>
	Remove the rows from the tables:
	<table frame="box">
	  <thead><tr><td>[Shell terminal session]</td></tr></thead>
	  <tbody><tr><td><screen>
tiian@ubuntu:~/tmp$ ./example4_ora_db2 dorg dcountries ddept
DELETE FROM DB2INST1.ORG executed!
DELETE FROM COUNTRIES executed!
DELETE FROM DB2INST1.DEPT executed!
COMMIT performed!
	  </screen></td></tr></tbody>
	</table>
	We can introduce the usage of the <option>rollback</option> option 
	to check dynamic registration behavior:
	<table frame="box">
	  <thead><tr><td>[Shell terminal session]</td></tr></thead>
	  <tbody><tr><td><screen>
tiian@ubuntu:~/tmp$ export LIXA_TRACE_MASK=0x00002000
tiian@ubuntu:~/tmp$ echo $LIXA_TRACE_MASK
0x00002000
tiian@ubuntu:~/tmp$ ./example4_ora_db2 iorg icountries idept rollback 2>&amp;1 | grep ax_reg
2011-05-04 22:35:07.919522 [8962/3023124208] ax_reg: rmid=1, xid=0xbfe8d1f0, flags=0x0
2011-05-04 22:35:07.920026 [8962/3023124208] ax_reg: the application program has started a transaction (TX states S3); this XID '1279875137.47b3b61569764774bfc1e5f79ef725ae.818e85f29a0c09e22f0c75f89ca17658' will be returned
2011-05-04 22:35:07.920276 [8962/3023124208] ax_reg: sending 153 bytes to the server for step 8
2011-05-04 22:35:07.920527 [8962/3023124208] ax_reg/excp=7/ret_cod=0/errno=2
2011-05-04 22:35:07.921592 [8962/3023124208] ax_reg: rmid=0, xid=0xbfe8b09c, flags=0x0
2011-05-04 22:35:07.921812 [8962/3023124208] ax_reg: the application program has started a transaction (TX states S3); this XID '1279875137.47b3b61569764774bfc1e5f79ef725ae.818e85f29a0c09e22f0c75f89ca17658' will be returned
2011-05-04 22:35:07.921979 [8962/3023124208] ax_reg: sending 153 bytes to the server for step 8
2011-05-04 22:35:07.922128 [8962/3023124208] ax_reg/excp=7/ret_cod=0/errno=2
	  </screen></td></tr></tbody>
	</table>
	The second resource manager for profile
	<quote>ORA_DYN_DB2_DYN</quote> is <quote>IBMDB2_dynreg</quote>
	and it calls <function>ax_reg</function> with 
	<parameter>rmid=1</parameter> before the first resource manager
	that's <quote>OracleXE_dynreg</quote> and calls
	<function>ax_reg</function> with <parameter>rmid=0</parameter>
	later.
      </para>
    </section>
    <section>
      <title>Program execution (mixed registration)</title>
      <para>
	Switching to a different registration type is quite easy; we can start
	with dynamic registration for Oracle and static registration for
	IBM DB2:
	<table frame="box">
	  <thead><tr><td>[Shell terminal session]</td></tr></thead>
	  <tbody><tr><td><screen>
tiian@ubuntu:~/tmp$ export LIXA_TRACE_MASK=0x00002000
tiian@ubuntu:~/tmp$ echo $LIXA_TRACE_MASK
0x00002000
tiian@ubuntu:~/tmp$ export LIXA_PROFILE=ORA_DYN_DB2_STA
tiian@ubuntu:~/tmp$ echo $LIXA_PROFILE
ORA_DYN_DB2_STA
tiian@ubuntu:~/tmp$ ./example4_ora_db2 iorg icountries idept rollback 2>&amp;1 | grep ax_reg
2011-05-04 22:47:11.812256 [9122/3022382832] ax_reg: rmid=0, xid=0xbfc0f59c, flags=0x0
2011-05-04 22:47:11.813114 [9122/3022382832] ax_reg: the application program has started a transaction (TX states S3); this XID '1279875137.a74508954f774509a939ad9580bca2b8.03460325a8fe89a8c8134b6dea4b782e' will be returned
2011-05-04 22:47:11.813631 [9122/3022382832] ax_reg: sending 153 bytes to the server for step 8
2011-05-04 22:47:11.814037 [9122/3022382832] ax_reg/excp=7/ret_cod=0/errno=2
tiian@ubuntu:~/tmp$ ./example4_ora_db2 iorg icountries idept rollback 2>&amp;1 | grep xa_start
2011-05-04 22:47:38.081183 [9126/3022632688] lixa_xa_start
[...]
2011-05-04 22:47:38.124749 [9126/3022632688] lixa_xa_start: resource manager # 0 registers dynamically, skipping...
2011-05-04 22:47:38.125154 [9126/3022632688] lixa_xa_start: xa_start_entry(xid, 1, 0x0) = 0
2011-05-04 22:47:38.125330 [9126/3022632688] lixa_xa_start: sending 210 bytes to the server for step 24
2011-05-04 22:47:38.125654 [9126/3022632688] lixa_xa_start/excp=10/ret_cod=0/errno=2
	  </screen></td></tr></tbody>
	</table>
	Oracle is defined as the first resource manager and calls
	<function>ax_reg</function> using <parameter>rmid=0</parameter>.
	IBM DB2 is defined as the second resource manager and its
	<function>xa_start</function> function is called
	from the LIXA transaction manager using <parameter>rmid=1</parameter>.
	<note><para>
	    The LIXA Transaction Manager skips the first resource manager
	    because it is configured for dynamic registration.
	</para></note>
	Using static registration for Oracle and dynamic registration for
	IBM DB2 is easy as well:
	<table frame="box">
	  <thead><tr><td>[Shell terminal session]</td></tr></thead>
	  <tbody><tr><td><screen>
tiian@ubuntu:~/tmp$ export LIXA_PROFILE=ORA_STA_DB2_DYN
tiian@ubuntu:~/tmp$ echo $LIXA_PROFILE
ORA_STA_DB2_DYN
tiian@ubuntu:~/tmp$ ./example4_ora_db2 iorg icountries idept rollback 2>&amp;1 | grep ax_reg
2011-05-04 22:57:37.235541 [9346/3023226608] ax_reg: rmid=1, xid=0xbfcf8880, flags=0x0
2011-05-04 22:57:37.236410 [9346/3023226608] ax_reg: the application program has started a transaction (TX states S3); this XID '1279875137.1bf330d60c0442e4b61539214a413ecb.79fecb55351db58295ebf99c9bf09a70' will be returned
2011-05-04 22:57:37.236859 [9346/3023226608] ax_reg: sending 153 bytes to the server for step 8
2011-05-04 22:57:37.237581 [9346/3023226608] ax_reg/excp=7/ret_cod=0/errno=2
tiian@ubuntu:~/tmp$ ./example4_ora_db2 iorg icountries idept rollback 2>&amp;1 | grep xa_start
2011-05-04 22:58:10.258562 [9350/3022706416] lixa_xa_start
[...]
2011-05-04 22:58:10.296182 [9350/3022706416] lixa_xa_start: xa_start_entry(xid, 0, 0x0) = 0
2011-05-04 22:58:10.296448 [9350/3022706416] lixa_xa_start: resource manager # 1 registers dynamically, skipping...
2011-05-04 22:58:10.296625 [9350/3022706416] lixa_xa_start: sending 210 bytes to the server for step 24
2011-05-04 22:58:10.296990 [9350/3022706416] lixa_xa_start/excp=10/ret_cod=0/errno=2
	  </screen></td></tr></tbody>
	</table>
	Now the roles of Oracle and IBM DB2 swapped. As a final example
	you can try the static registration for Oracle and IBM DB2 too:
	<table frame="box">
	  <thead><tr><td>[Shell terminal session]</td></tr></thead>
	  <tbody><tr><td><screen>
tiian@ubuntu:~/tmp$ export LIXA_PROFILE=ORA_STA_DB2_STA
tiian@ubuntu:~/tmp$ echo $LIXA_PROFILE
ORA_STA_DB2_STA
tiian@ubuntu:~/tmp$ ./example4_ora_db2 iorg icountries idept rollback 2>&amp;1 | grep ax_reg
tiian@ubuntu:~/tmp$ ./example4_ora_db2 iorg icountries idept rollback 2>&amp;1 | grep xa_start
2011-05-04 23:00:27.871131 [9356/3022927600] lixa_xa_start
[...]
2011-05-04 23:00:27.917087 [9356/3022927600] lixa_xa_start: xa_start_entry(xid, 0, 0x0) = 0
2011-05-04 23:00:27.918251 [9356/3022927600] lixa_xa_start: xa_start_entry(xid, 1, 0x0) = 0
2011-05-04 23:00:27.918741 [9356/3022927600] lixa_xa_start: sending 281 bytes to the server for step 24
2011-05-04 23:00:27.919389 [9356/3022927600] lixa_xa_start/excp=10/ret_cod=0/errno=2
	  </screen></td></tr></tbody>
	</table>
	No resource manager calls <function>ax_reg</function> with this
	configuration: this is exactly what's expected.
      </para>
      <para>
	As a final check, we can verify all the tables have no rows:
	<table frame="box">
	  <thead><tr><td>[Oracle terminal session]</td></tr></thead>
	  <tbody><tr><td><screen>
SQL> select * from COUNTRIES where COUNTRY_ID = 'RS';

no rows selected
	  </screen></td></tr></tbody>
	</table>
	<table frame="box">
	  <thead><tr><td>[IBM DB2 terminal session]</td></tr></thead>
	  <tbody><tr><td><screen>
db2 => select * from DB2INST1.ORG where DEPTNUMB = 150

DEPTNUMB DEPTNAME       MANAGER DIVISION   LOCATION
-------- -------------- ------- ---------- -------------

  0 record(s) selected.

db2 => select * from DB2INST1.DEPT where DEPTNO='Z99'

DEPTNO DEPTNAME                             MGRNO  ADMRDEPT LOCATION
------ ------------------------------------ ------ -------- ----------------

  0 record(s) selected.
	  </screen></td></tr></tbody>
	</table>
	Congratulations! You have just completed a full discovery of
	a Distributed Transaction Processing example with a simple
	Application Program, LIXA Transaction Manager and two widespread
	Resource Managers: Oracle Database Server and IBM DB2 DBMS.
      </para>
    </section>
  </section>
  <section xml:id="Development_example5_pql">
    <title>An example with PostgreSQL</title>
    <figure xml:id="develop5">
      <title>Deploy model of an example with PostgreSQL DBMS</title>
      <mediaobject>
	<imageobject>
	  <imagedata fileref="../images/LIXA_Development_5.png"/>
	</imageobject>
      </mediaobject>
    </figure>
    <para>
      This example was developed using PostgreSQL 8.3.15 for Linux (Ubuntu).
      If you were using a different version you would need to adapt some
      commands to your environment.
    </para>
    <note><para>
	If you did not yet installed the software, please refer to the 
	official site for your Linux distribution or to the official site
	of PostgreSQL if your operating system does not distribute the
	software or you want to use a different PostgreSQL version.
	Using Ubuntu Linux this packages are necessary:
	<variablelist>
	  <varlistentry>
	    <term><package>libpq-dev</package></term>
	    <listitem><para>
		header files for libpq5 (PostgreSQL library)
	    </para></listitem>
	  </varlistentry>	  
	  <varlistentry>
	    <term><package>libpq</package></term>
	    <listitem><para>
		PostgreSQL C client library
	    </para></listitem>
	  </varlistentry>	  
	  <varlistentry>
	    <term><package>postgresql-client-8.3</package></term>
	    <listitem><para>
		front-end programs for PostgreSQL 8.3
	    </para></listitem>
	  </varlistentry>	  
	  <varlistentry>
	    <term><package>postgresql-client-common</package></term>
	    <listitem><para>
		manager for multiple PostgreSQL client version
	    </para></listitem>
	  </varlistentry>	  
	  <varlistentry>
	    <term><package>postgresql-8.3</package></term>
	    <listitem><para>
		object-relational SQL database, version 8.3
	    </para></listitem>
	  </varlistentry>	  
	  <varlistentry>
	    <term><package>postgresql-common</package></term>
	    <listitem><para>
		PostgreSQL database-cluster manager
	    </para></listitem>
	  </varlistentry>
	</variablelist>
	This manual does not give you information related
	to PostgreSQL: it is assumed you already installed and
	configured the database.
    </para></note>
    <note><para>
	This example requires you are running the database and the application
	on the same host: this is not a technical limitation, but a way to
	make it easy. Client/server configuration must work as well, but
	it needs some PostgreSQL extra configuration: please refer to the
	database documentation.
    </para></note>
    <important><para>
	The LIXA software must be configured to support the PostgreSQL
	server resource manager as explained in 
	<xref linkend="Linking_third_party_resource_managers"/>.
    </para></important>
    <section xml:id="Development_setup_PostgreSQL_environment">
      <title>Set-up PostgreSQL environment</title>
      <section>
	<title>Start-up the PostgreSQL server</title>
	<para>
	  If your server didn't start-up automatically at boot time, you
	  could start it with the following commands:
	  <table frame="box">
	    <thead><tr><td>[Shell terminal session]</td></tr></thead>
	    <tbody><tr><td><screen>
tiian@ubuntu:~$ ps -ef|grep postgres|grep -v grep
tiian@ubuntu:~$ sudo /etc/init.d/postgresql-8.3 start
 * Starting PostgreSQL 8.3 database server                               [ OK ]
tiian@ubuntu:~$ ps -ef|grep postgres|grep -v grep
postgres  6086     1 24 11:25 ?        00:00:01 /usr/lib/postgresql/8.3/bin/postgres -D /var/lib/postgresql/8.3/main -c config_file=/etc/postgresql/8.3/main/postgresql.conf
postgres  6088  6086  0 11:25 ?        00:00:00 postgres: writer process                                                                                        
postgres  6089  6086  0 11:25 ?        00:00:00 postgres: wal writer process                                                                                    
postgres  6090  6086  0 11:25 ?        00:00:00 postgres: autovacuum launcher process                                                                           
postgres  6091  6086  0 11:25 ?        00:00:00 postgres: stats collector process
	    </screen></td></tr></tbody>
	  </table>
	  Switch to user <systemitem class="username">postgres</systemitem>,
	  associate your user to a matching database user
	  <footnote><para>
	      If you wanted to use a database user different than your own
	      UNIX user, as it ever happens when the database is hosted on
	      a different system, you should configure
	      <filename>pg_hba.conf</filename> as well. Look at the PostgreSQL
	      documentation to pick up all the necessary details.
	  </para></footnote>
	  ; my personal account is 
	  <systemitem class="username">tiian</systemitem>
	  and I created the same user inside PostgreSQL database:
	  <table frame="box">
	    <thead><tr><td>[Shell terminal session]</td></tr></thead>
	    <tbody><tr><td><screen>
tiian@ubuntu:~$ sudo su - postgres
[sudo] password for tiian:
postgres@ubuntu:~$ createuser --createdb tiian
Shall the new role be a superuser? (y/n) n
Shall the new role be allowed to create more new roles? (y/n) n
postgres@ubuntu:~$ exit
logout
	    </screen></td></tr></tbody>
	  </table>
	  Create a new database and a table necessary to store some data:
	  <table frame="box">
	    <thead><tr><td>[PostgreSQL terminal session]</td></tr></thead>
	    <tbody><tr><td><screen>
tiian@ubuntu:~$ createdb testdb
tiian@ubuntu:~$ psql testdb
Welcome to psql 8.3.15, the PostgreSQL interactive terminal.

Type:  \copyright for distribution terms
       \h for help with SQL commands
       \? for help with psql commands
       \g or terminate with semicolon to execute query
       \q to quit

testdb=> CREATE TABLE "authors" (
testdb(> "id" integer NOT NULL,
testdb(> "last_name" text,
testdb(> "first_name" text,
testdb(> Constraint "authors_pkey" Primary Key ("id"));
NOTICE:  CREATE TABLE / PRIMARY KEY will create implicit index "authors_pkey" for table "authors"
CREATE TABLE

testdb=> select * from authors;
 id | last_name | first_name
----+-----------+------------
(0 rows)
	    </screen></td></tr></tbody>
	  </table>
	  OK, the <quote>authors</quote> table was created. 
	  If something went wrong, you should refer to PostgreSQL
	  documentation to fix the issue before the next step because
	  you would not be able to execute the sample program without a
	  basic running installation.
	</para>
	<para>
	  Change the 
	  <systemitem class="constant">max_prepared_transactions</systemitem>
	  parameter in file
	  <filename>postgresql.conf</filename>
	  to allow the desired number of prepared transactions (i.e. 10):
	  <screen>
shared_buffers = 24MB                   # min 128kB
                                        # (change requires restart)
#temp_buffers = 8MB                     # min 800kB
max_prepared_transactions = 10          # zero disables the feature
#max_prepared_transactions = 0          # zero disables the feature
                                        # (change requires restart)
# Note:  Increasing max_prepared_transactions costs ~600 bytes of shared memory
# per transaction slot, plus lock space (see max_locks_per_transaction).
# It is not advisable to set max_prepared_transactions nonzero unless you
# actively intend to use prepared transactions.
#work_mem = 1MB                         # min 64kB
#maintenance_work_mem = 16MB            # min 1MB
#max_stack_depth = 2MB                  # min 100kB
	  </screen>
	  and restart the PostgreSQL server with something like
	  <screen>sudo service postgresql-8.4 restart</screen> (Ubuntu 10.04) or
	  <screen>sudo /etc/init.d/postgresql-8.3 restart</screen> (Ubuntu 8.04)
	  <screen>service postgresql restart</screen> (CentOS 6.2) using
	  <systemitem class="username">root</systemitem> user.
	</para>
      </section>
    </section>
    <section>
      <title>Start the LIXA state server</title>
      <para>
	Start the state server as shown below:
	<table frame="box">
	  <thead><tr><td>[Shell terminal session]</td></tr></thead>
	  <tbody><tr><td><screen>
tiian@ubuntu:~$ sudo su - lixa
lixa@ubuntu:~$ /opt/lixa/sbin/lixad --daemon
lixa@ubuntu:~$ exit
logout
tiian@ubuntu:~$ ps -ef|grep lixad|grep -v grep
lixa     12866     1  0 21:35 ?        00:00:00 /opt/lixa/sbin/lixad --daemon
	  </screen></td></tr></tbody>
	</table>
      </para>
    </section>
    <section>
      <title>Build the client program</title>
      <para>
	Prepare the client (Application Program) using the below commands
	(<command>gcc</command> command was splitted on several lines 
	using <command>\</command> to help readability, but you may use
	a single line):
	<table frame="box">
	  <thead><tr><td>[Shell terminal session]</td></tr></thead>
	  <tbody><tr><td><screen>
tiian@ubuntu:~$ mkdir tmp
tiian@ubuntu:~$ cd tmp
tiian@ubuntu:~/tmp$ cp /opt/lixa/share/doc/lixa-X.Y.Z/examples/example5_pql.c .
tiian@ubuntu:~/tmp$ gcc example5_pql.c $(/opt/lixa/bin/lixa-config -c -f -p -d) \
> -I /usr/include/postgresql -l pq -o example5_pql
	  </screen></td></tr></tbody>
	</table>
	Verify the executable produced by <command>gcc</command>:
	<table frame="box">
	  <thead><tr><td>[Shell terminal session]</td></tr></thead>
	  <tbody><tr><td><screen>
tiian@ubuntu:~/tmp$ ldd example5_pql
        linux-gate.so.1 =>  (0xb7711000)
        liblixac.so.0 => /opt/lixa/lib/liblixac.so.0 (0xb76f6000)
        liblixapq.so.0 => /opt/lixa/lib/liblixapq.so.0 (0xb76ef000)
        libpq.so.5 => /usr/lib/libpq.so.5 (0xb76c1000)
        libc.so.6 => /lib/tls/i686/cmov/libc.so.6 (0xb7572000)
        libgmodule-2.0.so.0 => /usr/lib/libgmodule-2.0.so.0 (0xb756e000)
        libdl.so.2 => /lib/tls/i686/cmov/libdl.so.2 (0xb756a000)
        libgthread-2.0.so.0 => /usr/lib/libgthread-2.0.so.0 (0xb7565000)
        librt.so.1 => /lib/tls/i686/cmov/librt.so.1 (0xb755c000)
        libglib-2.0.so.0 => /usr/lib/libglib-2.0.so.0 (0xb74aa000)
        libxml2.so.2 => /usr/lib/libxml2.so.2 (0xb738a000)
        liblixab.so.0 => /opt/lixa/lib/liblixab.so.0 (0xb7376000)
        libpthread.so.0 => /lib/tls/i686/cmov/libpthread.so.0 (0xb735e000)
        libssl.so.0.9.8 => /usr/lib/i686/cmov/libssl.so.0.9.8 (0xb7319000)
        libcrypto.so.0.9.8 => /usr/lib/i686/cmov/libcrypto.so.0.9.8 (0xb71d6000)
        libkrb5.so.3 => /usr/lib/libkrb5.so.3 (0xb7149000)
        libcom_err.so.2 => /lib/libcom_err.so.2 (0xb7146000)
        libgssapi_krb5.so.2 => /usr/lib/libgssapi_krb5.so.2 (0xb711d000)
        libcrypt.so.1 => /lib/tls/i686/cmov/libcrypt.so.1 (0xb70eb000)
        libldap_r-2.4.so.2 => /usr/lib/libldap_r-2.4.so.2 (0xb70ab000)
        /lib/ld-linux.so.2 (0xb7712000)
        libpcre.so.3 => /usr/lib/libpcre.so.3 (0xb7083000)
        libz.so.1 => /usr/lib/libz.so.1 (0xb706e000)
        libm.so.6 => /lib/tls/i686/cmov/libm.so.6 (0xb7049000)
        libuuid.so.1 => /lib/libuuid.so.1 (0xb7045000)
        libk5crypto.so.3 => /usr/lib/libk5crypto.so.3 (0xb7022000)
        libkrb5support.so.0 => /usr/lib/libkrb5support.so.0 (0xb7019000)
        libkeyutils.so.1 => /lib/libkeyutils.so.1 (0xb7016000)
        libresolv.so.2 => /lib/tls/i686/cmov/libresolv.so.2 (0xb7003000)
        liblber-2.4.so.2 => /usr/lib/liblber-2.4.so.2 (0xb6ff6000)
        libsasl2.so.2 => /usr/lib/libsasl2.so.2 (0xb6fdf000)
        libgnutls.so.13 => /usr/lib/libgnutls.so.13 (0xb6f68000)
        libtasn1.so.3 => /usr/lib/libtasn1.so.3 (0xb6f58000)
        libgcrypt.so.11 => /lib/libgcrypt.so.11 (0xb6f0b000)
        libgpg-error.so.0 => /lib/libgpg-error.so.0 (0xb6f07000)
	  </screen></td></tr></tbody>
	</table>
      </para>
    </section>
    <section>
      <title>Set-up LIXA environment</title>
      <para>
	Set-up the <varname>LIXA_PROFILE</varname> environment variable:
	<table frame="box">
	  <thead><tr><td>[Shell terminal session]</td></tr></thead>
	  <tbody><tr><td><screen>
tiian@ubuntu:~/tmp$ echo $LIXA_PROFILE

tiian@ubuntu:~/tmp$ export LIXA_PROFILE=PQL_STA
tiian@ubuntu:~/tmp$ echo $LIXA_PROFILE
PQL_STA
	  </screen></td></tr></tbody>
	</table>
      </para>
    </section>
    <section>
      <title>Some checks before program execution</title>
      <para>
	We set <varname>LIXA_PROFILE</varname> to value
	<quote>PQL_STA</quote>, looking at
	<filename>/opt/lixa/etc/lixac_conf.xml</filename>:
	<screen>
    &lt;profile name="PQL_STA"&gt;
      &lt;sttsrvs&gt;
        &lt;sttsrv&gt;local_1&lt;/sttsrv&gt;
      &lt;/sttsrvs&gt;
      &lt;rsrmgrs&gt;
        &lt;rsrmgr&gt;PostgreSQL_stareg&lt;/rsrmgr&gt;
      &lt;/rsrmgrs&gt;
    &lt;/profile&gt;
	</screen>
	the profile references the Resource Manager named
	<quote>PostgreSQL_stareg</quote>, looking again at the config file:
	<screen>
    &lt;rsrmgr name="PostgreSQL_stareg" switch_file="/opt/lixa/lib/switch_postgresql_stareg.so" xa_open_info="dbname=testdb" xa_close_info="" /&gt;
	</screen>
	we can discover how the PostgreSQL database is configured for XA
	<footnote><para>
	    The content of <constant>xa_open_info</constant> is passed to
	    <function>PQconnectdb</function> function: you can refer to 
	    PostgreSQL official
	    documentation to discover what you can pass to this function.
	    Please pay attention the <varname>xa_open_info</varname> can
	    contain a maximum of 255 characters: this limitation is
	    documented in <citation>XAspec</citation>.
	</para></footnote>.
      </para>
    </section>
    <section>
      <title>Program execution</title>
      <para>
	It is suggested to open two different terminals: the first one
	connected to <quote>testdb</quote> PostgreSQL database and the second
	one pointing to the directory where the compiled program
	<filename>example5_pql</filename> lives.
	First teminal session:
	<table frame="box">
	  <thead><tr><td>[PostgreSQL terminal session]</td></tr></thead>
	  <tbody><tr><td><screen>
tiian@ubuntu:~$ psql testdb
Welcome to psql 8.3.15, the PostgreSQL interactive terminal.

Type:  \copyright for distribution terms
       \h for help with SQL commands
       \? for help with psql commands
       \g or terminate with semicolon to execute query
       \q to quit

testdb=> 
	  </screen></td></tr></tbody>
	</table>
	Second teminal session:
	<table frame="box">
	  <thead><tr><td>[Shell terminal session]</td></tr></thead>
	  <tbody><tr><td><screen>
tiian@ubuntu:~/tmp$ ls -la
total 21
drwxr-xr-x   2 tiian tiian  112 2011-09-14 21:14 .
drwxrwx--x 101 tiian tiian 5064 2011-09-14 21:13 ..
-rwxr-xr-x   1 tiian tiian 8293 2011-09-13 21:27 example5_pql
-rw-r--r--   1 tiian tiian 3735 2011-09-13 21:26 example5_pql.c
	  </screen></td></tr></tbody>
	</table>
	Check the content of <quote>AUTHORS</quote> table before
	program execution:
	<table frame="box">
	  <thead><tr><td>[PostgreSQL terminal session]</td></tr></thead>
	  <tbody><tr><td><screen>
testdb=> select * from AUTHORS;
 id | last_name | first_name 
----+-----------+------------
(0 rows)
	  </screen></td></tr></tbody>
	</table>
	Execute the program:
	<table frame="box">
	  <thead><tr><td>[Shell terminal session]</td></tr></thead>
	  <tbody><tr><td><screen>
tiian@ubuntu:~/tmp$ ./example5_pql insert
Inserting a row in the table...
	  </screen></td></tr></tbody>
	</table>
	Check the content of the table again:
	<table frame="box">
	  <thead><tr><td>[PostgreSQL terminal session]</td></tr></thead>
	  <tbody><tr><td><screen>
testdb=> select * from AUTHORS;
 id | last_name | first_name 
----+-----------+------------
  1 | Foo       | Bar
(1 rows)
	  </screen></td></tr></tbody>
	</table>
	The example program inserted the row with id=1. You can not insert
	the same row twice because there is a unique constraint on this table,
	but you can remove the row using
	<table frame="box">
	  <thead><tr><td>[Shell terminal session]</td></tr></thead>
	  <tbody><tr><td><screen>
tiian@ubuntu:~/tmp$ ./example5_pql delete
Deleting a row from the table...
	  </screen></td></tr></tbody>
	</table>
	Check the table content again:
	<table frame="box">
	  <thead><tr><td>[PostgreSQL terminal session]</td></tr></thead>
	  <tbody><tr><td><screen>
testdb=> select * from AUTHORS;
 id | last_name | first_name 
----+-----------+------------
(0 rows)
	  </screen></td></tr></tbody>
	</table>
	you can verify in file
	<filename>/opt/lixa/etc/lixac_conf.xml</filename>
	that <quote>PQL_STA</quote> is associated to static registration
	<footnote><para>
	    The current implementation does not support dynamic registration
	    for PostgreSQL.
	</para></footnote>
	.
	Execute the program:
	<table frame="box">
	  <thead><tr><td>[Shell terminal session]</td></tr></thead>
	  <tbody><tr><td><screen>
tiian@ubuntu:~/tmp$ export LIXA_TRACE_MASK=0x00002000
tiian@ubuntu:~/tmp$ echo $LIXA_TRACE_MASK
0x00002000
tiian@ubuntu:~/tmp$ ./example5_pql insert 2>&amp;1 | grep xa_start
2011-09-14 21:53:13.403943 [9766/3069609728] lixa_xa_start
[...]
2011-09-14 21:53:13.448918 [9766/3069609728] lixa_xa_start: xa_start_entry(xid, 0, 0x0) = 0
2011-09-14 21:53:13.448977 [9766/3069609728] lixa_xa_start: sending 210 bytes to the server for step 24
2011-09-14 21:53:13.449104 [9766/3069609728] lixa_xa_start/excp=10/ret_cod=0/errno=0
	  </screen></td></tr></tbody>
	</table>
	Finally, clean up the table again:
	<table frame="box">
	  <thead><tr><td>[Shell terminal session]</td></tr></thead>
	  <tbody><tr><td><screen>
tiian@ubuntu:~/tmp$ unset LIXA_TRACE_MASK
tiian@ubuntu:~/tmp$ ./example5_pql delete
Deleting a row from the table...
	  </screen></td></tr></tbody>
	</table>
      </para>
    </section>
  </section>
  <section xml:id="Development_example6_pql_ora">
    <title>An example with PostgreSQL &amp; Oracle</title>
    <figure xml:id="develop6">
      <title>Deploy model of an example showing a distributed transaction with PostgreSQL and Oracle</title>
      <mediaobject>
	<imageobject>
	  <imagedata fileref="../images/LIXA_Development_6.png"/>
	</imageobject>
      </mediaobject>
    </figure>
    <para>
      This example shows as
      you can implement DTP (Distributed Transaction Processing) with two
      Resource Managers (PostgreSQL and Oracle Database Server)
      coordinated by the LIXA Transaction Manager.
      It's strongly suggested you have played with the
      examples previously shown in this chapter (see
      <xref linkend="Development"/>) before starting this more complex one.
    </para>
    <note>
      <para>
	If you did not yet installed the software provided by PostgreSQL,
	please refer to the official PostgreSQL site to download the
	software and to pick-up the information necessary to install 
	and configure
	the database. This manual does not give you information related
	to PostgreSQL technology: it is assumed you already installed and
	configured the database.
      </para>
      <para>
	If you did not yet installed the software provided by Oracle,
	please refer to the official Oracle site to download the
	software and to pick-up the information necessary to install 
	and configure
	the database. This manual does not give you information related
	to Oracle technology: it is assumed you already installed and
	configured the database.
      </para>
    </note>
    <important>
      <para>
	The LIXA software must be configured to support the PostgreSQL and
	the Oracle Database Server resource managers as explained in 
	<xref linkend="Linking_third_party_resource_managers"/>.
	As a little hint, you should configure LIXA as below:
	<screen>
./configure --with-postgresql-include=/usr/include/postgresql --with-postgresql-lib=/usr/lib \
> --with-oracle=/usr/lib/oracle/xe/app/oracle/product/10.2.0/server
	</screen>
	Please don't forget you must compile and install every time you
	re-configure.
      </para>
    </important>
    <para>
      Please follow the instructions explained 
      <itemizedlist mark="bullet">
	<listitem><para>
	    in <xref linkend="Development_setup_PostgreSQL_environment"/>
	    to set-up a running environment for PostgreSQL server
	</para></listitem>
	<listitem><para>
	    in <xref linkend="Development_setup_Oracle_environment"/>
	    to set-up a running environment for Oracle Database Server
	</para></listitem>
	<listitem><para>
	    in <xref linkend="Development_start_LIXA_server"/>
	    to start up the LIXA state server
	</para></listitem>
      </itemizedlist>
    </para>
    <section>
      <title>Build the client program</title>
      <para>
	Prepare the client (Application Program) using the below commands
	(<command>gcc</command> command was splitted on several lines 
	using <command>\</command> to help readability, but you may use
	a single line):
	<table frame="box">
	  <thead><tr><td>[Shell terminal session]</td></tr></thead>
	  <tbody><tr><td><screen>
tiian@ubuntu:~$ mkdir tmp
tiian@ubuntu:~$ cd tmp
tiian@ubuntu:~/tmp$ cp /opt/lixa/share/doc/lixa-X.Y.Z/examples/example6_pql_ora.c .
tiian@ubuntu:~/tmp$ gcc example6_pql_ora.c $(/opt/lixa/bin/lixa-config -c -f -p -d) \
> -I/usr/lib/oracle/xe/app/oracle/product/10.2.0/server/rdbms/public \
> -L/usr/lib/oracle/xe/app/oracle/product/10.2.0/server/lib -l clntsh -l nnz10 \
> -I/usr/include/postgresql -lpq -o example6_pql_ora
	  </screen></td></tr></tbody>
	</table>
	or if you are using Oracle 11.2 you will use something like this:
	<table frame="box">
	  <thead><tr><td>[Shell terminal session]</td></tr></thead>
	  <tbody><tr><td><screen>
tiian@ubuntu:~/tmp$ gcc example6_pql_ora.c $(/opt/lixa/bin/lixa-config -c -f -p -d) \
> -I/u01/app/oracle/product/11.2.0/xe/rdbms/public \
> -L/u01/app/oracle/product/11.2.0/xe/lib -l clntsh -l nnz11 \
> -I/usr/include/postgresql -lpq -o example6_pql_ora
	  </screen></td></tr></tbody>
	</table>
	Verify the executable produced by <command>gcc</command>:
	<table frame="box">
	  <thead><tr><td>[Shell terminal session]</td></tr></thead>
	  <tbody><tr><td><screen>
tiian@ubuntu:~/tmp$ ldd example6_pql_ora
        linux-gate.so.1 =>  (0xb7731000)
        liblixac.so.0 => /opt/lixa/lib/liblixac.so.0 (0xb7716000)
        liblixapq.so.0 => /opt/lixa/lib/liblixapq.so.0 (0xb770f000)
        libclntsh.so.10.1 => not found
        libnnz10.so => not found
        libpq.so.5 => /usr/lib/libpq.so.5 (0xb76e1000)
        libc.so.6 => /lib/tls/i686/cmov/libc.so.6 (0xb7592000)
        libgmodule-2.0.so.0 => /usr/lib/libgmodule-2.0.so.0 (0xb758e000)
        libdl.so.2 => /lib/tls/i686/cmov/libdl.so.2 (0xb7589000)
        libgthread-2.0.so.0 => /usr/lib/libgthread-2.0.so.0 (0xb7584000)
        librt.so.1 => /lib/tls/i686/cmov/librt.so.1 (0xb757b000)
        libglib-2.0.so.0 => /usr/lib/libglib-2.0.so.0 (0xb74ca000)
        libxml2.so.2 => /usr/lib/libxml2.so.2 (0xb73aa000)
        liblixab.so.0 => /opt/lixa/lib/liblixab.so.0 (0xb7395000)
        libm.so.6 => /lib/tls/i686/cmov/libm.so.6 (0xb736f000)
        libpthread.so.0 => /lib/tls/i686/cmov/libpthread.so.0 (0xb7357000)
        libssl.so.0.9.8 => /usr/lib/i686/cmov/libssl.so.0.9.8 (0xb7311000)
        libcrypto.so.0.9.8 => /usr/lib/i686/cmov/libcrypto.so.0.9.8 (0xb71cf000)
        libkrb5.so.3 => /usr/lib/libkrb5.so.3 (0xb7142000)
        libcom_err.so.2 => /lib/libcom_err.so.2 (0xb713e000)
        libgssapi_krb5.so.2 => /usr/lib/libgssapi_krb5.so.2 (0xb7115000)
        libcrypt.so.1 => /lib/tls/i686/cmov/libcrypt.so.1 (0xb70e3000)
        libldap_r-2.4.so.2 => /usr/lib/libldap_r-2.4.so.2 (0xb70a3000)
        /lib/ld-linux.so.2 (0xb7732000)
        libpcre.so.3 => /usr/lib/libpcre.so.3 (0xb707c000)
        libz.so.1 => /usr/lib/libz.so.1 (0xb7066000)
        libuuid.so.1 => /lib/libuuid.so.1 (0xb7062000)
        libk5crypto.so.3 => /usr/lib/libk5crypto.so.3 (0xb703f000)
        libkrb5support.so.0 => /usr/lib/libkrb5support.so.0 (0xb7037000)
        libkeyutils.so.1 => /lib/libkeyutils.so.1 (0xb7034000)
        libresolv.so.2 => /lib/tls/i686/cmov/libresolv.so.2 (0xb7020000)
        liblber-2.4.so.2 => /usr/lib/liblber-2.4.so.2 (0xb7013000)
        libsasl2.so.2 => /usr/lib/libsasl2.so.2 (0xb6ffc000)
        libgnutls.so.13 => /usr/lib/libgnutls.so.13 (0xb6f86000)
        libtasn1.so.3 => /usr/lib/libtasn1.so.3 (0xb6f76000)
        libgcrypt.so.11 => /lib/libgcrypt.so.11 (0xb6f28000)
        libgpg-error.so.0 => /lib/libgpg-error.so.0 (0xb6f24000)
	  </screen></td></tr></tbody>
	</table>
      </para>
    </section>
    <section>
      <title>Set-up LIXA environment</title>
      <para>
	There are four unresolved references that can be fixed setting up
	the environment properly; you can fix the environment manually or
	using this script supplied by Oracle:
	<filename>/usr/lib/oracle/xe/app/oracle/product/10.2.0/server/bin/oracle_env.sh</filename>
	<table frame="box">
	  <thead><tr><td>[Shell terminal session]</td></tr></thead>
	  <tbody><tr><td><screen>
tiian@ubuntu:~/tmp$ echo $LD_LIBRARY_PATH

tiian@ubuntu:~/tmp$ . /usr/lib/oracle/xe/app/oracle/product/10.2.0/server/bin/oracle_env.sh
tiian@ubuntu:~/tmp$ echo $LD_LIBRARY_PATH
/usr/lib/oracle/xe/app/oracle/product/10.2.0/server/lib:
	  </screen></td></tr></tbody>
	</table>
	Oracle 11.2 <filename>oracle_env.sh</filename> does not set
	environment variable <varname>LD_LIBRARY_PATH</varname> and you
	should set-up it manually:
	<table frame="box">
	  <thead><tr><td>[Shell terminal session]</td></tr></thead>
	  <tbody><tr><td><screen>
tiian@ubuntu:~/tmp$ echo $LD_LIBRARY_PATH

tiian@ubuntu:~/tmp$ export LD_LIBRARY_PATH=/u01/app/oracle/product/11.2.0/xe/lib
tiian@ubuntu:~/tmp$ echo $LD_LIBRARY_PATH
/u01/app/oracle/product/11.2.0/xe/lib
	  </screen></td></tr></tbody>
	</table>
	Check again the executable:
	<table frame="box">
	  <thead><tr><td>[Shell terminal session]</td></tr></thead>
	  <tbody><tr><td><screen>
tiian@ubuntu:~/tmp$ ldd example6_pql_ora                                                linux-gate.so.1 =>  (0xb770b000)
        liblixac.so.0 => /opt/lixa/lib/liblixac.so.0 (0xb76f0000)
        liblixapq.so.0 => /opt/lixa/lib/liblixapq.so.0 (0xb76e9000)
        libclntsh.so.10.1 => /usr/lib/oracle/xe/app/oracle/product/10.2.0/server/lib/libclntsh.so.10.1 (0xb6934000)
        libnnz10.so => /usr/lib/oracle/xe/app/oracle/product/10.2.0/server/lib/libnnz10.so (0xb672f000)
        libpq.so.5 => /usr/lib/libpq.so.5 (0xb6702000)
        libc.so.6 => /lib/tls/i686/cmov/libc.so.6 (0xb65b3000)
        libgmodule-2.0.so.0 => /usr/lib/libgmodule-2.0.so.0 (0xb65af000)
        libdl.so.2 => /lib/tls/i686/cmov/libdl.so.2 (0xb65aa000)
        libgthread-2.0.so.0 => /usr/lib/libgthread-2.0.so.0 (0xb65a5000)
        librt.so.1 => /lib/tls/i686/cmov/librt.so.1 (0xb659c000)
        libglib-2.0.so.0 => /usr/lib/libglib-2.0.so.0 (0xb64eb000)
        libxml2.so.2 => /usr/lib/libxml2.so.2 (0xb63cb000)
        liblixab.so.0 => /opt/lixa/lib/liblixab.so.0 (0xb63b6000)
        libm.so.6 => /lib/tls/i686/cmov/libm.so.6 (0xb6390000)
        libpthread.so.0 => /lib/tls/i686/cmov/libpthread.so.0 (0xb6378000)
        libnsl.so.1 => /lib/tls/i686/cmov/libnsl.so.1 (0xb6360000)
        libssl.so.0.9.8 => /usr/lib/i686/cmov/libssl.so.0.9.8 (0xb631a000)
        libcrypto.so.0.9.8 => /usr/lib/i686/cmov/libcrypto.so.0.9.8 (0xb61d8000)
        libkrb5.so.3 => /usr/lib/libkrb5.so.3 (0xb614a000)
        libcom_err.so.2 => /lib/libcom_err.so.2 (0xb6147000)
        libgssapi_krb5.so.2 => /usr/lib/libgssapi_krb5.so.2 (0xb611e000)
        libcrypt.so.1 => /lib/tls/i686/cmov/libcrypt.so.1 (0xb60ec000)
        libldap_r-2.4.so.2 => /usr/lib/libldap_r-2.4.so.2 (0xb60ac000)
        /lib/ld-linux.so.2 (0xb770c000)
        libpcre.so.3 => /usr/lib/libpcre.so.3 (0xb6084000)
        libz.so.1 => /usr/lib/libz.so.1 (0xb606f000)
        libuuid.so.1 => /lib/libuuid.so.1 (0xb606b000)
        libk5crypto.so.3 => /usr/lib/libk5crypto.so.3 (0xb6048000)
        libkrb5support.so.0 => /usr/lib/libkrb5support.so.0 (0xb6040000)
        libkeyutils.so.1 => /lib/libkeyutils.so.1 (0xb603c000)
        libresolv.so.2 => /lib/tls/i686/cmov/libresolv.so.2 (0xb6029000)
        liblber-2.4.so.2 => /usr/lib/liblber-2.4.so.2 (0xb601c000)
        libsasl2.so.2 => /usr/lib/libsasl2.so.2 (0xb6005000)
        libgnutls.so.13 => /usr/lib/libgnutls.so.13 (0xb5f8f000)
        libtasn1.so.3 => /usr/lib/libtasn1.so.3 (0xb5f7e000)
        libgcrypt.so.11 => /lib/libgcrypt.so.11 (0xb5f31000)
        libgpg-error.so.0 => /lib/libgpg-error.so.0 (0xb5f2d000)
	  </screen></td></tr></tbody>
	</table>
	Set-up the necessary environment variables:
	<table frame="box">
	  <thead><tr><td>[Shell terminal session]</td></tr></thead>
	  <tbody><tr><td><screen>
tiian@ubuntu:~/tmp$ echo $LIXA_PROFILE

tiian@ubuntu:~/tmp$ export LIXA_PROFILE=PQL_STA_ORA_DYN
tiian@ubuntu:~/tmp$ echo $LIXA_PROFILE
PQL_STA_ORA_DYN
	  </screen></td></tr></tbody>
	</table>
	The below environment variables were set by the previous sourced
	script; take a look to them:
	<table frame="box">
	  <thead><tr><td>[Shell terminal session]</td></tr></thead>
	  <tbody><tr><td><screen>
tiian@ubuntu:~/tmp$ echo $ORACLE_HOME
/usr/lib/oracle/xe/app/oracle/product/10.2.0/server
tiian@ubuntu:~/tmp$ echo $PATH
/usr/lib/oracle/xe/app/oracle/product/10.2.0/server/bin:/usr/local/sbin:/usr/local/bin:/usr/sbin:/usr/bin:/sbin:/bin:/usr/games
tiian@ubuntu:~/tmp$ echo $ORACLE_SID
XE
	  </screen></td></tr></tbody>
	</table>
	It is suggested to set the necessary environment variables in your 
	profile if you are going to execute the programs many times.
	This is the list of the suggested variables:
	<varname>LD_LIBRARY_PATH</varname>,
	<varname>LIXA_PROFILE</varname>,
	<varname>ORACLE_HOME</varname>,
	<varname>ORACLE_SID</varname>,
	<varname>PATH</varname>.
      </para>
    </section>
    <section xml:id="example5_some_checks">
      <title>Some checks before program execution</title>
      <para>
	We set <varname>LIXA_PROFILE</varname> to value
	<quote>PQL_STA_ORA_DYN</quote>, looking at
	<filename>/opt/lixa/etc/lixac_conf.xml</filename>:
	<screen>
    &lt;profile name="PQL_STA_ORA_DYN"&gt;
      &lt;sttsrvs&gt;
        &lt;sttsrv&gt;local_1&lt;/sttsrv&gt;
      &lt;/sttsrvs&gt;
      &lt;rsrmgrs&gt;
        &lt;rsrmgr&gt;PostgreSQL_stareg&lt;/rsrmgr&gt;
        &lt;rsrmgr&gt;OracleXE_dynreg&lt;/rsrmgr&gt;
      &lt;/rsrmgrs&gt;
    &lt;/profile&gt;
	</screen>
	the profile references two Resource Managers:
	<quote>PostgreSQL_stareg</quote> and <quote>OracleXE_dynreg</quote>, 
	looking again at the config file:
	<screen>
    &lt;rsrmgr name="OracleXE_dynreg" switch_file="/opt/lixa/lib/switch_oracle_dynreg.so" xa_open_info="Oracle_XA+Acc=P/hr/hr+SesTm=30+LogDir=/tmp+threads=true+DbgFl=7+Loose_Coupling=true" xa_close_info="" /&gt;
    &lt;rsrmgr name="PostgreSQL_stareg" switch_file="/opt/lixa/lib/switch_postgresql_stareg.so" xa_open_info="dbname=testdb" xa_close_info="" /&gt;
	</screen>
	we can discover how our application will access the resource
	managers
	<footnote>
	  <para>
	    The content of <constant>xa_open_info</constant> is passed to
	    <function>PQconnectdb</function> function: you can refer to 
	    PostgreSQL official
	    documentation to discover what you can pass to this function.
	    Please pay attention the <varname>xa_open_info</varname> can
	    contain a maximum of 255 characters: this limitation is
	    documented in <citation>XAspec</citation>.
	  </para>
	</footnote>
	<footnote>
	  <para>
	    The content of <constant>xa_open_info</constant> string is
	    described in chapter 15 "Developing Applications with Oracle XA"
	    of the "Oracle Database Application Developer's Guide"
	    manual; please refer to the documentation published by
	    Oracle Corporation for further details.
	  </para>
	</footnote>. 
      </para>
      <para>
	Verify no (Oracle) trace file exists:
	<screen>
tiian@ubuntu:~/tmp$ ls -la /tmp/xa*
ls: cannot access /tmp/xa*: No such file or directory
	</screen>
      </para>
    </section>
    <section>
      <title>Program execution (dynamic registration for Oracle)</title>
      <para>
	It is suggested to open three different terminals: 
	the first one connected to <quote>testdb</quote> PostgreSQL database,
	the second one connected to Oracle database and the
	third one pointing to the directory where the compiled program 
	example6_pql_ora lives.
	<table frame="box">
	  <thead><tr><td>[PostgreSQL terminal session]</td></tr></thead>
	  <tbody><tr><td><screen>
tiian@ubuntu:~$ psql testdb
Welcome to psql 8.3.15, the PostgreSQL interactive terminal.

Type:  \copyright for distribution terms
       \h for help with SQL commands
       \? for help with psql commands
       \g or terminate with semicolon to execute query
       \q to quit

testdb=>
	  </screen></td></tr></tbody>
	</table>
	<table frame="box">
	  <thead><tr><td>[Oracle terminal session]</td></tr></thead>
	  <tbody><tr><td><screen>
tiian@ubuntu:~$ . /usr/lib/oracle/xe/app/oracle/product/10.2.0/server/bin/oracle_env.sh
tiian@ubuntu:~$ sqlplus "hr/hr"                                                 
SQL*Plus: Release 10.2.0.1.0 - Production on Tue May 3 21:52:06 2011

Copyright (c) 1982, 2005, Oracle.  All rights reserved.


Connected to:
Oracle Database 10g Express Edition Release 10.2.0.1.0 - Production

SQL>
	  </screen></td></tr></tbody>
	</table>
	<table frame="box">
	  <thead><tr><td>[Shell terminal session]</td></tr></thead>
	  <tbody><tr><td><screen>
tiian@ubuntu:~/tmp$ ls -la
total 28
drwxr-xr-x  2 tiian tiian  4096 2011-09-20 21:53 .
drwxr-xr-x 40 tiian tiian  4096 2011-09-19 20:54 ..
-rwxr-xr-x  1 tiian tiian 11219 2011-09-18 21:24 example6_pql_ora
-rw-r--r--  1 tiian tiian  7176 2011-09-18 21:24 example6_pql_ora.c
	  </screen></td></tr></tbody>
	</table>
	Check the content of the PostgreSQL table (<quote>AUTHORS</quote>):
	<table frame="box">
	  <thead><tr><td>[PostgreSQL terminal session]</td></tr></thead>
	  <tbody><tr><td><screen>
testdb=> select * from AUTHORS;
 id | last_name | first_name
----+-----------+------------
(0 rows)
	  </screen></td></tr></tbody>
	</table>
	Check the content of the Oracle table (<quote>COUNTRIES</quote>):
	<table frame="box">
	  <thead><tr><td>[Oracle terminal session]</td></tr></thead>
	  <tbody><tr><td><screen>
SQL> select * from COUNTRIES where COUNTRY_ID = 'RS';

no rows selected
	  </screen></td></tr></tbody>
	</table>
	Insert a row in all the tables and check the contents of the tables
	after the transaction execution:
	<table frame="box">
	  <thead><tr><td>[Third terminal session]</td></tr></thead>
	  <tbody><tr><td><screen>
tiian@ubuntu:~/tmp$ ./example6_pql_ora insert
Inserting a row in the tables...
Oracle INSERT statement executed!
	  </screen></td></tr></tbody>
	</table>
	Now you can verify the content of the tables after the transaction:
	<table frame="box">
	  <thead><tr><td>[PostgreSQL terminal session]</td></tr></thead>
	  <tbody><tr><td><screen>
testdb=> select * from AUTHORS;
 id | last_name | first_name
----+-----------+------------
  1 | Foo       | Bar
(1 row)
	  </screen></td></tr></tbody>
	</table>
	<table frame="box">
	  <thead><tr><td>[Oracle terminal session]</td></tr></thead>
	  <tbody><tr><td><screen>
SQL> select * from COUNTRIES where COUNTRY_ID = 'RS';

CO COUNTRY_NAME                              REGION_ID
-- ---------------------------------------- ----------
RS Repubblica San Marino                             1
	  </screen></td></tr></tbody>
	</table>
	With the opposite command you can remove the rows from the tables:
	<table frame="box">
	  <thead><tr><td>[Shell terminal session]</td></tr></thead>
	  <tbody><tr><td><screen>
tiian@ubuntu:~/tmp$ ./example6_pql_ora delete
Deleting a row from the tables...
Oracle DELETE statement executed!
	  </screen></td></tr></tbody>
	</table>
	and check the content of the tables again:
	<table frame="box">
	  <thead><tr><td>[PostgreSQL terminal session]</td></tr></thead>
	  <tbody><tr><td><screen>
testdb=> select * from AUTHORS;
 id | last_name | first_name
----+-----------+------------
(0 rows)
	  </screen></td></tr></tbody>
	</table>
	<table frame="box">
	  <thead><tr><td>[Oracle terminal session]</td></tr></thead>
	  <tbody><tr><td><screen>
SQL> select * from COUNTRIES where COUNTRY_ID = 'RS';

no rows selected
	  </screen></td></tr></tbody>
	</table>
	We can verify the dynamic registration behavior of Oracle:
	<table frame="box">
	  <thead><tr><td>[Shell terminal session]</td></tr></thead>
	  <tbody><tr><td><screen>
tiian@ubuntu:~/tmp$ export LIXA_TRACE_MASK=0x00002000
tiian@ubuntu:~/tmp$ echo $LIXA_TRACE_MASK
0x00002000
tiian@ubuntu:~/tmp$ ./example6_pql_ora insert 2>&amp;1 | grep ax_reg
2011-09-20 22:11:01.669440 [6844/3052865280] ax_reg: rmid=1, xid=0xbfe4cdcc, flags=0x0
2011-09-20 22:11:01.669537 [6844/3052865280] ax_reg: the application program has started a transaction (TX states S3); this XID '1279875137.ce4993340a46495e94f07dbbdd5d0366.6e8ecf5972a778ab648b5950c0f96dd6' will be returned
2011-09-20 22:11:01.669591 [6844/3052865280] ax_reg: sending 153 bytes to the server for step 8
2011-09-20 22:11:01.669639 [6844/3052865280] ax_reg/excp=7/ret_cod=0/errno=0
	  </screen></td></tr></tbody>
	</table>
	We can check the static registration behavior of Oracle with a 
	different profile:
	<table frame="box">
	  <thead><tr><td>[Shell terminal session]</td></tr></thead>
	  <tbody><tr><td><screen>
tiian@ubuntu:~/tmp$ export LIXA_PROFILE=PQL_STA_ORA_STA
tiian@ubuntu:~/tmp$ echo $LIXA_PROFILE
PQL_STA_ORA_STA
tiian@ubuntu:~/tmp$ ./example6_pql_ora delete 2>&amp;1 | grep xa_start
2011-09-20 22:22:22.561677 [22658/3052615424] lixa_xa_start
[...]
2011-09-20 22:22:22.608794 [22658/3052615424] lixa_xa_start: xa_start_entry(xid, 0, 0x0) = 0
2011-09-20 22:22:22.610649 [22658/3052615424] lixa_xa_start: xa_start_entry(xid, 1, 0x0) = 0
2011-09-20 22:22:22.610694 [22658/3052615424] lixa_xa_start: sending 281 bytes to the server for step 24
2011-09-20 22:22:22.610757 [22658/3052615424] lixa_xa_start/excp=10/ret_cod=0/errno=0
	  </screen></td></tr></tbody>
	</table>
	and check the content of the tables again:
	<table frame="box">
	  <thead><tr><td>[PostgreSQL terminal session]</td></tr></thead>
	  <tbody><tr><td><screen>
testdb=> select * from AUTHORS;
 id | last_name | first_name
----+-----------+------------
(0 rows)
	  </screen></td></tr></tbody>
	</table>
	<table frame="box">
	  <thead><tr><td>[Oracle terminal session]</td></tr></thead>
	  <tbody><tr><td><screen>
SQL> select * from COUNTRIES where COUNTRY_ID = 'RS';

no rows selected
	  </screen></td></tr></tbody>
	</table>
	The activity of the Oracle database can be analyzed in the trace file:
	<table frame="box">
	  <thead><tr><td>[Shell terminal session]</td></tr></thead>
	  <tbody><tr><td><screen>
tiian@ubuntu:~/tmp$ ls -la /tmp/xa_NULL09202011.trc
-rw-r--r-- 1 tiian tiian 12042 2011-09-20 22:22 /tmp/xa_NULL09202011.trc
	  </screen></td></tr></tbody>
	</table>
      </para>
    </section>
  </section>
  <section xml:id="Development_example7_pql_ora">
    <title>An example with PostgreSQL &amp; IBM DB2</title>
    <figure xml:id="develop7">
      <title>Deploy model of an example showing a distributed transaction with PostgreSQL and IBM DB2</title>
      <mediaobject>
	<imageobject>
	  <imagedata fileref="../images/LIXA_Development_7.png"/>
	</imageobject>
      </mediaobject>
    </figure>
    <para>
      This example shows as
      you can implement DTP (Distributed Transaction Processing) with two
      Resource Managers (PostgreSQL and IBM DB2)
      coordinated by the LIXA Transaction Manager.
      It's strongly suggested you have played with the
      examples previously shown in this chapter (see
      <xref linkend="Development"/>) before starting this more complex one.
    </para>
    <note>
      <para>
	If you did not yet installed the software provided by PostgreSQL,
	please refer to the official PostgreSQL site to download the
	software and to pick-up the information necessary to install 
	and configure
	the database. This manual does not give you information related
	to PostgreSQL technology: it is assumed you already installed and
	configured the database.
      </para>
      <para>
	If you did not yet installed the software provided by IBM,
	please refer to the official IBM site to download the
	software and to pick-up the information necessary to install 
	and configure
	the database. This manual does not give you information related
	to IBM DB2 technology: it is assumed you already installed and
	configured the database.
      </para>
    </note>
    <important>
      <para>
	The LIXA software must be configured to support the PostgreSQL and
	the IBM DB2 resource managers as explained in 
	<xref linkend="Linking_third_party_resource_managers"/>.
	As a little hint, you should configure LIXA as below:
	<screen>
./configure --with-postgresql-include=/usr/include/postgresql --with-postgresql-lib=/usr/lib \
> --with-ibmdb2=/opt/ibm/db2/V9.7
	</screen>
	Please don't forget you must compile and install every time you
	re-configure.
      </para>
    </important>
    <para>
      Please follow the instructions explained 
      <itemizedlist mark="bullet">
	<listitem><para>
	    in <xref linkend="Development_setup_PostgreSQL_environment"/>
	    to set-up a running environment for PostgreSQL server
	</para></listitem>
	<listitem><para>
	    in <xref linkend="Development_setup_DB2_environment"/>
	    to set-up a running environment for IBM DB2
	</para></listitem>
	<listitem><para>
	    in <xref linkend="Development_start_LIXA_server"/>
	    to start up the LIXA state server
	</para></listitem>
      </itemizedlist>
    </para>
    <section>
      <title>Build the client program</title>
      <para>
	Prepare the client (Application Program) using the below commands
	(<command>gcc</command> command was splitted on several lines 
	using <command>\</command> to help readability, but you may use
	a single line):
	<table frame="box">
	  <thead><tr><td>[Shell terminal session]</td></tr></thead>
	  <tbody><tr><td><screen>
tiian@ubuntu:~$ mkdir tmp
tiian@ubuntu:~$ cd tmp
tiian@ubuntu:~/tmp$ cp /opt/lixa/share/doc/lixa-X.Y.Z/examples/example7_pql_db2.c .
tiian@ubuntu:~/tmp$ gcc example7_pql_db2.c $(/opt/lixa/bin/lixa-config -c -f -p -d) \
> -I/usr/include/postgresql -lpq \
> -I/opt/ibm/db2/V9.7/include -L/opt/ibm/db2/V9.7/lib32 -ldb2 \
> -o example7_pql_db2
	  </screen></td></tr></tbody>
	</table>
	Verify the executable produced by <command>gcc</command>:
	<table frame="box">
	  <thead><tr><td>[Shell terminal session]</td></tr></thead>
	  <tbody><tr><td><screen>
tiian@ubuntu:~/tmp$ ldd example7_pql_db2
        linux-gate.so.1 =>  (0xb7780000)
        liblixac.so.0 => /opt/lixa/lib/liblixac.so.0 (0xb7765000)
        liblixapq.so.0 => /opt/lixa/lib/liblixapq.so.0 (0xb775e000)
        libpq.so.5 => /usr/lib/libpq.so.5 (0xb7730000)
        libdb2.so.1 => /usr/lib/libdb2.so.1 (0xb61fe000)
        libc.so.6 => /lib/tls/i686/cmov/libc.so.6 (0xb60af000)
        libgmodule-2.0.so.0 => /usr/lib/libgmodule-2.0.so.0 (0xb60ab000)
        libdl.so.2 => /lib/tls/i686/cmov/libdl.so.2 (0xb60a7000)
        libgthread-2.0.so.0 => /usr/lib/libgthread-2.0.so.0 (0xb60a2000)
        librt.so.1 => /lib/tls/i686/cmov/librt.so.1 (0xb6098000)
        libglib-2.0.so.0 => /usr/lib/libglib-2.0.so.0 (0xb5fe7000)
        libxml2.so.2 => /usr/lib/libxml2.so.2 (0xb5ec7000)
        liblixab.so.0 => /opt/lixa/lib/liblixab.so.0 (0xb5eb2000)
        libm.so.6 => /lib/tls/i686/cmov/libm.so.6 (0xb5e8d000)
        libpthread.so.0 => /lib/tls/i686/cmov/libpthread.so.0 (0xb5e74000)
        libssl.so.0.9.8 => /usr/lib/i686/cmov/libssl.so.0.9.8 (0xb5e2e000)
        libcrypto.so.0.9.8 => /usr/lib/i686/cmov/libcrypto.so.0.9.8 (0xb5cec000)
        libkrb5.so.3 => /usr/lib/libkrb5.so.3 (0xb5c5f000)
        libcom_err.so.2 => /lib/libcom_err.so.2 (0xb5c5c000)
        libgssapi_krb5.so.2 => /usr/lib/libgssapi_krb5.so.2 (0xb5c33000)
        libcrypt.so.1 => /lib/tls/i686/cmov/libcrypt.so.1 (0xb5c00000)
        libldap_r-2.4.so.2 => /usr/lib/libldap_r-2.4.so.2 (0xb5bc0000)
        libpam.so.0 => /lib/libpam.so.0 (0xb5bb6000)
        libdb2dascmn.so.1 => /opt/ibm/db2/V9.7/lib32/libdb2dascmn.so.1 (0xb5b88000)
        libdb2g11n.so.1 => /opt/ibm/db2/V9.7/lib32/libdb2g11n.so.1 (0xb551a000)
        libdb2genreg.so.1 => /opt/ibm/db2/V9.7/lib32/libdb2genreg.so.1 (0xb54da000)
        libdb2install.so.1 => /opt/ibm/db2/V9.7/lib32/libdb2install.so.1 (0xb54cf000)
        libdb2locale.so.1 => /opt/ibm/db2/V9.7/lib32/libdb2locale.so.1 (0xb54bc000)
        libdb2osse.so.1 => /opt/ibm/db2/V9.7/lib32/libdb2osse.so.1 (0xb51b6000)
        libdb2osse_db2.so.1 => /opt/ibm/db2/V9.7/lib32/libdb2osse_db2.so.1 (0xb5146000)
        libdb2trcapi.so.1 => /opt/ibm/db2/V9.7/lib32/libdb2trcapi.so.1 (0xb5133000)
        libstdc++.so.6 => /usr/lib/libstdc++.so.6 (0xb5040000)
        libgcc_s.so.1 => /lib/libgcc_s.so.1 (0xb5035000)
        /lib/ld-linux.so.2 (0xb7781000)
        libpcre.so.3 => /usr/lib/libpcre.so.3 (0xb500d000)
        libz.so.1 => /usr/lib/libz.so.1 (0xb4ff8000)
        libuuid.so.1 => /lib/libuuid.so.1 (0xb4ff4000)
        libk5crypto.so.3 => /usr/lib/libk5crypto.so.3 (0xb4fd1000)
        libkrb5support.so.0 => /usr/lib/libkrb5support.so.0 (0xb4fc9000)
        libkeyutils.so.1 => /lib/libkeyutils.so.1 (0xb4fc5000)
        libresolv.so.2 => /lib/tls/i686/cmov/libresolv.so.2 (0xb4fb2000)
        liblber-2.4.so.2 => /usr/lib/liblber-2.4.so.2 (0xb4fa5000)
        libsasl2.so.2 => /usr/lib/libsasl2.so.2 (0xb4f8e000)
        libgnutls.so.13 => /usr/lib/libgnutls.so.13 (0xb4f18000)
        libtasn1.so.3 => /usr/lib/libtasn1.so.3 (0xb4f07000)
        libgcrypt.so.11 => /lib/libgcrypt.so.11 (0xb4eba000)
        libgpg-error.so.0 => /lib/libgpg-error.so.0 (0xb4eb6000)
	  </screen></td></tr></tbody>
	</table>
      </para>
    </section>
    <section>
      <title>Set-up LIXA environment</title>
      <para>
	Set-up the necessary environment variables:
	<table frame="box">
	  <thead><tr><td>[Shell terminal session]</td></tr></thead>
	  <tbody><tr><td><screen>
tiian@ubuntu:~/tmp$ echo $LIXA_PROFILE

tiian@ubuntu:~/tmp$ export LIXA_PROFILE=PQL_STA_DB2_DYN
tiian@ubuntu:~/tmp$ echo $LIXA_PROFILE
PQL_STA_DB2_DYN
	  </screen></td></tr></tbody>
	</table>
	It is suggested to set the necessary environment variables in your 
	profile if you are going to execute the programs many times.
	This is the list of the suggested variables:
	<varname>LIXA_PROFILE</varname>,
	<varname>PATH</varname>.
      </para>
    </section>
    <section>
      <title>Some checks before program execution</title>
      <para>
	We set <varname>LIXA_PROFILE</varname> to value
	<quote>PQL_STA_DB2_DYN</quote>, looking at
	<filename>/opt/lixa/etc/lixac_conf.xml</filename>:
	<screen>
    &lt;profile name="PQL_STA_DB2_DYN"&gt;
      &lt;sttsrvs&gt;
        &lt;sttsrv&gt;local_1&lt;/sttsrv&gt;
      &lt;/sttsrvs&gt;
      &lt;rsrmgrs&gt;
        &lt;rsrmgr&gt;PostgreSQL_stareg&lt;/rsrmgr&gt;
        &lt;rsrmgr&gt;IBMDB2_dynreg&lt;/rsrmgr&gt;
      &lt;/rsrmgrs&gt;
    &lt;/profile&gt;
	</screen>
	the profile references two Resource Managers:
	<quote>PostgreSQL_stareg</quote> and <quote>IBMDB2_dynreg</quote>, 
	looking again at the config file:
	<screen>
    &lt;rsrmgr name="PostgreSQL_stareg" switch_file="/opt/lixa/lib/switch_postgresql_stareg.so" xa_open_info="dbname=testdb" xa_close_info="" /&gt;
    &lt;rsrmgr name="IBMDB2_dynreg" switch_file="/opt/lixa/lib/switch_ibmdb2_dynreg.so" xa_open_info="axlib=/opt/lixa/lib/liblixac.so,db=sample,tpm=lixa" xa_close_info="" /&gt;
	</screen>
	we can discover how our application will access the resource
	managers
	<footnote>
	  <para>
	    The content of <constant>xa_open_info</constant> is passed to
	    <function>PQconnectdb</function> function: you can refer to 
	    PostgreSQL official
	    documentation to discover what you can pass to this function.
	    Please pay attention the <varname>xa_open_info</varname> can
	    contain a maximum of 255 characters: this limitation is
	    documented in <citation>XAspec</citation>.
	  </para>
	</footnote>
	<footnote>
	  <para>
	    The content of <constant>xa_open_info</constant> string is
	    documented at IBM Infocenter: search the string
	    <quote>xa_open string formats</quote> in the documentation
	    relevant to your installed version; this is a link
	    <link xlink:href="http://publib.boulder.ibm.com/infocenter/db2luw/v9r7/topic/com.ibm.db2.luw.admin.2pc.doc/doc/r0005080.html">
	      http://publib.boulder.ibm.com/infocenter/db2luw/v9r7/topic/com.ibm.db2.luw.admin.2pc.doc/doc/r0005080.html
	    </link>
	    but it may change in the future.
	  </para>
	</footnote>. 
      </para>
    </section>
    <section>
      <title>Program execution (dynamic registration)</title>
      <para>
	It is suggested to open three different terminals: 
	the first one connected to <quote>TESTDB</quote> PostgreSQL database,
	the second one connected to <quote>SAMPLE</quote> DB2 database
	and the	third one pointing to the directory where the compiled program 
	example7_pql_db2 lives.
	<table frame="box">
	  <thead><tr><td>[PostgreSQL terminal session]</td></tr></thead>
	  <tbody><tr><td><screen>
tiian@ubuntu:~$ psql testdb
Welcome to psql 8.3.15, the PostgreSQL interactive terminal.

Type:  \copyright for distribution terms
       \h for help with SQL commands
       \? for help with psql commands
       \g or terminate with semicolon to execute query
       \q to quit

testdb=>
	  </screen></td></tr></tbody>
	</table>
	<table frame="box">
	  <thead><tr><td>[IBM DB2 terminal session]</td></tr></thead>
	  <tbody><tr><td><screen>
tiian@ubuntu:~$ . /home/db2inst1/sqllib/db2profile
tiian@ubuntu:~$ db2
(c) Copyright IBM Corporation 1993,2007
Command Line Processor for DB2 Client 9.7.1

You can issue database manager commands and SQL statements from the command
prompt. For example:
    db2 => connect to sample
    db2 => bind sample.bnd

For general help, type: ?.
For command help, type: ? command, where command can be
the first few keywords of a database manager command. For example:
 ? CATALOG DATABASE for help on the CATALOG DATABASE command
 ? CATALOG          for help on all of the CATALOG commands.

To exit db2 interactive mode, type QUIT at the command prompt. Outside
interactive mode, all commands must be prefixed with 'db2'.
To list the current command option settings, type LIST COMMAND OPTIONS.

For more detailed help, refer to the Online Reference Manual.

db2 => connect to SAMPLE

   Database Connection Information

 Database server        = DB2/LINUX 9.7.1
 SQL authorization ID   = TIIAN
 Local database alias   = SAMPLE

db2 =>
	  </screen></td></tr></tbody>
	</table>
	<table frame="box">
	  <thead><tr><td>[Shell terminal session]</td></tr></thead>
	  <tbody><tr><td><screen>
tiian@ubuntu:~/tmp$ ls -la
total 32
drwxr-xr-x  2 tiian tiian  4096 2011-09-25 17:11 .
drwxr-xr-x 40 tiian tiian  4096 2011-09-22 22:24 ..
-rwxr-xr-x  1 tiian tiian 12429 2011-09-22 22:47 example7_pql_db2
-rw-r--r--  1 tiian tiian  7541 2011-09-22 22:46 example7_pql_db2.c
	  </screen></td></tr></tbody>
	</table>
	Check the content of the PostgreSQL table (<quote>AUTHORS</quote>):
	<table frame="box">
	  <thead><tr><td>[PostgreSQL terminal session]</td></tr></thead>
	  <tbody><tr><td><screen>
testdb=> select * from AUTHORS;
 id | last_name | first_name
----+-----------+------------
(0 rows)
	  </screen></td></tr></tbody>
	</table>
	Check the content of the DB2 tables (<quote>DB2INST1.ORG</quote> and
	<quote>DB2INST1.DEPT</quote>):
	<table frame="box">
	  <thead><tr><td>[IBM DB2 terminal session]</td></tr></thead>
	  <tbody><tr><td><screen>
db2 => select * from DB2INST1.ORG where DEPTNUMB = 150

DEPTNUMB DEPTNAME       MANAGER DIVISION   LOCATION
-------- -------------- ------- ---------- -------------

  0 record(s) selected.

db2 => select * from DB2INST1.DEPT where DEPTNO='Z99'

DEPTNO DEPTNAME                             MGRNO  ADMRDEPT LOCATION
------ ------------------------------------ ------ -------- ----------------

  0 record(s) selected.
	  </screen></td></tr></tbody>
	</table>
	Insert a row in PostgreSQL <quote>AUTHORS</quote> table and in
	DB2 <quote>ORG</quote> table and check the contents of the tables
	after the transaction execution:
	<table frame="box">
	  <thead><tr><td>[Third terminal session]</td></tr></thead>
	  <tbody><tr><td><screen>
tiian@ubuntu:~/tmp$ . /home/db2inst1/sqllib/db2profile
tiian@ubuntu:~/tmp$ ./example7_pql_db2 insert org
Executing DB2 statement 'INSERT INTO DB2INST1.ORG(DEPTNUMB, DEPTNAME, MANAGER, DIVISION, LOCATION) VALUES(150, 'Europe', 231, 'R&amp;D', 'Mojan')'...
Executing PostgreSQL statement 'INSERT INTO authors VALUES(1, 'Foo', 'Bar');'...	  </screen></td></tr></tbody>
	</table>
	Now you can verify the content of the tables after the transaction:
	<table frame="box">
	  <thead><tr><td>[PostgreSQL terminal session]</td></tr></thead>
	  <tbody><tr><td><screen>
testdb=> select * from authors;
 id | last_name | first_name
----+-----------+------------
  1 | Foo       | Bar
(1 row)
	  </screen></td></tr></tbody>
	</table>
	<table frame="box">
	  <thead><tr><td>[IBM DB2 terminal session]</td></tr></thead>
	  <tbody><tr><td><screen>
db2 => select * from DB2INST1.ORG where DEPTNUMB = 150

DEPTNUMB DEPTNAME       MANAGER DIVISION   LOCATION
-------- -------------- ------- ---------- -------------
     150 Europe             231 R&amp;D        Mojan

  1 record(s) selected.
	  </screen></td></tr></tbody>
	</table>
	If you try to insert the same row again you can verify an automatic
	rollback due to an error thrown by the second resource manager:
	<table frame="box">
	  <thead><tr><td>[Shell terminal session]</td></tr></thead>
	  <tbody><tr><td><screen>
tiian@ubuntu:~/tmp$ ./example7_pql_db2 insert org
Executing DB2 statement 'INSERT INTO DB2INST1.ORG(DEPTNUMB, DEPTNAME, MANAGER, DIVISION, LOCATION) VALUES(150, 'Europe', 231, 'R&amp;D', 'Mojan')'...
Executing PostgreSQL statement 'INSERT INTO authors VALUES(1, 'Foo', 'Bar');'...
PostgreSQL error: ERROR:  duplicate key value violates unique constraint "authors_pkey"
	  </screen></td></tr></tbody>
	</table>
	DB2 table (<quote>ORG</quote>) allows multiple rows, PostgreSQL table
	(<quote>AUTHORS</quote>) does not allow multiple rows: the error stops
	the program execution and the resource managers automatically
	rollback the changes. You can verify there is only one row in the
	tables:
	<table frame="box">
	  <thead><tr><td>[PostgreSQL terminal session]</td></tr></thead>
	  <tbody><tr><td><screen>
testdb=> select * from authors;
 id | last_name | first_name
----+-----------+------------
  1 | Foo       | Bar
(1 row)
	  </screen></td></tr></tbody>
	</table>
	<table frame="box">
	  <thead><tr><td>[IBM DB2 terminal session]</td></tr></thead>
	  <tbody><tr><td><screen>
db2 => select * from DB2INST1.ORG where DEPTNUMB = 150

DEPTNUMB DEPTNAME       MANAGER DIVISION   LOCATION
-------- -------------- ------- ---------- -------------
     150 Europe             231 R&amp;D        Mojan

  1 record(s) selected.
	  </screen></td></tr></tbody>
	</table>
	You can easily verify there are no prepared transactions inside
	PostgreSQL database:
	<table frame="box">
	  <thead><tr><td>[PostgreSQL terminal session]</td></tr></thead>
	  <tbody><tr><td><screen>
testdb=> select * from pg_prepared_xacts;
 transaction | gid | prepared | owner | database
-------------+-----+----------+-------+----------
(0 rows)
	  </screen></td></tr></tbody>
	</table>
	We can verify that DB2 is using dynamic registration:
	<table frame="box">
	  <thead><tr><td>[Shell terminal session]</td></tr></thead>
	  <tbody><tr><td><screen>
tiian@ubuntu:~/tmp$ export LIXA_TRACE_MASK=0x00002000
tiian@ubuntu:~/tmp$ echo $LIXA_TRACE_MASK
0x00002000
tiian@ubuntu:~/tmp$ ./example7_pql_db2 delete org 2>&amp;1 | grep ax_reg
2011-09-25 18:15:38.499702 [13586/3035527472] ax_reg: rmid=1, xid=0xbf9b2630, flags=0x0
2011-09-25 18:15:38.500405 [13586/3035527472] ax_reg: the application program has started a transaction (TX states S3); this XID '1279875137.0565b518222345ba852b4c4a09a660ae.725d0414e912e62f9ef42209ef693f36' will be returned
2011-09-25 18:15:38.500970 [13586/3035527472] ax_reg: sending 153 bytes to the server for step 8
2011-09-25 18:15:38.501415 [13586/3035527472] ax_reg/excp=7/ret_cod=0/errno=0
	  </screen></td></tr></tbody>
	</table>
	If you used <quote>PQL_STA_DB2_STA</quote> profile instead of 
	<quote>PQL_STA_DB2_DYN</quote> you could switch the DB2 to
	static behavior.
      </para>
      <note><para>
	  Combining the previous two examples you can realize a program that
	  access 3 resource managers: PostgreSQL, Oracle and DB2.
	  It is left as an exercise to the reader.
      </para></note>
    </section>
  </section>
  <section xml:id="Development_example8_mys">
    <title>An example with MySQL</title>
    <figure xml:id="develop8">
      <title>Deploy model of an example with MySQL DBMS</title>
      <mediaobject>
	<imageobject>
	  <imagedata fileref="../images/LIXA_Development_8.png"/>
	</imageobject>
      </mediaobject>
    </figure>
    <para>
      This example was developed using MySQL 5.0.51a for Linux (Ubuntu).
      If you were using a different version you would need to adapt some
      commands to your environment.
    </para>
    <note><para>
	If you did not yet installed the software, please refer to the 
	official site for your Linux distribution or to the official site
	of MySQL if your operating system does not distribute the
	software or you want to use a different MySQL version.
	Using Ubuntu Linux this packages are necessary:
	<variablelist>
	  <varlistentry>
	    <term><package>mysql-server</package></term>
	    <listitem><para>
		MySQL server
	    </para></listitem>
	  </varlistentry>	  
	  <varlistentry>
	    <term><package>libmysqlclient15-dev</package></term>
	    <listitem><para>
		MySQL C client development library
	    </para></listitem>
	  </varlistentry>
	</variablelist>
	This manual does not give you information related
	to MySQL: it is assumed you already installed and
	configured the database
	<footnote><para>
	    This is the sample command for Ubuntu 8.04 operating system:
	    <computeroutput>sudo apt-get install mysql-server libmysqlclient15-dev</computeroutput>
	</para></footnote>.
    </para></note>
    <note><para>
	This example uses a client running in the same host used by
	MySQL server: this is not a technical limitation, but a way to
	make it easy. Client/server configuration must work as well: 
	please refer to the database documentation.
    </para></note>
    <important><para>
	The LIXA software must be configured to support the MySQL 
	server resource manager as explained in 
	<xref linkend="Linking_third_party_resource_managers"/>.
    </para></important>
    <section xml:id="Development_setup_MySQL_environment">
      <title>Set-up MySQL environment</title>
      <section>
	<title>Start-up the MySQL server</title>
	<para>
	  If your server didn't start-up automatically at boot time, you
	  could start it with the following commands:
	  <table frame="box">
	    <thead><tr><td>[Shell terminal session]</td></tr></thead>
	    <tbody><tr><td><screen>
tiian@mojan:~$ sudo /etc/init.d/mysql start
 * Starting MySQL database server mysqld                                 [ OK ] 
 * Checking for corrupt, not cleanly closed and upgrade needing tables.
tiian@mojan:~$ ps -ef|grep mysql|grep -v grep
root      7666     1  0 21:52 ?        00:00:26 /bin/sh /usr/bin/mysqld_safe
root      9060     1  0 22:46 pts/1    00:00:00 /bin/sh /usr/bin/mysqld_safe
mysql     9099  9060  1 22:46 pts/1    00:00:00 /usr/sbin/mysqld --basedir=/usr --datadir=/var/lib/mysql --user=mysql --pid-file=/var/run/mysqld/mysqld.pid --skip-external-locking --port=3306 --socket=/var/run/mysqld/mysqld.sock
root      9101  9060  0 22:46 pts/1    00:00:00 logger -p daemon.err -t mysqld_safe -i -t mysqld
	    </screen></td></tr></tbody>
	  </table>
	  Create a new user authorization and a new database
	  <footnote><para>
	      You need the password of MySQL root user to execute
	      these commands
	  </para></footnote>:
	  <table frame="box">
	    <thead><tr><td>[Shell terminal session]</td></tr></thead>
	    <tbody><tr><td><screen>
tiian@ubuntu:~$ mysql -u root -p
Enter password:
Welcome to the MySQL monitor.  Commands end with ; or \g.
Your MySQL connection id is 1
Server version: 5.0.51a-3ubuntu5.8 (Ubuntu)

Type 'help;' or '\h' for help. Type '\c' to clear the buffer.

mysql> GRANT ALL ON lixa.* TO 'lixa'@'localhost';
Query OK, 0 rows affected (0.00 sec)

mysql> CREATE DATABASE lixa;
Query OK, 1 row affected (0.00 sec)

mysql> quit
Bye
	    </screen></td></tr></tbody>
	  </table>
	  The <systemitem class="username">lixa@localhost</systemitem> user
	  has been created with all privileges on the <quote>lixa</quote>
	  database. Now a sample table must be created using this new user:
	  <table frame="box">
	    <thead><tr><td>[Shell terminal session]</td></tr></thead>
	    <tbody><tr><td><screen>
tiian@ubuntu:~$ mysql -h localhost -u lixa lixa
Enter password:
Welcome to the MySQL monitor.  Commands end with ; or \g.
Your MySQL connection id is 3
Server version: 5.0.51a-3ubuntu5.8 (Ubuntu)

Type 'help;' or '\h' for help. Type '\c' to clear the buffer.

mysql> SELECT DATABASE();
+------------+
| DATABASE() |
+------------+
| lixa       |
+------------+
1 row in set (0.01 sec)

mysql> CREATE TABLE authors (id INTEGER NOT NULL PRIMARY KEY, last_name TEXT, first_name TEXT) ENGINE=InnoDB;
Query OK, 0 rows affected (0.02 sec)

mysql> DESCRIBE authors;
+------------+---------+------+-----+---------+-------+
| Field      | Type    | Null | Key | Default | Extra |
+------------+---------+------+-----+---------+-------+
| id         | int(11) | NO   | PRI | NULL    |       |
| last_name  | text    | YES  |     | NULL    |       |
| first_name | text    | YES  |     | NULL    |       |
+------------+---------+------+-----+---------+-------+
3 rows in set (0.00 sec)

mysql> SELECT * FROM authors;
Empty set (0.00 sec)
	    </screen></td></tr></tbody>
	  </table>
	  OK, the <quote>authors</quote> table was created using 
	  the <quote>InnoDB</quote> engine. 
	  If something went wrong, you should refer to MySQL
	  documentation to fix the issue before the next step because
	  you would not be able to execute the sample program without a
	  basic running installation.
	</para>
      </section>
    </section>
    <section>
      <title>Start the LIXA state server</title>
      <para>
	Start the state server as shown below:
	<table frame="box">
	  <thead><tr><td>[Shell terminal session]</td></tr></thead>
	  <tbody><tr><td><screen>
tiian@ubuntu:~$ sudo su - lixa
lixa@ubuntu:~$ /opt/lixa/sbin/lixad --daemon
lixa@ubuntu:~$ exit
logout
tiian@ubuntu:~$ ps -ef|grep lixad|grep -v grep
lixa     12866     1  0 21:35 ?        00:00:00 /opt/lixa/sbin/lixad --daemon
	  </screen></td></tr></tbody>
	</table>
      </para>
    </section>
    <section>
      <title>Build the client program</title>
      <para>
	Prepare the client (Application Program) using the below commands
	(<command>gcc</command> command was splitted on several lines 
	using <command>\</command> to help readability, but you may use
	a single line):
	<table frame="box">
	  <thead><tr><td>[Shell terminal session]</td></tr></thead>
	  <tbody><tr><td><screen>
tiian@ubuntu:~$ mkdir tmp
tiian@ubuntu:~$ cd tmp
tiian@ubuntu:~/tmp$ cp /opt/lixa/share/doc/lixa-X.Y.Z/examples/example8_mys.c .
tiian@ubuntu:~/tmp$ gcc example8_mys.c $(/opt/lixa/bin/lixa-config -c -f -m -d) \
> $(mysql_config --include --libs_r) -o example8_mys

	  </screen></td></tr></tbody>
	</table>
	Verify the executable produced by <command>gcc</command>:
	<table frame="box">
	  <thead><tr><td>[Shell terminal session]</td></tr></thead>
	  <tbody><tr><td><screen>
tiian@ubuntu:~/tmp$ ldd example8_mys
        linux-gate.so.1 =>  (0xb7737000)
        liblixac.so.0 => /opt/lixa/lib/liblixac.so.0 (0xb771c000)
        liblixamy.so.0 => /opt/lixa/lib/liblixamy.so.0 (0xb7714000)
        libmysqlclient_r.so.15 => /usr/lib/libmysqlclient_r.so.15 (0xb7523000)
        libc.so.6 => /lib/tls/i686/cmov/libc.so.6 (0xb73d4000)
        libgmodule-2.0.so.0 => /usr/lib/libgmodule-2.0.so.0 (0xb73d0000)
        libdl.so.2 => /lib/tls/i686/cmov/libdl.so.2 (0xb73cc000)
        libgthread-2.0.so.0 => /usr/lib/libgthread-2.0.so.0 (0xb73c7000)
        librt.so.1 => /lib/tls/i686/cmov/librt.so.1 (0xb73bd000)
        libglib-2.0.so.0 => /usr/lib/libglib-2.0.so.0 (0xb730c000)
        libxml2.so.2 => /usr/lib/libxml2.so.2 (0xb71ec000)
        liblixab.so.0 => /opt/lixa/lib/liblixab.so.0 (0xb71d7000)
        libpthread.so.0 => /lib/tls/i686/cmov/libpthread.so.0 (0xb71bf000)
        libcrypt.so.1 => /lib/tls/i686/cmov/libcrypt.so.1 (0xb718d000)
        libnsl.so.1 => /lib/tls/i686/cmov/libnsl.so.1 (0xb7174000)
        libm.so.6 => /lib/tls/i686/cmov/libm.so.6 (0xb714f000)
        libz.so.1 => /usr/lib/libz.so.1 (0xb713a000)
        /lib/ld-linux.so.2 (0xb7738000)
        libpcre.so.3 => /usr/lib/libpcre.so.3 (0xb7113000)
        libuuid.so.1 => /lib/libuuid.so.1 (0xb710f000)
	  </screen></td></tr></tbody>
	</table>
      </para>
    </section>
    <section>
      <title>Set-up LIXA environment</title>
      <para>
	Set-up the <varname>LIXA_PROFILE</varname> environment variable:
	<table frame="box">
	  <thead><tr><td>[Shell terminal session]</td></tr></thead>
	  <tbody><tr><td><screen>
tiian@ubuntu:~/tmp$ echo $LIXA_PROFILE

tiian@ubuntu:~/tmp$ export LIXA_PROFILE=MYS_STA
tiian@ubuntu:~/tmp$ echo $LIXA_PROFILE
MYS_STA
	  </screen></td></tr></tbody>
	</table>
      </para>
    </section>
    <section xml:id="Development_setup_MySQL_xa_open_info">
      <title>Some checks before program execution</title>
      <para>
	We set <varname>LIXA_PROFILE</varname> to value
	<quote>MYS_STA</quote>, looking at
	<filename>/opt/lixa/etc/lixac_conf.xml</filename>:
	<screen>
    &lt;profile name="MYS_STA"&gt;
      &lt;sttsrvs&gt;
        &lt;sttsrv&gt;local_1&lt;/sttsrv&gt;
      &lt;/sttsrvs&gt;
      &lt;rsrmgrs&gt;
        &lt;rsrmgr&gt;MySQL_stareg&lt;/rsrmgr&gt;
      &lt;/rsrmgrs&gt;
    &lt;/profile&gt;
	</screen>
	the profile references the Resource Manager named
	<quote>MySQL_stareg</quote>, looking again at the config file:
	<screen>
    &lt;rsrmgr name="MySQL_stareg" switch_file="/opt/lixa/lib/switch_mysql_stareg.so" xa_open_info="host=localhost,user=lixa,passwd=,db=lixa,client_flag=0" xa_close_info="" /&gt;
	</screen>
	we can discover how LIXA is configured to access the MySQL database.
	The content of <constant>xa_open_info</constant> is passed to
	<link xlink:href="http://dev.mysql.com/doc/refman/5.0/en/mysql-real-connect.html"><function>mysql_real_connect</function></link>
	function after some parsing has occurred.
	This is the prototype of the <function>mysql_real_connect</function>
	function as described in the official manual
	<funcsynopsis>
	  <funcprototype>
	    <?dbhtml funcsynopsis-style='ANSI'?>
	    <funcdef>MYSQL *<function>mysql_real_connect</function></funcdef>
	    <paramdef>const char *<parameter>host</parameter></paramdef>
	    <paramdef>const char *<parameter>passwd</parameter></paramdef>
	    <paramdef>const char *<parameter>db</parameter></paramdef>
	    <paramdef>unsigned int <parameter>port</parameter></paramdef>
	    <paramdef>const char *<parameter>unix_socket</parameter></paramdef>
	    <paramdef>unsigned long <parameter>client_flag</parameter></paramdef>
	  </funcprototype>
	</funcsynopsis>
	and these are the tokens accepted by LIXA inside 
	<constant>xa_open_info</constant>:
	<itemizedlist mark='bullet'>
	  <listitem><para>
	      <parameter>host</parameter>: a string of characters
	  </para></listitem>
	  <listitem><para>
	      <parameter>user</parameter>: a string of characters
	  </para></listitem>
	  <listitem><para>
	      <parameter>passwd</parameter>: a string of characters
	  </para></listitem>
	  <listitem><para>
	      <parameter>db</parameter>: a string of characters
	  </para></listitem>
	  <listitem><para>
	      <parameter>port</parameter>: a number
	  </para></listitem>
	  <listitem><para>
	      <parameter>unix_socket</parameter>: a string of characters
	  </para></listitem>
	  <listitem><para>
	      <parameter>client_flag</parameter>: a number
	  </para></listitem>
	</itemizedlist>
	As shown in the above example, this is the syntax that applies to
	<constant>xa_open_info</constant>:
	<orderedlist numeration="arabic">
	  <listitem><para>
	      an element is composed by
	      <token>&lt;token&gt;</token>=<token>&lt;value&gt;</token> where 
	      <token>&lt;token&gt;</token> is one of the keywords listed above
	  </para></listitem>
	  <listitem><para>
	      a comma <quote>,</quote> separates two elements 
	  </para></listitem>
	  <listitem><para>
	      <token>&lt;value&gt;</token> may be empty 
	      (like <constant>passwd</constant> 
	      in the above example): it will passed as an empty string ("")
	      to <function>mysql_real_connect</function>
	  </para></listitem>
	  <listitem><para>
	      if a <token>&lt;token&gt;</token> is not specified in 
	      <constant>xa_open_info</constant>, LIXA will pass to 
	      <function>mysql_real_connect</function> a NULL pointer if the
	      missing token refers to a character string and 0 value if the
	      missing token refers to a number
	  </para></listitem>
	  <listitem><para>
	      if you must put an equal symbol ("=") inside 
	      <token>&lt;value&gt;</token>
	      you must put two instead of one: "=="
	  </para></listitem>
	  <listitem><para>
	      if you must put a comma symbol (",") inside 
	      <token>&lt;value&gt;</token>
	      you must put two instead of one: ",,"
	  </para></listitem>
	  <listitem><para>
	      all control characters like space, tab, newline and so on, are
	      passed as is without any modification
	  </para></listitem>
	</orderedlist>
	Using this configuration:
	<constant>xa_open_info="host=localhost,user=lixa,passwd=,db=lixa,client_flag=0"</constant>
	LIXA will call <function>mysql_real_connect</function> as
      </para>
      <para>
	<function>mysql_real_connect</function>(<parameter>conn</parameter>,
	<parameter>"localhost"</parameter>, <parameter>"lixa"</parameter>,
	<parameter>""</parameter>, <parameter>"lixa"</parameter>,
	<parameter>0</parameter>, <parameter>NULL</parameter>,
	<parameter>0</parameter>)
      </para>
      <para>
	You should refer to MySQL official documentation to discover how you
	can configure <constant>xa_open_info</constant>.
	<warning><para>
	    <constant>xa_open_info</constant> can contain a maximum of 255
	    characters (plus \0 string terminator); if you need more space,
	    consider to move some parameters to <filename>mycnf</filename> file
	    (see MySQL official documentation to pick-up the details).
	</para></warning>
      </para>
    </section>
    <section>
      <title>Program execution</title>
      <para>
	It is suggested to open two different terminals: the first one
	connected to <quote>lixa</quote> MySQL database and the second
	one pointing to the directory where the compiled program
	<filename>example8_mys</filename> lives.
	First teminal session:
	<table frame="box">
	  <thead><tr><td>[MySQL terminal session]</td></tr></thead>
	  <tbody><tr><td><screen>
tiian@ubuntu:~$ mysql -h localhost -u lixa lixa
Reading table information for completion of table and column names
You can turn off this feature to get a quicker startup with -A

Welcome to the MySQL monitor.  Commands end with ; or \g.
Your MySQL connection id is 7
Server version: 5.0.51a-3ubuntu5.8 (Ubuntu)

Type 'help;' or '\h' for help. Type '\c' to clear the buffer.

mysql>
	  </screen></td></tr></tbody>
	</table>
	Second teminal session:
	<table frame="box">
	  <thead><tr><td>[Shell terminal session]</td></tr></thead>
	  <tbody><tr><td><screen>
tiian@ubuntu:~/tmp$ ls -la
total 21
drwxr-xr-x   2 tiian tiian  112 2011-09-14 21:14 .
drwxrwx--x 101 tiian tiian 5064 2011-09-14 21:13 ..
-rwxr-xr-x  1 tiian tiian  8828 2011-11-02 15:01 example8_mys
-rw-r--r--  1 tiian tiian  3174 2011-11-02 15:00 example8_mys.c
	  </screen></td></tr></tbody>
	</table>
	Check the content of <quote>authors</quote> table before
	program execution:
	<table frame="box">
	  <thead><tr><td>[MySQL terminal session]</td></tr></thead>
	  <tbody><tr><td><screen>
mysql> SELECT * FROM authors;
Empty set (0.04 sec)
	  </screen></td></tr></tbody>
	</table>
	Execute the program:
	<table frame="box">
	  <thead><tr><td>[Shell terminal session]</td></tr></thead>
	  <tbody><tr><td><screen>
tiian@ubuntu:~/tmp$ ./example8_mys insert
Inserting a row in the table...
	  </screen></td></tr></tbody>
	</table>
	Check the content of the table again:
	<table frame="box">
	  <thead><tr><td>[MySQL terminal session]</td></tr></thead>
	  <tbody><tr><td><screen>
mysql> SELECT * FROM authors;
+----+-----------+------------+
| id | last_name | first_name |
+----+-----------+------------+
|  1 | Foo       | Bar        |
+----+-----------+------------+
1 row in set (0.00 sec)
	  </screen></td></tr></tbody>
	</table>
	The example program inserted the row with id=1. You can not insert
	the same row twice because there is a unique constraint on this table,
	but you can remove the row using
	<table frame="box">
	  <thead><tr><td>[Shell terminal session]</td></tr></thead>
	  <tbody><tr><td><screen>
tiian@ubuntu:~/tmp$ ./example8_mys delete
Deleting a row from the table...
	  </screen></td></tr></tbody>
	</table>
	Check the table content again:
	<table frame="box">
	  <thead><tr><td>[MySQL terminal session]</td></tr></thead>
	  <tbody><tr><td><screen>
mysql> SELECT * FROM authors;
Empty set (0.00 sec)
	  </screen></td></tr></tbody>
	</table>
	you can verify in file
	<filename>/opt/lixa/etc/lixac_conf.xml</filename>
	that <quote>MYS_STA</quote> is associated to static registration
	<footnote><para>
	    The current implementation does not support dynamic registration
	    for MySQL.
	</para></footnote>
	.
	Execute the program:
	<table frame="box">
	  <thead><tr><td>[Shell terminal session]</td></tr></thead>
	  <tbody><tr><td><screen>
tiian@ubuntu:~/tmp$ export LIXA_TRACE_MASK=0x00002000
tiian@ubuntu:~/tmp$ echo $LIXA_TRACE_MASK
0x00002000
tiian@ubuntu:~/tmp$ ./example8_mys insert 2>&amp;1 | grep xa_start
2011-11-02 22:10:45.425495 [25927/3069150960] lixa_xa_start
[...]
2011-11-02 22:10:45.473079 [25927/3069150960] lixa_xa_start: xa_start_entry(xid, 0, 0x0) = 0
2011-11-02 22:10:45.473633 [25927/3069150960] lixa_xa_start: sending 210 bytes to the server for step 24
2011-11-02 22:10:45.474534 [25927/3069150960] lixa_xa_start/excp=10/ret_cod=0/errno=0
	  </screen></td></tr></tbody>
	</table>
	Finally, clean up the table again:
	<table frame="box">
	  <thead><tr><td>[Shell terminal session]</td></tr></thead>
	  <tbody><tr><td><screen>
tiian@ubuntu:~/tmp$ unset LIXA_TRACE_MASK
tiian@ubuntu:~/tmp$ ./example8_mys delete
Deleting a row from the table...
	  </screen></td></tr></tbody>
	</table>
      </para>
    </section>
  </section>
  <section xml:id="Development_example9_mys_pql">
    <title>An example with MySQL &amp; PostgreSQL</title>
    <figure xml:id="develop9">
      <title>Deploy model of an example showing a distributed transaction with
	MySQL and PostgreSQL</title>
      <mediaobject>
	<imageobject>
	  <imagedata fileref="../images/LIXA_Development_9.png"/>
	</imageobject>
      </mediaobject>
    </figure>
    <para>
      This example shows as
      you can implement DTP (Distributed Transaction Processing) with two
      Resource Managers (MySQL and PostgreSQL)
      coordinated by the LIXA Transaction Manager.
      It's strongly suggested you have played with the
      examples previously shown in this chapter (see
      <xref linkend="Development"/>) before starting this more complex one.
    </para>
    <note>
      <para>
	If you did not yet installed the software provided by PostgreSQL,
	please refer to the official PostgreSQL site to download the
	software and to pick-up the information necessary to install 
	and configure
	the database. This manual does not give you information related
	to PostgreSQL technology: it is assumed you already installed and
	configured the database.
      </para>
      <para>
	If you did not yet installed the software provided by MySQL,
	please refer to the official MySQL site to download the
	software and to pick-up the information necessary to install 
	and configure
	the database. This manual does not give you information related
	to MySQL technology: it is assumed you already installed and
	configured the database.
      </para>
    </note>
    <important>
      <para>
	The LIXA software must be configured to support the MySQL and 
	PostgreSQL and resource managers as explained in 
	<xref linkend="Linking_third_party_resource_managers"/>.
	As a little hint, you should configure LIXA as below (Ubuntu):
	<screen>
./configure --with-mysql \
> --with-postgresql-include=/usr/include/postgresql --with-postgresql-lib=/usr/lib
	</screen>
	or as below (Centos):
	<screen>
./configure --with-mysql \
> --with-postgresql-include=/usr/include/postgresql --with-postgresql-lib=/usr/lib
	</screen>
	Please don't forget you must compile and install every time you
	re-configure.
      </para>
    </important>
    <para>
      Please follow the instructions explained 
      <itemizedlist mark="bullet">
	<listitem><para>
	    in <xref linkend="Development_setup_MySQL_environment"/>
	    to set-up a running environment for MySQL server
	</para></listitem>
	<listitem><para>
	    in <xref linkend="Development_setup_PostgreSQL_environment"/>
	    to set-up a running environment for PostgreSQL server
	</para></listitem>
	<listitem><para>
	    in <xref linkend="Development_start_LIXA_server"/>
	    to start up the LIXA state server
	</para></listitem>
      </itemizedlist>
    </para>
    <section>
      <title>Build the client program</title>
      <para>
	Prepare the client (Application Program) using the below commands
	(<command>gcc</command> command was splitted on several lines 
	using <command>\</command> to help readability, but you may use
	a single line):
	<table frame="box">
	  <thead><tr><td>[Shell terminal session]</td></tr></thead>
	  <tbody><tr><td><screen>
tiian@ubuntu:~$ mkdir tmp
tiian@ubuntu:~$ cd tmp
tiian@ubuntu:~/tmp$ cp /opt/lixa/share/doc/lixa-X.Y.Z/examples/example9_mys_pql.c .
tiian@ubuntu:~/tmp$ gcc example9_mys_pql.c $(/opt/lixa/bin/lixa-config -c -f -m -p -d) \
> $(mysql_config --include --libs_r) -I/usr/include/postgresql -lpq \
> -o example9_mys_pql
	  </screen></td></tr></tbody>
	</table>
	Verify the executable produced by <command>gcc</command>:
	<table frame="box">
	  <thead><tr><td>[Shell terminal session]</td></tr></thead>
	  <tbody><tr><td><screen>
tiian@ubuntu:~/tmp$ ldd example9_mys_pql
        linux-gate.so.1 =>  (0xb76f6000)
        liblixac.so.0 => /opt/lixa/lib/liblixac.so.0 (0xb76db000)
        liblixamy.so.0 => /opt/lixa/lib/liblixamy.so.0 (0xb76d3000)
        liblixapq.so.0 => /opt/lixa/lib/liblixapq.so.0 (0xb76cb000)
        libmysqlclient_r.so.15 => /usr/lib/libmysqlclient_r.so.15 (0xb74db000)
        libpq.so.5 => /usr/lib/libpq.so.5 (0xb74bc000)
        libc.so.6 => /lib/tls/i686/cmov/libc.so.6 (0xb736d000)
        libgmodule-2.0.so.0 => /usr/lib/libgmodule-2.0.so.0 (0xb7369000)
        libdl.so.2 => /lib/tls/i686/cmov/libdl.so.2 (0xb7365000)
        libgthread-2.0.so.0 => /usr/lib/libgthread-2.0.so.0 (0xb735f000)
        librt.so.1 => /lib/tls/i686/cmov/librt.so.1 (0xb7356000)
        libglib-2.0.so.0 => /usr/lib/libglib-2.0.so.0 (0xb72a5000)
        libxml2.so.2 => /usr/lib/libxml2.so.2 (0xb7185000)
        liblixab.so.0 => /opt/lixa/lib/liblixab.so.0 (0xb7170000)
        libpthread.so.0 => /lib/tls/i686/cmov/libpthread.so.0 (0xb7157000)
        libcrypt.so.1 => /lib/tls/i686/cmov/libcrypt.so.1 (0xb7125000)
        libnsl.so.1 => /lib/tls/i686/cmov/libnsl.so.1 (0xb710d000)
        libm.so.6 => /lib/tls/i686/cmov/libm.so.6 (0xb70e8000)
        libz.so.1 => /usr/lib/libz.so.1 (0xb70d3000)
        libssl.so.0.9.8 => /usr/lib/i686/cmov/libssl.so.0.9.8 (0xb708e000)
        libcrypto.so.0.9.8 => /usr/lib/i686/cmov/libcrypto.so.0.9.8 (0xb6f4b000)
        libkrb5.so.3 => /usr/lib/libkrb5.so.3 (0xb6ebe000)
        libcom_err.so.2 => /lib/libcom_err.so.2 (0xb6ebb000)
        libgssapi_krb5.so.2 => /usr/lib/libgssapi_krb5.so.2 (0xb6e92000)
        libldap_r-2.4.so.2 => /usr/lib/libldap_r-2.4.so.2 (0xb6e52000)
        /lib/ld-linux.so.2 (0xb76f7000)
        libpcre.so.3 => /usr/lib/libpcre.so.3 (0xb6e2a000)
        libuuid.so.1 => /lib/libuuid.so.1 (0xb6e26000)
        libk5crypto.so.3 => /usr/lib/libk5crypto.so.3 (0xb6e03000)
        libkrb5support.so.0 => /usr/lib/libkrb5support.so.0 (0xb6dfb000)
        libkeyutils.so.1 => /lib/libkeyutils.so.1 (0xb6df8000)
        libresolv.so.2 => /lib/tls/i686/cmov/libresolv.so.2 (0xb6de4000)
        liblber-2.4.so.2 => /usr/lib/liblber-2.4.so.2 (0xb6dd7000)
        libsasl2.so.2 => /usr/lib/libsasl2.so.2 (0xb6dc0000)
        libgnutls.so.13 => /usr/lib/libgnutls.so.13 (0xb6d4a000)
        libtasn1.so.3 => /usr/lib/libtasn1.so.3 (0xb6d3a000)
        libgcrypt.so.11 => /lib/libgcrypt.so.11 (0xb6cec000)
        libgpg-error.so.0 => /lib/libgpg-error.so.0 (0xb6ce8000)
	  </screen></td></tr></tbody>
	</table>
      </para>
    </section>
    <section>
      <title>Set-up LIXA environment</title>
      <para>
	Set-up the necessary environment variables:
	<table frame="box">
	  <thead><tr><td>[Shell terminal session]</td></tr></thead>
	  <tbody><tr><td><screen>
tiian@ubuntu:~/tmp$ echo $LIXA_PROFILE

tiian@ubuntu:~/tmp$ export LIXA_PROFILE=MYS_STA_PQL_STA
tiian@ubuntu:~/tmp$ echo $LIXA_PROFILE
MYS_STA_PQL_STA
	  </screen></td></tr></tbody>
	</table>
	It is suggested to set the necessary environment variable
	(<varname>LIXA_PROFILE</varname>) in your 
	profile if you are going to execute the programs many times.
      </para>
    </section>
    <section>
      <title>Some checks before program execution</title>
      <para>
	We set <varname>LIXA_PROFILE</varname> to value
	<quote>MYS_STA_PQL_STA</quote>, looking at
	<filename>/opt/lixa/etc/lixac_conf.xml</filename>:
	<screen>
    &lt;profile name="MYS_STA_PQL_STA"&gt;
      &lt;sttsrvs&gt;
        &lt;sttsrv&gt;local_1&lt;/sttsrv&gt;
      &lt;/sttsrvs&gt;
      &lt;rsrmgrs&gt;
        &lt;rsrmgr&gt;MySQL_stareg&lt;/rsrmgr&gt;
        &lt;rsrmgr&gt;PostgreSQL_stareg&lt;/rsrmgr&gt;
      &lt;/rsrmgrs&gt;
    &lt;/profile&gt;
	</screen>
	the profile references two Resource Managers:
	<quote>MySQL_stareg</quote> and <quote>PostgreSQL_stareg</quote>, 
	looking again at the config file:
	<screen>
    &lt;rsrmgr name="MySQL_stareg" switch_file="/opt/lixa/lib/switch_mysql_stareg.so" xa_open_info="host=localhost,user=lixa,passwd=,db=lixa,client_flag=0" xa_close_info="" /&gt;
    &lt;rsrmgr name="PostgreSQL_stareg" switch_file="/opt/lixa/lib/switch_postgresql_stareg.so" xa_open_info="dbname=testdb" xa_close_info="" /&gt;
	</screen>
	we can discover how our application will access the resource
	managers
	<footnote>
	  <para>
	    The content of <constant>xa_open_info</constant> for MySQL is
	    described in 
	    <xref linkend="Development_setup_MySQL_xa_open_info"/>.
	  </para>
	</footnote>
	<footnote>
	  <para>
	    The content of <constant>xa_open_info</constant> is passed to
	    <function>PQconnectdb</function> function: you can refer to 
	    PostgreSQL official
	    documentation to discover what you can pass to this function.
	    Please pay attention the <varname>xa_open_info</varname> can
	    contain a maximum of 255 characters: this limitation is
	    documented in <citation>XAspec</citation>.
	  </para>
	</footnote>.
      </para>
    </section>
    <section>
      <title>Program execution</title>
      <para>
	It is suggested to open three different terminals: 
	the first one connected to <quote>lixa</quote> MySQL database,
	the second one connected to <quote>testdb</quote> PostgreSQL database
	and the
	third one pointing to the directory where the compiled program 
	example9_mys_pql lives.
	<table frame="box">
	  <thead><tr><td>[MySQL terminal session]</td></tr></thead>
	  <tbody><tr><td><screen>
tiian@ubuntu:~$ mysql -h localhost -u lixa lixa
Reading table information for completion of table and column names
You can turn off this feature to get a quicker startup with -A

Welcome to the MySQL monitor.  Commands end with ; or \g.
Your MySQL connection id is 37
Server version: 5.0.51a-3ubuntu5.8 (Ubuntu)

Type 'help;' or '\h' for help. Type '\c' to clear the buffer.

mysql>
	  </screen></td></tr></tbody>
	</table>
	<table frame="box">
	  <thead><tr><td>[PostgreSQL terminal session]</td></tr></thead>
	  <tbody><tr><td><screen>
tiian@ubuntu:~$ psql testdb
Welcome to psql 8.3.15, the PostgreSQL interactive terminal.

Type:  \copyright for distribution terms
       \h for help with SQL commands
       \? for help with psql commands
       \g or terminate with semicolon to execute query
       \q to quit

testdb=>
	  </screen></td></tr></tbody>
	</table>
	<table frame="box">
	  <thead><tr><td>[Shell terminal session]</td></tr></thead>
	  <tbody><tr><td><screen>
tiian@ubuntu:~/tmp$ ls -la
total 28
drwxr-xr-x  2 tiian tiian  4096 2011-09-20 21:53 .
drwxr-xr-x 40 tiian tiian  4096 2011-09-19 20:54 ..
-rwxr-xr-x  1 tiian tiian 10096 2011-11-03 20:45 example9_mys_pql
-rw-r--r--  1 tiian tiian  4602 2011-11-03 20:45 example9_mys_pql.c
	  </screen></td></tr></tbody>
	</table>
	Check the content of the MySQL table (<quote>authors</quote>):
	<table frame="box">
	  <thead><tr><td>[MySQL terminal session]</td></tr></thead>
	  <tbody><tr><td><screen>
mysql> SELECT * FROM authors;
Empty set (0.02 sec)
	  </screen></td></tr></tbody>
	</table>
	Check the content of the PostgreSQL table (<quote>AUTHORS</quote>):
	<table frame="box">
	  <thead><tr><td>[PostgreSQL terminal session]</td></tr></thead>
	  <tbody><tr><td><screen>
testdb=> select * from AUTHORS;
 id | last_name | first_name
----+-----------+------------
(0 rows)
	  </screen></td></tr></tbody>
	</table>
	Insert a row in all the tables and check the contents of the tables
	after the transaction execution:
	<table frame="box">
	  <thead><tr><td>[Third terminal session]</td></tr></thead>
	  <tbody><tr><td><screen>
tiian@ubuntu:~/tmp$ ./example9_mys_pql insert
Inserting a row in MySQL table...
Inserting a row in PostgreSQL table...
	  </screen></td></tr></tbody>
	</table>
	Now you can verify the content of the tables after the transaction:
	<table frame="box">
	  <thead><tr><td>[MySQL terminal session]</td></tr></thead>
	  <tbody><tr><td><screen>
mysql> SELECT * FROM authors;
+----+-----------+------------+
| id | last_name | first_name |
+----+-----------+------------+
|  1 | Foo       | Bar        |
+----+-----------+------------+
1 row in set (0.00 sec)
	  </screen></td></tr></tbody>
	</table>
	<table frame="box">
	  <thead><tr><td>[PostgreSQL terminal session]</td></tr></thead>
	  <tbody><tr><td><screen>
testdb=> select * from AUTHORS;
 id | last_name | first_name
----+-----------+------------
  1 | Foo       | Bar
(1 row)
	  </screen></td></tr></tbody>
	</table>
	With the opposite command you can remove the rows from the tables:
	<table frame="box">
	  <thead><tr><td>[Shell terminal session]</td></tr></thead>
	  <tbody><tr><td><screen>
tiian@ubuntu:~/tmp$ ./example9_mys_pql delete
Deleting a row from MySQL  table...
Deleting a row from PostgreSQL table...
	  </screen></td></tr></tbody>
	</table>
	and check the content of the tables again:
	<table frame="box">
	  <thead><tr><td>[MySQL terminal session]</td></tr></thead>
	  <tbody><tr><td><screen>
mysql> SELECT * FROM authors;
Empty set (0.00 sec)
	  </screen></td></tr></tbody>
	</table>
	<table frame="box">
	  <thead><tr><td>[PostgreSQL terminal session]</td></tr></thead>
	  <tbody><tr><td><screen>
testdb=> select * from AUTHORS;
 id | last_name | first_name
----+-----------+------------
(0 rows)
	  </screen></td></tr></tbody>
	</table>
      </para>
    </section>
  </section>
  <section xml:id="Development_example10_mys_pql_ora">
    <title>An example with MySQL, PostgreSQL &amp; Oracle</title>
    <figure xml:id="develop10">
      <title>Deploy model of an example showing a distributed transaction with
	MySQL, PostgreSQL and Oracle</title>
      <mediaobject>
	<imageobject>
	  <imagedata fileref="../images/LIXA_Development_10.png"/>
	</imageobject>
      </mediaobject>
    </figure>
    <para>
      This example shows as
      you can implement DTP (Distributed Transaction Processing) with three
      Resource Managers (MySQL, PostgreSQL and Oracle)
      coordinated by the LIXA Transaction Manager.
      It's strongly suggested you have played with the
      examples previously shown in this chapter (see
      <xref linkend="Development"/>) before starting this more complex one.
    </para>
    <note>
      <para>
	If you did not yet installed the software provided by MySQL,
	please refer to the official MySQL site to download the
	software and to pick-up the information necessary to install 
	and configure
	the database. This manual does not give you information related
	to MySQL technology: it is assumed you already installed and
	configured the database.
      </para>
      <para>
	If you did not yet installed the software provided by PostgreSQL,
	please refer to the official PostgreSQL site to download the
	software and to pick-up the information necessary to install 
	and configure
	the database. This manual does not give you information related
	to PostgreSQL technology: it is assumed you already installed and
	configured the database.
      </para>
      <para>
	If you did not yet installed the software provided by Oracle,
	please refer to the official Oracle site to download the
	software and to pick-up the information necessary to install 
	and configure
	the database. This manual does not give you information related
	to Oracle technology: it is assumed you already installed and
	configured the database.
      </para>
    </note>
    <important>
      <para>
	The LIXA software must be configured to support the MySQL, 
	PostgreSQL and Oracle resource managers as explained in 
	<xref linkend="Linking_third_party_resource_managers"/>.
	As a little hint, you should configure LIXA as below:
	<screen>
./configure --with-mysql \
> --with-postgresql-include=/usr/include/postgresql --with-postgresql-lib=/usr/lib \
> --with-oracle=/usr/lib/oracle/xe/app/oracle/product/10.2.0/server
	</screen>
	Please don't forget you must compile and install every time you
	re-configure.
      </para>
    </important>
    <para>
      Please follow the instructions explained 
      <itemizedlist mark="bullet">
	<listitem><para>
	    in <xref linkend="Development_setup_MySQL_environment"/>
	    to set-up a running environment for MySQL server
	</para></listitem>
	<listitem><para>
	    in <xref linkend="Development_setup_PostgreSQL_environment"/>
	    to set-up a running environment for PostgreSQL server
	</para></listitem>
	<listitem><para>
	    in <xref linkend="Development_setup_Oracle_environment"/>
	    to set-up a running environment for Oracle Database Server
	</para></listitem>
	<listitem><para>
	    in <xref linkend="Development_start_LIXA_server"/>
	    to start up the LIXA state server
	</para></listitem>
      </itemizedlist>
    </para>
    <section>
      <title>Build the client program</title>
      <para>
	Prepare the client (Application Program) using the below commands
	(<command>gcc</command> command was splitted on several lines 
	using <command>\</command> to help readability, but you may use
	a single line):
	<table frame="box">
	  <thead><tr><td>[Shell terminal session]</td></tr></thead>
	  <tbody><tr><td><screen>
tiian@ubuntu:~$ mkdir tmp
tiian@ubuntu:~$ cd tmp
tiian@ubuntu:~/tmp$ cp /opt/lixa/share/doc/lixa-X.Y.Z/examples/example10_mys_pql_ora.c .
tiian@ubuntu:~/tmp$ gcc example10_mys_pql_ora.c $(/opt/lixa/bin/lixa-config -c -f -m -p -d) \
> $(mysql_config --include --libs_r) -I/usr/include/postgresql -lpq \
> -I/usr/lib/oracle/xe/app/oracle/product/10.2.0/server/rdbms/public \
> -L/usr/lib/oracle/xe/app/oracle/product/10.2.0/server/lib -lclntsh -lnnz10 \  > -o example10_mys_pql_ora
	  </screen></td></tr></tbody>
	</table>
	Verify the executable produced by <command>gcc</command>:
	<table frame="box">
	  <thead><tr><td>[Shell terminal session]</td></tr></thead>
	  <tbody><tr><td><screen>
tiian@ubuntu:~/tmp$ ldd example10_mys_pql_ora
        linux-gate.so.1 =>  (0xb774b000)
        liblixac.so.0 => /opt/lixa/lib/liblixac.so.0 (0xb7730000)
        liblixapq.so.0 => /opt/lixa/lib/liblixapq.so.0 (0xb7729000)
        liblixamy.so.0 => /opt/lixa/lib/liblixamy.so.0 (0xb7720000)
        libmysqlclient_r.so.15 => /usr/lib/libmysqlclient_r.so.15 (0xb7530000)
        libpq.so.5 => /usr/lib/libpq.so.5 (0xb7511000)
        libclntsh.so.10.1 => not found
        libnnz10.so => not found
        libc.so.6 => /lib/tls/i686/cmov/libc.so.6 (0xb73c1000)
        libgmodule-2.0.so.0 => /usr/lib/libgmodule-2.0.so.0 (0xb73bd000)
        libdl.so.2 => /lib/tls/i686/cmov/libdl.so.2 (0xb73b9000)
        libgthread-2.0.so.0 => /usr/lib/libgthread-2.0.so.0 (0xb73b4000)
        librt.so.1 => /lib/tls/i686/cmov/librt.so.1 (0xb73ab000)
        libglib-2.0.so.0 => /usr/lib/libglib-2.0.so.0 (0xb72fa000)
        libxml2.so.2 => /usr/lib/libxml2.so.2 (0xb71d9000)
        liblixab.so.0 => /opt/lixa/lib/liblixab.so.0 (0xb71c4000)
        libm.so.6 => /lib/tls/i686/cmov/libm.so.6 (0xb719f000)
        libpthread.so.0 => /lib/tls/i686/cmov/libpthread.so.0 (0xb7187000)
        libcrypt.so.1 => /lib/tls/i686/cmov/libcrypt.so.1 (0xb7155000)
        libnsl.so.1 => /lib/tls/i686/cmov/libnsl.so.1 (0xb713c000)
        libz.so.1 => /usr/lib/libz.so.1 (0xb7127000)
        libssl.so.0.9.8 => /usr/lib/i686/cmov/libssl.so.0.9.8 (0xb70e1000)
        libcrypto.so.0.9.8 => /usr/lib/i686/cmov/libcrypto.so.0.9.8 (0xb6f9f000)
        libkrb5.so.3 => /usr/lib/libkrb5.so.3 (0xb6f12000)
        libcom_err.so.2 => /lib/libcom_err.so.2 (0xb6f0e000)
        libgssapi_krb5.so.2 => /usr/lib/libgssapi_krb5.so.2 (0xb6ee5000)
        libldap_r-2.4.so.2 => /usr/lib/libldap_r-2.4.so.2 (0xb6ea5000)
        /lib/ld-linux.so.2 (0xb774c000)
        libpcre.so.3 => /usr/lib/libpcre.so.3 (0xb6e7e000)
        libuuid.so.1 => /lib/libuuid.so.1 (0xb6e7a000)
        libk5crypto.so.3 => /usr/lib/libk5crypto.so.3 (0xb6e56000)
        libkrb5support.so.0 => /usr/lib/libkrb5support.so.0 (0xb6e4e000)
        libkeyutils.so.1 => /lib/libkeyutils.so.1 (0xb6e4b000)
        libresolv.so.2 => /lib/tls/i686/cmov/libresolv.so.2 (0xb6e38000)
        liblber-2.4.so.2 => /usr/lib/liblber-2.4.so.2 (0xb6e2b000)
        libsasl2.so.2 => /usr/lib/libsasl2.so.2 (0xb6e13000)
        libgnutls.so.13 => /usr/lib/libgnutls.so.13 (0xb6d9d000)
        libtasn1.so.3 => /usr/lib/libtasn1.so.3 (0xb6d8d000)
        libgcrypt.so.11 => /lib/libgcrypt.so.11 (0xb6d40000)
        libgpg-error.so.0 => /lib/libgpg-error.so.0 (0xb6d3c000)
	  </screen></td></tr></tbody>
	</table>
      </para>
    </section>
    <section>
      <title>Set-up LIXA environment</title>
      <para>
	There are five unresolved references that can be fixed setting up
	the environment properly:
	<table frame="box">
	  <thead><tr><td>[Shell terminal session]</td></tr></thead>
	  <tbody><tr><td><screen>
tiian@ubuntu:~/tmp$ echo $LD_LIBRARY_PATH

tiian@ubuntu:~/tmp$ . /usr/lib/oracle/xe/app/oracle/product/10.2.0/server/bin/oracle_env.sh
tiian@ubuntu:~/tmp$ echo $LD_LIBRARY_PATH
/usr/lib/oracle/xe/app/oracle/product/10.2.0/server/lib:
	  </screen></td></tr></tbody>
	</table>
	Check again the executable:
	<table frame="box">
	  <thead><tr><td>[Shell terminal session]</td></tr></thead>
	  <tbody><tr><td><screen>
tiian@ubuntu:~/tmp$ ldd example10_mys_pql_ora                                           linux-gate.so.1 =>  (0xb77c3000)
        liblixac.so.0 => /opt/lixa/lib/liblixac.so.0 (0xb77a8000)
        liblixapq.so.0 => /opt/lixa/lib/liblixapq.so.0 (0xb77a1000)
        liblixamy.so.0 => /opt/lixa/lib/liblixamy.so.0 (0xb7798000)
        libmysqlclient_r.so.15 => /usr/lib/libmysqlclient_r.so.15 (0xb75a8000)
        libpq.so.5 => /usr/lib/libpq.so.5 (0xb7589000)
        libclntsh.so.10.1 => /usr/lib/oracle/xe/app/oracle/product/10.2.0/server/lib/libclntsh.so.10.1 (0xb67d5000)
        libnnz10.so => /usr/lib/oracle/xe/app/oracle/product/10.2.0/server/lib/libnnz10.so (0xb65d0000)
        libc.so.6 => /lib/tls/i686/cmov/libc.so.6 (0xb6480000)
        libgmodule-2.0.so.0 => /usr/lib/libgmodule-2.0.so.0 (0xb647c000)
        libdl.so.2 => /lib/tls/i686/cmov/libdl.so.2 (0xb6478000)
        libgthread-2.0.so.0 => /usr/lib/libgthread-2.0.so.0 (0xb6473000)
        librt.so.1 => /lib/tls/i686/cmov/librt.so.1 (0xb646a000)
        libglib-2.0.so.0 => /usr/lib/libglib-2.0.so.0 (0xb63b9000)
        libxml2.so.2 => /usr/lib/libxml2.so.2 (0xb6298000)
        liblixab.so.0 => /opt/lixa/lib/liblixab.so.0 (0xb6283000)
        libm.so.6 => /lib/tls/i686/cmov/libm.so.6 (0xb625e000)
        libpthread.so.0 => /lib/tls/i686/cmov/libpthread.so.0 (0xb6246000)
        libcrypt.so.1 => /lib/tls/i686/cmov/libcrypt.so.1 (0xb6214000)
        libnsl.so.1 => /lib/tls/i686/cmov/libnsl.so.1 (0xb61fb000)
        libz.so.1 => /usr/lib/libz.so.1 (0xb61e6000)
        libssl.so.0.9.8 => /usr/lib/i686/cmov/libssl.so.0.9.8 (0xb61a0000)
        libcrypto.so.0.9.8 => /usr/lib/i686/cmov/libcrypto.so.0.9.8 (0xb605e000)
        libkrb5.so.3 => /usr/lib/libkrb5.so.3 (0xb5fd1000)
        libcom_err.so.2 => /lib/libcom_err.so.2 (0xb5fcd000)
        libgssapi_krb5.so.2 => /usr/lib/libgssapi_krb5.so.2 (0xb5fa4000)
        libldap_r-2.4.so.2 => /usr/lib/libldap_r-2.4.so.2 (0xb5f64000)
        /lib/ld-linux.so.2 (0xb77c4000)
        libpcre.so.3 => /usr/lib/libpcre.so.3 (0xb5f3d000)
        libuuid.so.1 => /lib/libuuid.so.1 (0xb5f39000)
        libk5crypto.so.3 => /usr/lib/libk5crypto.so.3 (0xb5f15000)
        libkrb5support.so.0 => /usr/lib/libkrb5support.so.0 (0xb5f0d000)
        libkeyutils.so.1 => /lib/libkeyutils.so.1 (0xb5f0a000)
        libresolv.so.2 => /lib/tls/i686/cmov/libresolv.so.2 (0xb5ef7000)
        liblber-2.4.so.2 => /usr/lib/liblber-2.4.so.2 (0xb5eea000)
        libsasl2.so.2 => /usr/lib/libsasl2.so.2 (0xb5ed2000)
        libgnutls.so.13 => /usr/lib/libgnutls.so.13 (0xb5e5c000)
        libtasn1.so.3 => /usr/lib/libtasn1.so.3 (0xb5e4c000)
        libgcrypt.so.11 => /lib/libgcrypt.so.11 (0xb5dff000)
        libgpg-error.so.0 => /lib/libgpg-error.so.0 (0xb5dfb000)
	  </screen></td></tr></tbody>
	</table>
	Set-up the necessary environment variables:
	<table frame="box">
	  <thead><tr><td>[Shell terminal session]</td></tr></thead>
	  <tbody><tr><td><screen>
tiian@ubuntu:~/tmp$ echo $LIXA_PROFILE

tiian@ubuntu:~/tmp$ export LIXA_PROFILE=MYS_STA_PQL_STA_ORA_DYN
tiian@ubuntu:~/tmp$ echo $LIXA_PROFILE
MYS_STA_PQL_STA_ORA_DYN
	  </screen></td></tr></tbody>
	</table>
	It is suggested to set the necessary environment variables in your 
	profile if you are going to execute the programs many times.
	This is the list of the suggested variables:
	<varname>LD_LIBRARY_PATH</varname>,
	<varname>LIXA_PROFILE</varname>,
	<varname>ORACLE_HOME</varname>,
	<varname>ORACLE_SID</varname>,
	<varname>PATH</varname>.
      </para>
    </section>
    <section>
      <title>Some checks before program execution</title>
      <para>
	We set <varname>LIXA_PROFILE</varname> to value
	<quote>MYS_STA_PQL_STA_ORA_DYN</quote>, looking at
	<filename>/opt/lixa/etc/lixac_conf.xml</filename>:
	<screen>
    &lt;profile name="MYS_STA_PQL_STA_ORA_DYN"&gt;
      &lt;sttsrvs&gt;
        &lt;sttsrv&gt;local_1&lt;/sttsrv&gt;
      &lt;/sttsrvs&gt;
      &lt;rsrmgrs&gt;
        &lt;rsrmgr&gt;MySQL_stareg&lt;/rsrmgr&gt;
        &lt;rsrmgr&gt;PostgreSQL_stareg&lt;/rsrmgr&gt;
        &lt;rsrmgr&gt;OracleXE_dynreg&lt;/rsrmgr&gt;
      &lt;/rsrmgrs&gt;
    &lt;/profile&gt;
	</screen>
	the profile references three Resource Managers:
	<quote>MySQL_stareg</quote>, <quote>PostgreSQL_stareg</quote> 
	and <quote>OracleXE_dynreg</quote>,
	looking again at the config file:
	<screen>
    &lt;rsrmgr name="MySQL_stareg" switch_file="/opt/lixa/lib/switch_mysql_stareg.so" xa_open_info="host=localhost,user=lixa,passwd=,db=lixa,client_flag=0" xa_close_info="" /&gt;
    &lt;rsrmgr name="PostgreSQL_stareg" switch_file="/opt/lixa/lib/switch_postgresql_stareg.so" xa_open_info="dbname=testdb" xa_close_info="" /&gt;
    &lt;rsrmgr name="OracleXE_dynreg" switch_file="/opt/lixa/lib/switch_oracle_dynreg.so" xa_open_info="Oracle_XA+Acc=P/hr/hr+SesTm=30+LogDir=/tmp+threads=true+DbgFl=7+Loose_Coupling=true" xa_close_info="" /&gt;
	</screen>
	we can discover how our application will access the resource
	managers
	<footnote>
	  <para>
	    The content of <constant>xa_open_info</constant> for MySQL is
	    described in 
	    <xref linkend="Development_setup_MySQL_xa_open_info"/>.
	  </para>
	</footnote>
	<footnote>
	  <para>
	    The content of <constant>xa_open_info</constant> is passed to
	    <function>PQconnectdb</function> function: you can refer to 
	    PostgreSQL official
	    documentation to discover what you can pass to this function.
	    Please pay attention the <varname>xa_open_info</varname> can
	    contain a maximum of 255 characters: this limitation is
	    documented in <citation>XAspec</citation>.
	  </para>
	</footnote>
	<footnote>
	  <para>
	    The content of <constant>xa_open_info</constant> string is
	    described in chapter 15 "Developing Applications with Oracle XA"
	    of the "Oracle Database Application Developer's Guide"
	    manual; please refer to the documentation published by
	    Oracle Corporation for further details.
	  </para>
	</footnote>. 
      </para>
      <para>
	Verify no (Oracle) trace file exists:
	<screen>
tiian@ubuntu:~/tmp$ ls -la /tmp/xa*
ls: cannot access /tmp/xa*: No such file or directory
	</screen>
      </para>
    </section>
    <section>
      <title>Program execution (dynamic registration for Oracle)</title>
      <para>
	It is suggested to open four different terminals: 
	the first one connected to <quote>lixa</quote> MySQL database,
	the second one connected to <quote>testdb</quote> PostgreSQL database,
	the third one connected to Oracle database and the
	fourth one pointing to the directory where the compiled program 
	example10_mys_pql_ora lives.
	<table frame="box">
	  <thead><tr><td>[MySQL terminal session]</td></tr></thead>
	  <tbody><tr><td><screen>
tiian@ubuntu:~$ mysql -h localhost -u lixa lixa
Reading table information for completion of table and column names
You can turn off this feature to get a quicker startup with -A

Welcome to the MySQL monitor.  Commands end with ; or \g.
Your MySQL connection id is 37
Server version: 5.0.51a-3ubuntu5.8 (Ubuntu)

Type 'help;' or '\h' for help. Type '\c' to clear the buffer.

mysql>
	  </screen></td></tr></tbody>
	</table>
	<table frame="box">
	  <thead><tr><td>[PostgreSQL terminal session]</td></tr></thead>
	  <tbody><tr><td><screen>
tiian@ubuntu:~$ psql testdb
Welcome to psql 8.3.15, the PostgreSQL interactive terminal.

Type:  \copyright for distribution terms
       \h for help with SQL commands
       \? for help with psql commands
       \g or terminate with semicolon to execute query
       \q to quit

testdb=>
	  </screen></td></tr></tbody>
	</table>
	<table frame="box">
	  <thead><tr><td>[Oracle terminal session]</td></tr></thead>
	  <tbody><tr><td><screen>
tiian@ubuntu:~$ . /usr/lib/oracle/xe/app/oracle/product/10.2.0/server/bin/oracle_env.sh
tiian@ubuntu:~$ sqlplus "hr/hr"                                                 
SQL*Plus: Release 10.2.0.1.0 - Production on Tue May 3 21:52:06 2011

Copyright (c) 1982, 2005, Oracle.  All rights reserved.


Connected to:
Oracle Database 10g Express Edition Release 10.2.0.1.0 - Production

SQL>
	  </screen></td></tr></tbody>
	</table>
	<table frame="box">
	  <thead><tr><td>[Shell terminal session]</td></tr></thead>
	  <tbody><tr><td><screen>
tiian@ubuntu:~/tmp$ ls -la
total 152
drwxr-xr-x  2 tiian tiian  4096 2011-11-11 21:06 .
drwxr-xr-x 40 tiian tiian  4096 2011-11-11 15:47 ..
-rwxr-xr-x  1 tiian tiian 12317 2011-11-11 21:06 example10_mys_pql_ora
-rw-r--r--  1 tiian tiian  8422 2011-11-11 21:05 example10_mys_pql_ora.c
	  </screen></td></tr></tbody>
	</table>
	Check the content of the MySQL table (<quote>authors</quote>):
	<table frame="box">
	  <thead><tr><td>[MySQL terminal session]</td></tr></thead>
	  <tbody><tr><td><screen>
mysql> SELECT * FROM authors;
Empty set (0.02 sec)
	  </screen></td></tr></tbody>
	</table>
	Check the content of the PostgreSQL table (<quote>AUTHORS</quote>):
	<table frame="box">
	  <thead><tr><td>[PostgreSQL terminal session]</td></tr></thead>
	  <tbody><tr><td><screen>
testdb=> select * from AUTHORS;
 id | last_name | first_name
----+-----------+------------
(0 rows)
	  </screen></td></tr></tbody>
	</table>
	Check the content of the Oracle table (<quote>COUNTRIES</quote>):
	<table frame="box">
	  <thead><tr><td>[Oracle terminal session]</td></tr></thead>
	  <tbody><tr><td><screen>
SQL> select * from COUNTRIES where COUNTRY_ID = 'RS';

no rows selected
	  </screen></td></tr></tbody>
	</table>
	Insert a row in all the tables and check the contents of the tables
	after the transaction execution:
	<table frame="box">
	  <thead><tr><td>[Shell terminal session]</td></tr></thead>
	  <tbody><tr><td><screen>
tiian@ubuntu:~/tmp$ ./example10_mys_pql_ora insert
Inserting a row in MySQL table...
Inserting a row in PostgreSQL table...
Inserting a row in Oracle table...
	  </screen></td></tr></tbody>
	</table>
	Now you can verify the content of the tables after the transaction:
	<table frame="box">
	  <thead><tr><td>[MySQL terminal session]</td></tr></thead>
	  <tbody><tr><td><screen>
mysql> SELECT * FROM authors;
+----+-----------+------------+
| id | last_name | first_name |
+----+-----------+------------+
|  1 | Foo       | Bar        |
+----+-----------+------------+
1 row in set (0.00 sec)
	  </screen></td></tr></tbody>
	</table>
	<table frame="box">
	  <thead><tr><td>[PostgreSQL terminal session]</td></tr></thead>
	  <tbody><tr><td><screen>
testdb=> select * from AUTHORS;
 id | last_name | first_name
----+-----------+------------
  1 | Foo       | Bar
(1 row)
	  </screen></td></tr></tbody>
	</table>
	<table frame="box">
	  <thead><tr><td>[Oracle terminal session]</td></tr></thead>
	  <tbody><tr><td><screen>
SQL> select * from COUNTRIES where COUNTRY_ID = 'RS';

CO COUNTRY_NAME                              REGION_ID
-- ---------------------------------------- ----------
RS Repubblica San Marino                             1
	  </screen></td></tr></tbody>
	</table>
	With the opposite command you can remove the rows from the tables:
	<table frame="box">
	  <thead><tr><td>[Shell terminal session]</td></tr></thead>
	  <tbody><tr><td><screen>
tiian@ubuntu:~/tmp$ ./example10_mys_pql_ora delete
Deleting a row from MySQL  table...
Deleting a row from PostgreSQL table...
Deleting a row from Oracle table...
	  </screen></td></tr></tbody>
	</table>
	and check the content of the tables again:
	<table frame="box">
	  <thead><tr><td>[MySQL terminal session]</td></tr></thead>
	  <tbody><tr><td><screen>
mysql> SELECT * FROM authors;
Empty set (0.00 sec)
	  </screen></td></tr></tbody>
	</table>
	<table frame="box">
	  <thead><tr><td>[PostgreSQL terminal session]</td></tr></thead>
	  <tbody><tr><td><screen>
testdb=> select * from AUTHORS;
 id | last_name | first_name
----+-----------+------------
(0 rows)
	  </screen></td></tr></tbody>
	</table>
	<table frame="box">
	  <thead><tr><td>[Oracle terminal session]</td></tr></thead>
	  <tbody><tr><td><screen>
SQL> select * from COUNTRIES where COUNTRY_ID = 'RS';

no rows selected
	  </screen></td></tr></tbody>
	</table>
	We can verify the dynamic registration behavior of Oracle:
	<table frame="box">
	  <thead><tr><td>[Shell terminal session]</td></tr></thead>
	  <tbody><tr><td><screen>
tiian@ubuntu:~/tmp$ export LIXA_TRACE_MASK=0x00002000
tiian@ubuntu:~/tmp$ echo $LIXA_TRACE_MASK
0x00002000
tiian@ubuntu:~/tmp$ ./example10_mys_pql_ora insert 2>&amp;1 | grep ax_reg
2011-11-11 21:39:40.850356 [23176/3051161344] ax_reg: rmid=2, xid=0xbfecc68c, flags=0x0
2011-11-11 21:39:40.850451 [23176/3051161344] ax_reg: the application program has started a transaction (TX states S3); this XID '1279875137.0600c467d21b42b38f1c89d912fc125d.8be5bdb35ba638bb997258e6bd8b9d88' will be returned
2011-11-11 21:39:40.850565 [23176/3051161344] ax_reg: sending 153 bytes to the server for step 8
2011-11-11 21:39:40.850602 [23176/3051161344] ax_reg/excp=7/ret_cod=0/errno=0
	  </screen></td></tr></tbody>
	</table>
	We can check the static registration behavior of Oracle with a 
	different profile:
	<table frame="box">
	  <thead><tr><td>[Shell terminal session]</td></tr></thead>
	  <tbody><tr><td><screen>
tiian@ubuntu:~/tmp$ export LIXA_PROFILE=MYS_STA_PQL_STA_ORA_STA
tiian@ubuntu:~/tmp$ echo $LIXA_PROFILE
MYS_STA_PQL_STA_ORA_STA
tiian@ubuntu:~/tmp$ ./example10_mys_pql_ora delete 2>&amp;1 | grep xa_start
2011-11-11 21:41:52.953050 [23204/3050981120] lixa_xa_start
[...]
2011-11-11 21:41:53.005001 [23204/3050981120] lixa_xa_start: xa_start_entry(xid, 0, 0x0) = 0
2011-11-11 21:41:53.007040 [23204/3050981120] lixa_xa_start: xa_start_entry(xid, 1, 0x0) = 0
2011-11-11 21:41:53.009927 [23204/3050981120] lixa_xa_start: xa_start_entry(xid, 2, 0x0) = 0
2011-11-11 21:41:53.010004 [23204/3050981120] lixa_xa_start: sending 352 bytes to the server for step 24
2011-11-11 21:41:53.010095 [23204/3050981120] lixa_xa_start/excp=10/ret_cod=0/errno=0
	  </screen></td></tr></tbody>
	</table>
	and check the content of the tables again:
	<table frame="box">
	  <thead><tr><td>[MySQL terminal session]</td></tr></thead>
	  <tbody><tr><td><screen>
mysql> SELECT * FROM authors;
Empty set (0.00 sec)
	  </screen></td></tr></tbody>
	</table>
	<table frame="box">
	  <thead><tr><td>[PostgreSQL terminal session]</td></tr></thead>
	  <tbody><tr><td><screen>
testdb=> select * from AUTHORS;
 id | last_name | first_name
----+-----------+------------
(0 rows)
	  </screen></td></tr></tbody>
	</table>
	<table frame="box">
	  <thead><tr><td>[Oracle terminal session]</td></tr></thead>
	  <tbody><tr><td><screen>
SQL> select * from COUNTRIES where COUNTRY_ID = 'RS';

no rows selected
	  </screen></td></tr></tbody>
	</table>
	The activity of the Oracle database can be analyzed in the trace file:
	<table frame="box">
	  <thead><tr><td>[Shell terminal session]</td></tr></thead>
	  <tbody><tr><td><screen>
tiian@ubuntu:~/tmp$ ls -la /tmp/xa_NULL11112011.trc
-rw-r--r-- 1 tiian tiian 22112 2011-11-11 21:47 /tmp/xa_NULL11112011.trc
	  </screen></td></tr></tbody>
	</table>
      </para>
    </section>
  </section>
  <section xml:id="Development_example11_mys_mys">
    <title>An example with two MySQL servers</title>
    <figure xml:id="develop11">
      <title>Deploy model of an example showing a distributed transaction with
	two MySQL servers</title>
      <mediaobject>
	<imageobject>
	  <imagedata fileref="../images/LIXA_Development_11.png"/>
	</imageobject>
      </mediaobject>
    </figure>
    <para>
      This example shows as
      you can implement DTP (Distributed Transaction Processing) with two
      Resource Managers of the same type (MySQL) 
      coordinated by the LIXA Transaction Manager.
      It's strongly suggested you have played with the
      examples previously shown in this chapter (see
      <xref linkend="Development"/>) before starting this more complex one.
    </para>
    <note>
      <para>
	If you did not yet installed the software provided by MySQL,
	please refer to the official MySQL site to download the
	software and to pick-up the information necessary to install 
	and configure
	the database. This manual does not give you information related
	to MySQL technology: it is assumed you already installed and
	configured the database.
      </para>
    </note>
    <important>
      <para>
	The LIXA software must be configured to support the MySQL 
	resource managers as explained in 
	<xref linkend="Linking_third_party_resource_managers"/>.
	As a little hint, you should configure LIXA as below:
	<screen>
./configure --with-mysql
	</screen>
	Please don't forget you must compile and install every time you
	re-configure.
      </para>
    </important>
    <para>
      Please follow the instructions explained 
      <itemizedlist mark="bullet">
	<listitem><para>
	    in <xref linkend="Development_setup_MySQL_environment"/>
	    to set-up a running environment for MySQL server
	</para></listitem>
	<listitem><para>
	    in <xref linkend="Development_start_LIXA_server"/>
	    to start up the LIXA state server
	</para></listitem>
      </itemizedlist>
      To address a remote MySQL server some additional steps must be completed.
      The example explained here uses this configuration:
      <itemizedlist mark="bullet">
	<listitem><para>
	    IP address of the server running <command>lixad</command>
	    (LIXA state server), application program and local MySQL
	    server (reached using localhost 
	    <systemitem class="ipaddress">127.0.0.1</systemitem> 
	    address): 
	    <systemitem class="ipaddress">192.168.1.2</systemitem> 
	</para></listitem>
	<listitem><para>
	    IP address of the server running the remote MySQL server:
	    <systemitem class="ipaddress">192.168.1.3</systemitem> 
	</para></listitem>
      </itemizedlist>
      Connect to server 
      <systemitem class="ipaddress">192.168.1.3</systemitem> 
      and change the parameter
      <parameter>bind-address</parameter> in the file
      <filename>/etc/mysql/my.cnf</filename> to allow network reachability:
      <table frame="box">
	<thead><tr><td>[Host:192.168.1.3 /etc/mysql/my.cnf]</td></tr></thead>
	<tbody><tr><td><screen>
# Instead of skip-networking the default is now to listen only on
# localhost which is more compatible and is not less secure.
#bind-address            = 127.0.0.1
bind-address            = 192.168.1.3
	</screen></td></tr></tbody>
      </table>
      restart MySQL server:
      <table frame="box">
	<thead><tr><td>[Host:192.168.1.3 terminal session]</td></tr></thead>
	<tbody><tr><td><screen>
tiian@ubuntu:~$ sudo /etc/init.d/mysql restart
[sudo] password for tiian:
 * Stopping MySQL database server mysqld                                 [ OK ]
 * Starting MySQL database server mysqld                                 [ OK ]
 * Checking for corrupt, not cleanly closed and upgrade needing tables.
	</screen></td></tr></tbody>
      </table>
      connect to that MySQL server from the remote host and grant access to
      user <systemitem class="username">lixa</systemitem> from the server 
      <systemitem class="ipaddress">192.168.1.2</systemitem>:
      <table frame="box">
	<thead><tr><td>[Host:192.168.1.3 terminal session]</td></tr></thead>
	<tbody><tr><td><screen>
tiian@mojan:~$ mysql -u root -p
Enter password:
Welcome to the MySQL monitor.  Commands end with ; or \g.
Your MySQL connection id is 11
Server version: 5.0.51a-3ubuntu5.8 (Ubuntu)

Type 'help;' or '\h' for help. Type '\c' to clear the buffer.

mysql> GRANT ALL ON lixa.* TO 'lixa'@'192.168.1.2';
Query OK, 0 rows affected (0.00 sec)
	</screen></td></tr></tbody>
      </table>
      now you should be able to connect to the server running at
      <systemitem class="ipaddress">192.168.1.3</systemitem> 
      from the server 
      <systemitem class="ipaddress">192.168.1.2</systemitem>:
      <table frame="box">
	<thead><tr><td>[Host:192.168.1.2 terminal session]</td></tr></thead>
	<tbody><tr><td><screen>
tiian@ubuntu:~$ mysql -h 192.168.1.3 -u lixa lixa
Reading table information for completion of table and column names
You can turn off this feature to get a quicker startup with -A

Welcome to the MySQL monitor.  Commands end with ; or \g.
Your MySQL connection id is 13
Server version: 5.0.51a-3ubuntu5.8 (Ubuntu)

Type 'help;' or '\h' for help. Type '\c' to clear the buffer.
	</screen></td></tr></tbody>
      </table>
      and you must create the table necessary for the example program:
      <table frame="box">
	<thead><tr><td>[MySQL (remote) terminal session]</td></tr></thead>
	<tbody><tr><td><screen>
mysql> CREATE TABLE authors (id INTEGER NOT NULL PRIMARY KEY, last_name TEXT, first_name TEXT) ENGINE=InnoDB;
Query OK, 0 rows affected (0.01 sec)

mysql> DESCRIBE authors;
+------------+---------+------+-----+---------+-------+
| Field      | Type    | Null | Key | Default | Extra |
+------------+---------+------+-----+---------+-------+
| id         | int(11) | NO   | PRI | NULL    |       |
| last_name  | text    | YES  |     | NULL    |       |
| first_name | text    | YES  |     | NULL    |       |
+------------+---------+------+-----+---------+-------+
3 rows in set (0.01 sec)
	</screen></td></tr></tbody>
      </table>
    </para>
    <section>
      <title>Build the client program</title>
      <para>
	Prepare the client (Application Program) using the below commands
	(<command>gcc</command> command was splitted on several lines 
	using <command>\</command> to help readability, but you may use
	a single line):
	<table frame="box">
	  <thead><tr><td>[Shell terminal session]</td></tr></thead>
	  <tbody><tr><td><screen>
tiian@ubuntu:~$ mkdir tmp
tiian@ubuntu:~$ cd tmp
tiian@ubuntu:~/tmp$ cp /opt/lixa/share/doc/lixa-X.Y.Z/examples/example11_mys_mys.c .
tiian@ubuntu:~/tmp$ gcc example11_mys_mys.c $(/opt/lixa/bin/lixa-config -c -f -m -d) \
> $(mysql_config --include --libs_r) -o example11_mys_mys
	  </screen></td></tr></tbody>
	</table>
	Verify the executable produced by <command>gcc</command>:
	<table frame="box">
	  <thead><tr><td>[Shell terminal session]</td></tr></thead>
	  <tbody><tr><td><screen>
tiian@ubuntu:~/tmp$ ldd example11_mys_mys
        linux-gate.so.1 =>  (0xb777d000)
        liblixac.so.0 => /opt/lixa/lib/liblixac.so.0 (0xb7762000)
        liblixamy.so.0 => /opt/lixa/lib/liblixamy.so.0 (0xb775a000)
        libmysqlclient_r.so.15 => /usr/lib/libmysqlclient_r.so.15 (0xb7569000)
        libc.so.6 => /lib/tls/i686/cmov/libc.so.6 (0xb741a000)
        libgmodule-2.0.so.0 => /usr/lib/libgmodule-2.0.so.0 (0xb7416000)
        libdl.so.2 => /lib/tls/i686/cmov/libdl.so.2 (0xb7412000)
        libgthread-2.0.so.0 => /usr/lib/libgthread-2.0.so.0 (0xb740d000)
        librt.so.1 => /lib/tls/i686/cmov/librt.so.1 (0xb7403000)
        libglib-2.0.so.0 => /usr/lib/libglib-2.0.so.0 (0xb7352000)
        libxml2.so.2 => /usr/lib/libxml2.so.2 (0xb7232000)
        liblixab.so.0 => /opt/lixa/lib/liblixab.so.0 (0xb721d000)
        libpthread.so.0 => /lib/tls/i686/cmov/libpthread.so.0 (0xb7205000)
        libcrypt.so.1 => /lib/tls/i686/cmov/libcrypt.so.1 (0xb71d3000)
        libnsl.so.1 => /lib/tls/i686/cmov/libnsl.so.1 (0xb71ba000)
        libm.so.6 => /lib/tls/i686/cmov/libm.so.6 (0xb7195000)
        libz.so.1 => /usr/lib/libz.so.1 (0xb7180000)
        /lib/ld-linux.so.2 (0xb777e000)
        libpcre.so.3 => /usr/lib/libpcre.so.3 (0xb7159000)
        libuuid.so.1 => /lib/libuuid.so.1 (0xb7155000)
	  </screen></td></tr></tbody>
	</table>
      </para>
    </section>
    <section>
      <title>Set-up LIXA environment</title>
      <para>
	Set-up the necessary environment variables:
	<table frame="box">
	  <thead><tr><td>[Shell terminal session]</td></tr></thead>
	  <tbody><tr><td><screen>
tiian@ubuntu:~/tmp$ echo $LIXA_PROFILE

tiian@ubuntu:~/tmp$ export LIXA_PROFILE=MYS_STA_MYS_STA
tiian@ubuntu:~/tmp$ echo $LIXA_PROFILE
MYS_STA_MYS_STA
	  </screen></td></tr></tbody>
	</table>
	It is suggested to set the necessary environment variable
	(<varname>LIXA_PROFILE</varname>) in your 
	profile if you are going to execute the programs many times.
      </para>
    </section>
    <section>
      <title>Some checks before program execution</title>
      <para>
	We set <varname>LIXA_PROFILE</varname> to value
	<quote>MYS_STA_MYS_STA</quote>, looking at
	<filename>/opt/lixa/etc/lixac_conf.xml</filename>:
	<screen>
    &lt;profile name="MYS_STA_MYS_STA"&gt;
      &lt;sttsrvs&gt;
        &lt;sttsrv&gt;local_1&lt;/sttsrv&gt;
      &lt;/sttsrvs&gt;
      &lt;rsrmgrs&gt;
        &lt;rsrmgr&gt;MySQL_stareg&lt;/rsrmgr&gt;
        &lt;rsrmgr&gt;MySQL2_stareg&lt;/rsrmgr&gt;
      &lt;/rsrmgrs&gt;
    &lt;/profile&gt;
	</screen>
	the profile references two Resource Managers:
	<quote>MySQL_stareg</quote> and <quote>MySQL2_stareg</quote> 
	looking again at the config file:
	<screen>
    &lt;rsrmgr name="MySQL_stareg" switch_file="/opt/lixa/lib/switch_mysql_stareg.so" xa_open_info="host=localhost,user=lixa,passwd=,db=lixa,client_flag=0" xa_close_info="" /&gt;
    &lt;rsrmgr name="MySQL2_stareg" switch_file="/opt/lixa/lib/switch_mysql_stareg.so" xa_open_info="host=192.168.1.3,user=lixa,passwd=,db=lixa,client_flag=0" xa_close_info="" /&gt;
	</screen>
	we can discover how our application will access the resource
	managers
	<footnote>
	  <para>
	    The content of <constant>xa_open_info</constant> for MySQL is
	    described in 
	    <xref linkend="Development_setup_MySQL_xa_open_info"/>.
	  </para>
	</footnote>. 
      </para>
    </section>
    <section>
      <title>Program execution</title>
      <para>
	It is suggested to open three different terminals: 
	the first one connected to <quote>lixa</quote> local MySQL database,
	the second one connected to <quote>lixa</quote> remote MySQL database
	and the	third one pointing to the directory where the compiled program 
	example11_mys_mys lives.
	<table frame="box">
	  <thead><tr><td>[MySQL (local) terminal session]</td></tr></thead>
	  <tbody><tr><td><screen>
tiian@ubuntu:~$ mysql -h localhost -u lixa lixa
Reading table information for completion of table and column names
You can turn off this feature to get a quicker startup with -A

Welcome to the MySQL monitor.  Commands end with ; or \g.
Your MySQL connection id is 37
Server version: 5.0.51a-3ubuntu5.8 (Ubuntu)

Type 'help;' or '\h' for help. Type '\c' to clear the buffer.

mysql>
	  </screen></td></tr></tbody>
	</table>
	<table frame="box">
	  <thead><tr><td>[MySQL (remote) terminal session]</td></tr></thead>
	  <tbody><tr><td><screen>
tiian@ubuntu:~$ mysql -h 192.168.1.3 -u lixa lixa
Reading table information for completion of table and column names
You can turn off this feature to get a quicker startup with -A

Welcome to the MySQL monitor.  Commands end with ; or \g.
Your MySQL connection id is 7
Server version: 5.0.51a-3ubuntu5.8 (Ubuntu)

Type 'help;' or '\h' for help. Type '\c' to clear the buffer.
	  </screen></td></tr></tbody>
	</table>
	<table frame="box">
	  <thead><tr><td>[Shell terminal session]</td></tr></thead>
	  <tbody><tr><td><screen>
tiian@ubuntu:~/tmp$ ls -la
total 168
drwxr-xr-x  2 tiian tiian  4096 2011-11-13 21:04 .
drwxr-xr-x 40 tiian tiian  4096 2011-11-13 19:09 ..
-rwxr-xr-x  1 tiian tiian  9201 2011-11-13 21:04 example11_mys_mys
-rw-r--r--  1 tiian tiian  3977 2011-11-13 21:04 example11_mys_mys.c
	  </screen></td></tr></tbody>
	</table>
	Check the content of the (local) MySQL table (<quote>authors</quote>):
	<table frame="box">
	  <thead><tr><td>[MySQL (local) terminal session]</td></tr></thead>
	  <tbody><tr><td><screen>
mysql> SELECT * FROM authors;
Empty set (0.02 sec)
	  </screen></td></tr></tbody>
	</table>
	Check the content of the (remote) MySQL table (<quote>authors</quote>):
	<table frame="box">
	  <thead><tr><td>[MySQL (remote) terminal session]</td></tr></thead>
	  <tbody><tr><td><screen>
mysql> SELECT * FROM authors;
Empty set (0.01 sec)
	  </screen></td></tr></tbody>
	</table>
	Insert a row in all the tables and check the contents of the tables
	after the transaction execution:
	<table frame="box">
	  <thead><tr><td>[Shell terminal session]</td></tr></thead>
	  <tbody><tr><td><screen>
tiian@ubuntu:~/tmp$ ./example11_mys_mys insert
Inserting a row in MySQL(1) table...
Inserting a row in MySQL(2) table...
	  </screen></td></tr></tbody>
	</table>
	Now you can verify the content of the tables after the transaction:
	<table frame="box">
	  <thead><tr><td>[MySQL (local) terminal session]</td></tr></thead>
	  <tbody><tr><td><screen>
mysql> SELECT * FROM authors;
+----+-----------+------------+
| id | last_name | first_name |
+----+-----------+------------+
|  1 | Foo       | Bar        |
+----+-----------+------------+
1 row in set (0.00 sec)
	  </screen></td></tr></tbody>
	</table>
	<table frame="box">
	  <thead><tr><td>[MySQL (remote) terminal session]</td></tr></thead>
	  <tbody><tr><td><screen>
mysql> SELECT * FROM authors;
+----+-----------+------------+
| id | last_name | first_name |
+----+-----------+------------+
|  1 | Foo       | Bar        |
+----+-----------+------------+
1 row in set (0.01 sec)
	  </screen></td></tr></tbody>
	</table>
	With the opposite command you can remove the rows from the tables:
	<table frame="box">
	  <thead><tr><td>[Shell terminal session]</td></tr></thead>
	  <tbody><tr><td><screen>
tiian@ubuntu:~/tmp$ ./example11_mys_mys delete
Deleting a row from MySQL(1) table...
Deleting a row from MySQL(2) table...
	  </screen></td></tr></tbody>
	</table>
	and check the content of the tables again:
	<table frame="box">
	  <thead><tr><td>[MySQL (local) terminal session]</td></tr></thead>
	  <tbody><tr><td><screen>
mysql> SELECT * FROM authors;
Empty set (0.00 sec)
	  </screen></td></tr></tbody>
	</table>
	<table frame="box">
	  <thead><tr><td>[MySQL (remote) terminal session]</td></tr></thead>
	  <tbody><tr><td><screen>
mysql> SELECT * FROM authors;
Empty set (0.00 sec)
	  </screen></td></tr></tbody>
	</table>
	Finally, you can verify the two phase commit protocol is running as
	expected. Insert a row in all the tables:
	<table frame="box">
	  <thead><tr><td>[Shell terminal session]</td></tr></thead>
	  <tbody><tr><td><screen>
tiian@ubuntu:~/tmp$ ./example11_mys_mys insert
Inserting a row in MySQL(1) table...
Inserting a row in MySQL(2) table...
	  </screen></td></tr></tbody>
	</table>
	manually remove the row from the local MySQL server only:
	<table frame="box">
	  <thead><tr><td>[MySQL (local) terminal session]</td></tr></thead>
	  <tbody><tr><td><screen>
mysql> SELECT * FROM authors;
+----+-----------+------------+
| id | last_name | first_name |
+----+-----------+------------+
|  1 | Foo       | Bar        |
+----+-----------+------------+
1 row in set (0.00 sec)

mysql> DELETE FROM authors;
Query OK, 1 row affected (0.01 sec)

mysql> SELECT * FROM authors;
Empty set (0.00 sec)
	  </screen></td></tr></tbody>
	</table>
	try to insert the row again in all the tables:
	<table frame="box">
	  <thead><tr><td>[Shell terminal session]</td></tr></thead>
	  <tbody><tr><td><screen>
tiian@ubuntu:~/tmp$ ./example11_mys_mys insert
Inserting a row in MySQL(1) table...
Inserting a row in MySQL(2) table...
INSERT INTO authors: 1062/Duplicate entry '1' for key 1
	  </screen></td></tr></tbody>
	</table>
	the first (local) INSERT is ok, while the second one can not be
	performed due to a duplicated key. 
	Check the content of the tables again:
	<table frame="box">
	  <thead><tr><td>[MySQL (local) terminal session]</td></tr></thead>
	  <tbody><tr><td><screen>
mysql> SELECT * FROM authors;
Empty set (0.00 sec)
	  </screen></td></tr></tbody>
	</table>
	<table frame="box">
	  <thead><tr><td>[MySQL (remote) terminal session]</td></tr></thead>
	  <tbody><tr><td><screen>
mysql> SELECT * FROM authors;
+----+-----------+------------+
| id | last_name | first_name |
+----+-----------+------------+
|  1 | Foo       | Bar        |
+----+-----------+------------+
1 row in set (0.01 sec)
	  </screen></td></tr></tbody>
	</table>
	If you inspect the program
	source code you will discover what the program will do:
	<table frame="box">
	  <thead><tr><td><filename>example11_mys_mys.c</filename></td></tr></thead>
	  <tbody><tr><td><screen>
        [...]

        printf("Inserting a row in MySQL(2) table...\n");
        if (mysql_query(conn2,
                        "INSERT INTO authors VALUES(1, 'Foo', 'Bar')")) {
            fprintf(stderr, "INSERT INTO authors: %u/%s\n",
                    mysql_errno(conn2), mysql_error(conn2));
            exit_nicely(conn1, conn2);
        }

        [...]
	  </screen></td></tr></tbody>
	</table>
	in case of error the program exits closing the connections...
	XA protocol is a <quote>two phase commit with presumed 
	rollback</quote>: if the transaction does not complete 
	<function>xa_prepare</function>, the transaction will be rolled back.
	An alternative way is the usage of <function>tx_rollback()</function>:
	you can rollback the current transaction and start a new one without
	program (and connection) termination.
	Clean up the (remote) table:
	<table frame="box">
	  <thead><tr><td>[MySQL (remote) terminal session]</td></tr></thead>
	  <tbody><tr><td><screen>
mysql> DELETE FROM authors;
Query OK, 1 row affected (0.04 sec)

mysql> SELECT * FROM authors;
Empty set (0.00 sec)
	  </screen></td></tr></tbody>
	</table>
      </para>
    </section>
  </section>
  <section xml:id="Development_example12_wmq">
    <title>An example with WebSphere MQ</title>
    <section>
      <title>Introduction</title>
      <para>
	WebSphere MQ is a proprietary commercial product supplied by
	IBM Corporation: the LIXA project tested its behavior when managed
	by LIXA Transaction Manager using a trial copy. At the time of this
	writing, the author does not know if a reduced 
	<quote>express</quote> or <quote>community</quote> edition exists.
	If you are interested in LIXA and WebSphere MQ you probably already
	have a valid license to run the software supplied by IBM.
      </para>
      <para>
	WebSphere MQ is a special type of Resource Manager because:
	<itemizedlist mark="bullet">
	  <listitem><para>
	      it can work as a Transaction Manager as well as a Resource
	      Manager; LIXA does <emphasis>not</emphasis> use WebSphere MQ
	      as a Transaction Manager, but only as a Resource Manager.
	      If you were interested in the Transaction Manager feature of
	      WebSphere MQ, you should stop this reading and go to the IBM
	      official documentation
	  </para></listitem>
	  <listitem><para>
	      the WebSphere MQ Resource Manager can be interfaced by a standard
	      XA Transaction Manager using two different configurations:
	      <emphasis>server (bind)</emphasis> and
	      <emphasis>Extended Transactional Client</emphasis>
	  </para></listitem>
	</itemizedlist>
      </para>
      <section>
	<title>WebSphere MQ server/bind (SRV) mode</title>
	<para>
	  To use this mode, the WebSphere MQ queue manager used by your
	  Application Program <emphasis>must reside</emphasis> inside the
	  same host of your Application Program: the communication between
	  your Application Program and the queue manager uses interprocess
	  communication (UNIX System V IPC). The interface is really fast,
	  but you can not travel a network (LAN/MAN/WAN) using it.
	  If your Application Program and the queue manager are hosted
	  by different systems, you will have to use the ETC mode.
	</para>
      </section>
      <section>
	<title>WebSphere MQ Extended Transactional Client (ETC) mode</title>
	<para>
	  You can use this mode every time your Application Program can
	  reach the desired queue manager using a network: it's usually an
	  IP network, but WebSphere MQ gives you different choices if you
	  have to deal with some special non IP based environment like a
	  SNA network.
	</para>
	<para>
	  You should pay attention the 
	  <emphasis>Extended Transactional Client (ETC) is not</emphasis>
	  a basic client: you must install a specific package and you must
	  pay a specific license to use it. This is not an IBM site, contact
	  your IBM vendor to pick-up all the necessary information.
	</para>
	<para>
	  The basic/standard WebSphere MQ client can
	  <emphasis>not</emphasis> be used in conjunction with LIXA because
	  it does <emphasis>not</emphasis> support the XA protocol. 
	</para>
      </section>
      <important><para>
	You must not configure and build LIXA to use WebSphere with 
	server/bind mode and build your Application Program to use
	WebSphere with ETC mode, or vice versa. If you did it, you would
	catch unexpected behaviors.
      </para></important>
      <important><para>
	The LIXA software must be configured to support the WebSphere MQ
	Resource Manager as explained in 
	<xref linkend="Linking_third_party_resource_managers"/>.
      </para></important>
      <para>
	LIXA project provides <command>lixa-config</command> to retrieve
	how the LIXA was configured and built:
	<table frame="box">
	  <thead><tr><td>[Shell terminal session]</td></tr></thead>
	  <tbody><tr><td><screen>
[tiian@centos lixa]$ /opt/lixa/bin/lixa-config --rsrc-mngrs
DB2             no
MySQL           yes
Oracle          no
PostgreSQL      yes
WebSphereMQ     yes     (ETC)
	  </screen></td></tr></tbody>
	</table>
      </para>
    </section>
    <figure xml:id="develop12">
      <title>Deploy model of an example with WebSphere MQ</title>
      <mediaobject>
	<imageobject>
	  <imagedata fileref="../images/LIXA_Development_12.png"/>
	</imageobject>
      </mediaobject>
    </figure>
    <section xml:id="Development_setup_WebSphereMQ_environment">
      <title>Set-up WebSphere MQ environment</title>
      <para>
	This example was developed using WebSphere MQ 7.1 for Linux (32 bit)
	and CentOS 6.2 (32 bit).
	<note><para>
	    If you did not yet installed the software, please refer to IBM
	    official documentation.
	    You should need at least these packages for server/bind mode:
	    <itemizedlist mark="bullet">
	      <listitem><para>
		  MQSeriesServer
	      </para></listitem>
	      <listitem><para>
		  MQSeriesSDK
	      </para></listitem>
	      <listitem><para>
		  MQSeriesRuntime
	      </para></listitem>
	    </itemizedlist>
	    You should need at least these packages for ETC mode:
	    <itemizedlist mark="bullet">
	      <listitem><para>
		  MQSeriesTXClient
	      </para></listitem>
	      <listitem><para>
		  MQSeriesSDK
	      </para></listitem>
	      <listitem><para>
		  MQSeriesRuntime
	      </para></listitem>
	      <listitem><para>
		  MQSeriesJava
	      </para></listitem>
	    </itemizedlist>
	</para></note>
	These are the necessary configuration steps to create the environment
	to run the supplied example (<filename>example12_wmq.c</filename>).
	First, you must set the correct environment for your shell:
      </para>
      <para>
	<table frame="box">
	  <thead><tr><td>[Shell terminal session]</td></tr></thead>
	  <tbody><tr><td><screen>
[tiian@centos manuals]$ su -
Password:
[tiian@centos manuals]$ cd
[tiian@centos ~]$ su -
Password:
[root@centos ~]# su - mqm
-bash-4.1$ . /opt/mqm71/bin/setmqenv -s
-bash-4.1$ dspmqver
Name:        WebSphere MQ
Version:     7.1.0.0
Level:       p000-L111024
BuildType:   IKAP - (Production)
Platform:    WebSphere MQ for Linux (x86 platform)
Mode:        32-bit
O/S:         Linux 2.6.32-220.el6.i686
InstName:    Installation1
InstDesc:
InstPath:    /opt/mqm71
DataPath:    /var/mqm
Primary:     No
MaxCmdLevel: 710
	  </screen></td></tr></tbody>
	</table>
	<note><para>
	    I installed the product in <filename>/opt/mqm71</filename>:
	    adjust the command to reflect your real installation path.
	</para></note>
	Create a queue manager named <quote>LIXA</quote> and start it:
	<table frame="box">
	  <thead><tr><td>[Shell terminal session]</td></tr></thead>
	  <tbody><tr><td><screen>
-bash-4.1$ crtmqm LIXA
There are 90 days left in the trial period for this copy of WebSphere MQ.
WebSphere MQ queue manager created.
Directory '/var/mqm/qmgrs/LIXA' created.
The queue manager is associated with installation 'Installation1'.
Creating or replacing default objects for queue manager 'LIXA'.
Default objects statistics : 71 created. 0 replaced. 0 failed.
Completing setup.
Setup completed.

-bash-4.1$ strmqm LIXA
There are 90 days left in the trial period for this copy of WebSphere MQ.
WebSphere MQ queue manager 'LIXA' starting.
The queue manager is associated with installation 'Installation1'.
5 log records accessed on queue manager 'LIXA' during the log replay phase.
Log replay for queue manager 'LIXA' complete.
Transaction manager state recovered for queue manager 'LIXA'.
WebSphere MQ queue manager 'LIXA' started using V7.1.0.0.
	  </screen></td></tr></tbody>
	</table>
	Create a test queue named <quote>LIXA.QLOCAL</quote>
	<table frame="box">
	  <thead><tr><td>[Shell terminal session]</td></tr></thead>
	  <tbody><tr><td><screen>
-bash-4.1$ runmqsc LIXA
5724-H72 (C) Copyright IBM Corp. 1994, 2011.  ALL RIGHTS RESERVED.
Starting MQSC for queue manager LIXA.


DEFINE QLOCAL(LIXA.QLOCAL)
     1 : DEFINE QLOCAL(LIXA.QLOCAL)
AMQ8006: WebSphere MQ queue created.
end
     2 : end
One MQSC command read.
No commands have a syntax error.
All valid MQSC commands were processed.
	  </screen></td></tr></tbody>
	</table>
	try to put/get a message into/from it using your own user
	(mine is <systemitem class="username">lixa</systemitem>):
	<table frame="box">
	  <thead><tr><td>[Shell terminal session]</td></tr></thead>
	  <tbody><tr><td><screen>
[tiian@centos ~]$ . /opt/mqm71/bin/setmqenv -s
[tiian@centos ~]$ cd /opt/mqm71/samp/bin
[tiian@centos bin]$ ./amqsput LIXA.QLOCAL LIXA
Sample AMQSPUT0 start
target queue is LIXA.QLOCAL
This is a test message

Sample AMQSPUT0 end
[tiian@centos bin]$ ./amqsget LIXA.QLOCAL LIXA
Sample AMQSGET0 start
message &lt;This is a test message&gt;
no more messages
Sample AMQSGET0 end
	  </screen></td></tr></tbody>
	</table>
	Please refer to IBM documentation for 
	<command>runmqsc, amqsput, amqsget</command> commands.
      </para>
      <para>
	Now you can create the definition necessary for WebSphere MQ client
	mode. First, authorize your user to connect to the queue manager
	using a user <emphasis>not</emphasis> connected to
	<systemitem class="group">mqm</systemitem> group
	(change <systemitem class="username">tiian</systemitem> with your
	own user):
	<table frame="box">
	  <thead><tr><td>[Shell terminal session]</td></tr></thead>
	  <tbody><tr><td><screen>
-bash-4.1$ runmqsc LIXA
5724-H72 (C) Copyright IBM Corp. 1994, 2011.  ALL RIGHTS RESERVED.
Starting MQSC for queue manager LIXA.


DISPLAY QMGR CHLAUTH
     1 : DISPLAY QMGR CHLAUTH
AMQ8408: Display Queue Manager details.
   QMNAME(LIXA)                            CHLAUTH(ENABLED)
SET AUTHREC OBJTYPE(QMGR) PRINCIPAL('tiian') AUTHADD(CONNECT)
     2 : SET AUTHREC OBJTYPE(QMGR) PRINCIPAL('tiian') AUTHADD(CONNECT)
AMQ8862: WebSphere MQ authority record set.
SET AUTHREC PROFILE(LIXA.QLOCAL) OBJTYPE(QUEUE) PRINCIPAL('tiian')
AUTHADD(PUT,GET)
     3 : SET AUTHREC PROFILE(LIXA.QLOCAL) OBJTYPE(QUEUE) PRINCIPAL('tiian')
AUTHADD(PUT,GET)
AMQ8862: WebSphere MQ authority record set.
end
     4 : end
3 MQSC commands read.
No commands have a syntax error.
All valid MQSC commands were processed.
	  </screen></td></tr></tbody>
	</table>
	Then create a connection channel, authorize it to your user
	(change <systemitem class="username">tiian</systemitem>) and 
	a listener:
	<table frame="box">
	  <thead><tr><td>[Shell terminal session]</td></tr></thead>
	  <tbody><tr><td><screen>
-bash-4.1$ runmqsc LIXA
5724-H72 (C) Copyright IBM Corp. 1994, 2011.  ALL RIGHTS RESERVED.
Starting MQSC for queue manager LIXA.


DEFINE CHANNEL (LIXA.CHANNEL) CHLTYPE (SVRCONN) TRPTYPE (TCP)
     1 : DEFINE CHANNEL (LIXA.CHANNEL) CHLTYPE (SVRCONN) TRPTYPE (TCP)
AMQ8014: WebSphere MQ channel created.
SET CHLAUTH(LIXA.CHANNEL) TYPE(ADDRESSMAP) ADDRESS('127.0.0.1')
MCAUSER('tiian')
     2 : SET CHLAUTH(LIXA.CHANNEL) TYPE(ADDRESSMAP) ADDRESS('127.0.0.1')
MCAUSER('tiian')
AMQ8877: WebSphere MQ channel authentication record set.
DEFINE LISTENER (LIXA.LISTENER) TRPTYPE (TCP) CONTROL (QMGR) PORT(1414)
     3 : DEFINE LISTENER (LIXA.LISTENER) TRPTYPE (TCP) CONTROL (QMGR)
PORT(1414)
AMQ8626: WebSphere MQ listener created.
START LISTENER(LIXA.LISTENER)
     4 : START LISTENER(LIXA.LISTENER)
AMQ8021: Request to start WebSphere MQ listener accepted.
end
     5 : end
4 MQSC commands read.
No commands have a syntax error.
All valid MQSC commands were processed.
	  </screen></td></tr></tbody>
	</table>
	Now you can try the TCP/IP client connection using 
	<emphasis>your own</emphasis> user (mine is
	<systemitem class="username">tiian</systemitem>):
	<table frame="box">
	  <thead><tr><td>[Shell terminal session]</td></tr></thead>
	  <tbody><tr><td><screen>
[tiian@centos ~]$ export MQSERVER=LIXA.CHANNEL/TCP/'127.0.0.1(1414)'
[tiian@centos ~]$ echo $MQSERVER
LIXA.CHANNEL/TCP/127.0.0.1(1414)

[tiian@centos ~]$ cd /opt/mqm71/samp/bin
[tiian@centos bin]$ . /opt/mqm71/bin/setmqenv -s
[tiian@centos bin]$ ./amqsputc LIXA.QLOCAL LIXA
Sample AMQSPUT0 start
target queue is LIXA.QLOCAL
This is a test message (from client)

Sample AMQSPUT0 end
[tiian@centos bin]$ ./amqsgetc LIXA.QLOCAL LIXA
Sample AMQSGET0 start
message &lt;This is a test message (from client)&gt;
no more messages
Sample AMQSGET0 end
	  </screen></td></tr></tbody>
	</table>
	Please refer to IBM documentation for 
	<command>runmqsc, amqsputc, amqsgetc</command> commands.
      </para>
      <para>
	OK, the <quote>LIXA.QLOCAL</quote> local queue was created and it's
	usable. If something went wrong, you should refer to WebSphere MQ
	documentation to fix the issue before the next step because you 
	would not be able to execute the sample program without a basic 
	running installation. 
      </para>
    </section>
    <section>
      <title>Start the LIXA state server</title>
      <para>
	Start the state server as shown below:
	<table frame="box">
	  <thead><tr><td>[Shell terminal session]</td></tr></thead>
	  <tbody><tr><td><screen>
[tiian@centos ~]$ su -
Password:
[root@centos ~]# su - lixa
[lixa@centos ~]$ /opt/lixa/sbin/lixad --daemon
[lixa@centos ~]$ exit
logout
[root@centos ~]# exit
logout
[tiian@centos ~]$ ps -ef|grep lixad|grep -v grep
lixa      3589     1  0 12:30 ?        00:00:00 /opt/lixa/sbin/lixad --daemon
	  </screen></td></tr></tbody>
	</table>
      </para>
    </section>
    <section>
      <title>Build the client program (SRV mode)</title>
      <para>
	Prepare the client (Application Program) using the below commands
	(<command>gcc</command> command was splitted on 
	several lines using \ to help
	readability, but you may use a single line): 
	<table frame="box">
	  <thead><tr><td>[Shell terminal session]</td></tr></thead>
	  <tbody><tr><td><screen>
[tiian@centos ~]$ mkdir tmp
[tiian@centos ~]$ cd tmp
[tiian@centos tmp]$ cp /opt/lixa/share/doc/lixa-X.Y.Z/examples/example12_wmq.c .
[tiian@centos tmp]$ /opt/lixa/bin/lixa-config -r|grep WebSphereMQ
WebSphereMQ     yes     (SRV)
[tiian@centos tmp]$ gcc example12_wmq.c $(/opt/lixa/bin/lixa-config -c -f -l -d) \
> -I/opt/mqm71/inc -L/opt/mqm71/lib -Wl,-rpath=/opt/mqm71/lib \
> -lmqm_r -o example12_wmq
	  </screen></td></tr></tbody>
	</table>
	Verify the executable produced by <command>gcc</command>:
	<table frame="box">
	  <thead><tr><td>[Shell terminal session]</td></tr></thead>
	  <tbody><tr><td><screen>
[tiian@centos tmp]$ ldd example12_wmq
        linux-gate.so.1 =>  (0x00852000)
        liblixac.so.0 => /opt/lixa/lib/liblixac.so.0 (0x00cfc000)
        libmqm_r.so => /opt/mqm71/lib/libmqm_r.so (0x00a7f000)
        libc.so.6 => /lib/libc.so.6 (0x00110000)
        libgmodule-2.0.so.0 => /lib/libgmodule-2.0.so.0 (0x00da2000)
        libgthread-2.0.so.0 => /lib/libgthread-2.0.so.0 (0x00da8000)
        librt.so.1 => /lib/librt.so.1 (0x00bca000)
        libglib-2.0.so.0 => /lib/libglib-2.0.so.0 (0x00bd5000)
        libxml2.so.2 => /usr/lib/libxml2.so.2 (0x02d3c000)
        liblixab.so.0 => /opt/lixa/lib/liblixab.so.0 (0x00daf000)
        libm.so.6 => /lib/libm.so.6 (0x00b9e000)
        libpthread.so.0 => /lib/libpthread.so.0 (0x00b81000)
        libmqe_r.so => /opt/mqm71/lib/libmqe_r.so (0xb6f70000)
        libdl.so.2 => /lib/libdl.so.2 (0x00b7a000)
        /lib/ld-linux.so.2 (0x009c2000)
        libz.so.1 => /lib/libz.so.1 (0x00ce1000)
        libuuid.so.1 => /lib/libuuid.so.1 (0x0076f000)
	  </screen></td></tr></tbody>
	</table>
      </para>
    </section>
    <section>
      <title>Set-up LIXA environment (SRV mode)</title>
      <para>
	Set-up the <varname>LIXA_PROFILE</varname> environment variable:
	<table frame="box">
	  <thead><tr><td>[Shell terminal session]</td></tr></thead>
	  <tbody><tr><td><screen>
[tiian@centos tmp]$ echo $LIXA_PROFILE

[tiian@centos tmp]$ export LIXA_PROFILE=MQS_DYN
[tiian@centos tmp]$ echo $LIXA_PROFILE
MQS_DYN
	  </screen></td></tr></tbody>
	</table>
      </para>
    </section>
    <section>
      <title>Some checks before program execution (SRV mode)</title>
      <para>
	We set <varname>LIXA_PROFILE</varname> to value
	<quote>MQS_DYN</quote>, looking at
	<filename>/opt/lixa/etc/lixac_conf.xml</filename>:
	<screen>
    &lt;profile name="MQS_DYN"&gt;
      &lt;sttsrvs&gt;
        &lt;sttsrv&gt;local_1&lt;/sttsrv&gt;
      &lt;/sttsrvs&gt;
      &lt;rsrmgrs&gt;
        &lt;rsrmgr&gt;WSMQ_SRV_dynreg&lt;/rsrmgr&gt;
      &lt;/rsrmgrs&gt;
    &lt;/profile&gt;
	</screen>
	the profile references the Resource Manager named
	<quote>WSMQ_SRV_dynreg</quote>, looking again at the config file:
	<screen>
    &lt;rsrmgr name="WSMQ_SRV_dynreg" switch_file="/opt/lixa/lib/switch_wsmq_dynreg.so" xa_open_info="axlib=/opt/lixa/lib/liblixac.so,qmname=LIXA,tpm=lixa" xa_close_info="" /&gt;
	</screen>
	we can discover how the WebSphere MQ Resource Manager is configured 
	for XA
	<footnote><para>
	    The content of <constant>xa_open_info</constant> is passed to
	    <function>xa_open</function> function: you can refer to 
	    WebSphere MQ official
	    documentation to discover what you can pass to this function.
	    Please pay attention the <varname>xa_open_info</varname> can
	    contain a maximum of 255 characters: this limitation is
	    documented in <citation>XAspec</citation>.
	</para></footnote>.
      </para>
    </section>
    <section>
      <title>Program execution (SRV mode)</title>
      <para>
	<table frame="box">
	  <thead><tr><td>[Shell terminal session]</td></tr></thead>
	  <tbody><tr><td><screen>
[tiian@centos tmp]$ ls -la
total 116
drwxrwxr-x 2 tiian tiian  4096 Mar 16 17:04 .
drwx------ 8 tiian tiian  4096 Mar 16 13:10 ..
-rwxrwxr-x 1 tiian tiian  9587 Mar 16 17:04 example12_wmq
-rw-r--r-- 1 tiian tiian  5342 Mar 16 13:13 example12_wmq.c
	  </screen></td></tr></tbody>
	</table>
	Retrieve all the messages from <quote>LIXA.QLOCAL</quote> queue before
	program execution:
	<table frame="box">
	  <thead><tr><td>[Shell terminal session]</td></tr></thead>
	  <tbody><tr><td><screen>
[tiian@centos tmp]$ . /opt/mqm71/bin/setmqenv -s
[tiian@centos tmp]$ /opt/mqm71/samp/bin/amqsget LIXA.QLOCAL LIXA
Sample AMQSGET0 start
no more messages
Sample AMQSGET0 end
	  </screen></td></tr></tbody>
	</table>
	Execute the program:
	<table frame="box">
	  <thead><tr><td>[Shell terminal session]</td></tr></thead>
	  <tbody><tr><td><screen>
[tiian@centos tmp]$ ./example12_wmq insert
target queue is LIXA.QLOCAL
Message inserted in queue LIXA.QLOCAL: 'Test message for LIXA'
	  </screen></td></tr></tbody>
	</table>
	Check the content of the queue:
	<table frame="box">
	  <thead><tr><td>[Shell terminal session]</td></tr></thead>
	  <tbody><tr><td><screen>
[tiian@centos tmp]$ /opt/mqm71/samp/bin/amqsget LIXA.QLOCAL LIXA
Sample AMQSGET0 start
message &lt;Test message for LIXA&gt;
no more messages
Sample AMQSGET0 end
	  </screen></td></tr></tbody>
	</table>
	Now you can try to remove a message inserted with the standard
	utility:
	<table frame="box">
	  <thead><tr><td>[Shell terminal session]</td></tr></thead>
	  <tbody><tr><td><screen>
[tiian@centos tmp]$ /opt/mqm71/samp/bin/amqsput LIXA.QLOCAL LIXA
Sample AMQSPUT0 start
target queue is LIXA.QLOCAL
This is a sample message from the keyboard!

Sample AMQSPUT0 end
[tiian@centos tmp]$ ./example12_wmq delete
target queue is LIXA.QLOCAL
Message retrieved from queue LIXA.QLOCAL: 'This is a sample message from the keyboard!'
	  </screen></td></tr></tbody>
	</table>
	you can verify in file
	<filename>/opt/lixa/etc/lixac_conf.xml</filename>
	that <quote>MQS_DYN</quote> is associated to dynamic registration.
	Execute the program enabling trace:
	<table frame="box">
	  <thead><tr><td>[Shell terminal session]</td></tr></thead>
	  <tbody><tr><td><screen>
[tiian@centos tmp]$ export LIXA_TRACE_MASK=0x00002000
[tiian@centos tmp]$ echo $LIXA_TRACE_MASK
0x00002000
[tiian@centos tmp]$ ./example12_wmq insert 2&gt;&amp;1 | grep ax_reg
2012-03-16 18:36:23.500382 [14774/3078875408] ax_reg: rmid=0, xid=0xbffaf630, flags=0x0
2012-03-16 18:36:23.500581 [14774/3078875408] ax_reg: the application program has started a transaction (TX states S3); this XID '1279875137.846a8fdfe2204b11ac85586a13fc0348.9a910775bb747f3c157021d6a03a7b31' will be returned
2012-03-16 18:36:23.501290 [14774/3078875408] ax_reg: sending 153 bytes to the server for step 8
2012-03-16 18:36:23.501965 [14774/3078875408] ax_reg/excp=7/ret_cod=0/errno=1
	  </screen></td></tr></tbody>
	</table>
	Changing <varname>LIXA_PROFILE</varname> you can try the static
	registration as well:
	<table frame="box">
	  <thead><tr><td>[Shell terminal session]</td></tr></thead>
	  <tbody><tr><td><screen>
[tiian@centos tmp]$ export LIXA_PROFILE=MQS_STA
[tiian@centos tmp]$ echo $LIXA_PROFILE
MQC_STA
[tiian@centos tmp]$ ./example12_wmq delete 2&gt;&amp;1 | grep xa_start
2012-03-16 18:38:08.942458 [14784/3078269200] lixa_xa_start
2012-03-16 18:38:08.942644 [14784/3078269200] lixa_xa_start: sending 213 bytes to the server for step 8
[...]
2012-03-16 18:38:08.946569 [14784/3078269200] lixa_xa_start: xa_start_entry(xid, 0, 0x0) = 0
2012-03-16 18:38:08.947188 [14784/3078269200] lixa_xa_start: sending 210 bytes to the server for step 24
2012-03-16 18:38:08.947521 [14784/3078269200] lixa_xa_start/excp=10/ret_cod=0/errno=1
	  </screen></td></tr></tbody>
	</table>
	To try <function>tx_rollback()</function> you have to slightly 
	change the sample program:
	<table frame="box">
	  <thead><tr><td>[original example12_wmq.c]</td></tr></thead>
	  <tbody><tr><td><screen>
    [...]
    if (TX_OK != (txrc = tx_commit())) {
        fprintf(stderr, "tx_commit error: %d\n", txrc);
        exit(txrc);
    }

    /*
    if (TX_OK != (txrc = tx_rollback())) {
        fprintf(stderr, "tx_rollback error: %d\n", txrc);
        exit(txrc);
    }
    */
    [...]
	  </screen></td></tr></tbody>
	</table>
	move the comment from <function>tx_rollback()</function> function
	block to <function>tx_rollback()</function> function block:
	<table frame="box">
	  <thead><tr><td>[modified example12_wmq.c]</td></tr></thead>
	  <tbody><tr><td><screen>
    [...]
    /*
    if (TX_OK != (txrc = tx_commit())) {
        fprintf(stderr, "tx_commit error: %d\n", txrc);
        exit(txrc);
    }
    */

    if (TX_OK != (txrc = tx_rollback())) {
        fprintf(stderr, "tx_rollback error: %d\n", txrc);
        exit(txrc);
    }
    [...]
	  </screen></td></tr></tbody>
	</table>
	Compile it again and try the modified example:
	<table frame="box">
	  <thead><tr><td>[Shell terminal session]</td></tr></thead>
	  <tbody><tr><td><screen>
[tiian@centos tmp]$ gcc example12_wmq.c $(/opt/lixa/bin/lixa-config -c -f -l -d) \
> -I/opt/mqm71/inc -L/opt/mqm71/lib -Wl,-rpath=/opt/mqm71/lib \
> -lmqm_r -o example12_wmq
	  </screen></td></tr></tbody>
	</table>
	Verify the queue is empty, execute the sample program, verify the
	queue is empty again:
	<table frame="box">
	  <thead><tr><td>[Shell terminal session]</td></tr></thead>
	  <tbody><tr><td><screen>
[tiian@centos tmp]$ unset LIXA_TRACE_MASK
[tiian@centos tmp]$ /opt/mqm71/samp/bin/amqsget LIXA.QLOCAL LIXA
Sample AMQSGET0 start
no more messages
Sample AMQSGET0 end
[tiian@centos tmp]$ ./example12_wmq insert
target queue is LIXA.QLOCAL
Message inserted in queue LIXA.QLOCAL: 'Test message for LIXA'
[tiian@centos tmp]$ /opt/mqm71/samp/bin/amqsget LIXA.QLOCAL LIXA
Sample AMQSGET0 start
no more messages
Sample AMQSGET0 end
	  </screen></td></tr></tbody>
	</table>
	Restore <filename>example12_wmq.c</filename> to the original state.
      </para>
    </section>
    <section>
      <title>Build the client program (ETC mode)</title>
      <para>
	Prepare the client (Application Program) using the below commands
	(<command>gcc</command> command was splitted on 
	several lines using \ to help
	readability, but you may use a single line): 
	<table frame="box">
	  <thead><tr><td>[Shell terminal session]</td></tr></thead>
	  <tbody><tr><td><screen>
[tiian@centos ~]$ mkdir tmp
[tiian@centos ~]$ cd tmp
[tiian@centos tmp]$ cp /opt/lixa/share/doc/lixa-X.Y.Z/examples/example12_wmq.c .
[tiian@centos tmp]$ /opt/lixa/bin/lixa-config -r|grep WebSphereMQ
WebSphereMQ     yes     (ETC)
[tiian@centos tmp]$ gcc example12_wmq.c $(/opt/lixa/bin/lixa-config -c -f -l -d) \
> -I/opt/mqm71/inc -L/opt/mqm71/lib -Wl,-rpath=/opt/mqm71/lib \
> -lmqic_r -o example12_wmq
	  </screen></td></tr></tbody>
	</table>
	Verify the executable produced by <command>gcc</command>:
	<table frame="box">
	  <thead><tr><td>[Shell terminal session]</td></tr></thead>
	  <tbody><tr><td><screen>
[tiian@centos tmp]$ ldd example12_wmq
        linux-gate.so.1 =>  (0x00d50000)
        liblixac.so.0 => /opt/lixa/lib/liblixac.so.0 (0x00dfd000)
        libmqic_r.so => /opt/mqm71/lib/libmqic_r.so (0x0021a000)
        libc.so.6 => /lib/libc.so.6 (0x009e8000)
        libgmodule-2.0.so.0 => /lib/libgmodule-2.0.so.0 (0x00da2000)
        libgthread-2.0.so.0 => /lib/libgthread-2.0.so.0 (0x00da8000)
        librt.so.1 => /lib/librt.so.1 (0x00bca000)
        libglib-2.0.so.0 => /lib/libglib-2.0.so.0 (0x00bd5000)
        libxml2.so.2 => /usr/lib/libxml2.so.2 (0x02d3c000)
        liblixab.so.0 => /opt/lixa/lib/liblixab.so.0 (0x008f3000)
        libm.so.6 => /lib/libm.so.6 (0x00b9e000)
        libpthread.so.0 => /lib/libpthread.so.0 (0x00b81000)
        libmqe_r.so => /opt/mqm71/lib/libmqe_r.so (0x00e16000)
        libdl.so.2 => /lib/libdl.so.2 (0x00b7a000)
        /lib/ld-linux.so.2 (0x009c2000)
        libz.so.1 => /lib/libz.so.1 (0x00ce1000)
        libuuid.so.1 => /lib/libuuid.so.1 (0x0076f000)
	  </screen></td></tr></tbody>
	</table>
      </para>
    </section>
    <section>
      <title>Set-up LIXA environment (ETC mode)</title>
      <para>
	Set-up the <varname>LIXA_PROFILE</varname> environment variable:
	<table frame="box">
	  <thead><tr><td>[Shell terminal session]</td></tr></thead>
	  <tbody><tr><td><screen>
[tiian@centos tmp]$ echo $LIXA_PROFILE

[tiian@centos tmp]$ export LIXA_PROFILE=MQC_DYN
[tiian@centos tmp]$ echo $LIXA_PROFILE
MQC_DYN
	  </screen></td></tr></tbody>
	</table>
      </para>
    </section>
    <section>
      <title>Some checks before program execution (ETC mode)</title>
      <para>
	We set <varname>LIXA_PROFILE</varname> to value
	<quote>MQC_DYN</quote>, looking at
	<filename>/opt/lixa/etc/lixac_conf.xml</filename>:
	<screen>
    &lt;profile name="MQC_DYN"&gt;
      &lt;sttsrvs&gt;
        &lt;sttsrv&gt;local_1&lt;/sttsrv&gt;
      &lt;/sttsrvs&gt;
      &lt;rsrmgrs&gt;
        &lt;rsrmgr&gt;WSMQ_ETC_dynreg&lt;/rsrmgr&gt;
      &lt;/rsrmgrs&gt;
    &lt;/profile&gt;
	</screen>
	the profile references the Resource Manager named
	<quote>WSMQ_ETC_dynreg</quote>, looking again at the config file:
	<screen>
    &lt;rsrmgr name="WSMQ_ETC_dynreg" switch_file="/opt/lixa/lib/switch_wsmq_dynreg.so" xa_open_info="axlib=/opt/lixa/lib/liblixac.so,channel=LIXA.CHANNEL,trptype=tcp,conname=127.0.0.1(1414),qmname=LIXA,tpm=lixa" xa_close_info="" /&gt;
	</screen>
	we can discover how the WebSphere MQ Resource Manager is configured 
	for XA
	<footnote><para>
	    The content of <constant>xa_open_info</constant> is passed to
	    <function>xa_open</function> function: you can refer to 
	    WebSphere MQ official
	    documentation to discover what you can pass to this function.
	    Please pay attention the <varname>xa_open_info</varname> can
	    contain a maximum of 255 characters: this limitation is
	    documented in <citation>XAspec</citation>.
	</para></footnote>.
      </para>
    </section>
    <section>
      <title>Program execution (ETC mode)</title>
      <para>
	<table frame="box">
	  <thead><tr><td>[Shell terminal session]</td></tr></thead>
	  <tbody><tr><td><screen>
[tiian@centos tmp]$ ls -la
total 116
drwxrwxr-x 2 tiian tiian  4096 Mar 16 17:04 .
drwx------ 8 tiian tiian  4096 Mar 16 13:10 ..
-rwxrwxr-x 1 tiian tiian  9587 Mar 16 17:04 example12_wmq
-rw-r--r-- 1 tiian tiian  5342 Mar 16 13:13 example12_wmq.c
	  </screen></td></tr></tbody>
	</table>
	Retrieve all the messages from <quote>LIXA.QLOCAL</quote> queue before
	program execution:
	<table frame="box">
	  <thead><tr><td>[Shell terminal session]</td></tr></thead>
	  <tbody><tr><td><screen>
[tiian@centos tmp]$ . /opt/mqm71/bin/setmqenv -s
[tiian@centos tmp]$ export MQSERVER=LIXA.CHANNEL/TCP/'127.0.0.1(1414)'
[tiian@centos tmp]$ /opt/mqm71/samp/bin/amqsgetc LIXA.QLOCAL LIXA
Sample AMQSGET0 start
no more messages
Sample AMQSGET0 end
	  </screen></td></tr></tbody>
	</table>
	Execute the program:
	<table frame="box">
	  <thead><tr><td>[Shell terminal session]</td></tr></thead>
	  <tbody><tr><td><screen>
[tiian@centos tmp]$ ./example12_wmq insert
target queue is LIXA.QLOCAL
Message inserted in queue LIXA.QLOCAL: 'Test message for LIXA'
	  </screen></td></tr></tbody>
	</table>
	Check the content of the queue:
	<table frame="box">
	  <thead><tr><td>[Shell terminal session]</td></tr></thead>
	  <tbody><tr><td><screen>
[tiian@centos tmp]$ /opt/mqm71/samp/bin/amqsgetc LIXA.QLOCAL LIXA
Sample AMQSGET0 start
message &lt;Test message for LIXA&gt;
no more messages
Sample AMQSGET0 end
	  </screen></td></tr></tbody>
	</table>
	Now you can try to remove a message inserted with the standard
	utility:
	<table frame="box">
	  <thead><tr><td>[Shell terminal session]</td></tr></thead>
	  <tbody><tr><td><screen>
[tiian@centos tmp]$ /opt/mqm71/samp/bin/amqsputc LIXA.QLOCAL LIXA
Sample AMQSPUT0 start
target queue is LIXA.QLOCAL
This is a sample message from the keyboard!

Sample AMQSPUT0 end
[tiian@centos tmp]$ ./example12_wmq delete
target queue is LIXA.QLOCAL
Message retrieved from queue LIXA.QLOCAL: 'This is a sample message from the keyboard!'
	  </screen></td></tr></tbody>
	</table>
	you can verify in file
	<filename>/opt/lixa/etc/lixac_conf.xml</filename>
	that <quote>MQC_DYN</quote> is associated to dynamic registration.
	Execute the program:
	<table frame="box">
	  <thead><tr><td>[Shell terminal session]</td></tr></thead>
	  <tbody><tr><td><screen>
[tiian@centos tmp]$ export LIXA_TRACE_MASK=0x00002000
[tiian@centos tmp]$ echo $LIXA_TRACE_MASK
0x00002000
[tiian@centos tmp]$ ./example12_wmq insert 2&gt;&amp;1 | grep ax_reg
2012-03-16 18:17:06.108362 [2793/3077654800] ax_reg: rmid=0, xid=0xbfb4d59c, flags=0x0
2012-03-16 18:17:06.108566 [2793/3077654800] ax_reg: the application program has started a transaction (TX states S3); this XID '1279875137.70797228836149378b6fd6a315481425.80e88a292250da8f8b2ee3a5959e8650' will be returned
2012-03-16 18:17:06.109221 [2793/3077654800] ax_reg: sending 153 bytes to the server for step 8
2012-03-16 18:17:06.109926 [2793/3077654800] ax_reg/excp=7/ret_cod=0/errno=2
	  </screen></td></tr></tbody>
	</table>
	Changing <varname>LIXA_PROFILE</varname> you can try the static
	registration as well:
	<table frame="box">
	  <thead><tr><td>[Shell terminal session]</td></tr></thead>
	  <tbody><tr><td><screen>
[tiian@centos tmp]$ export LIXA_PROFILE=MQC_STA
[tiian@centos tmp]$ echo $LIXA_PROFILE
MQC_STA
[tiian@centos tmp]$ ./example12_wmq delete 2&gt;&amp;1 | grep xa_start
2012-03-16 18:18:59.302555 [2806/3078256912] lixa_xa_start
2012-03-16 18:18:59.302831 [2806/3078256912] lixa_xa_start: sending 213 bytes to the server for step 8
[...]
2012-03-16 18:18:59.307208 [2806/3078256912] lixa_xa_start: xa_start_entry(xid, 0, 0x0) = 0
2012-03-16 18:18:59.307373 [2806/3078256912] lixa_xa_start: sending 210 bytes to the server for step 24
2012-03-16 18:18:59.308103 [2806/3078256912] lixa_xa_start/excp=10/ret_cod=0/errno=2
	  </screen></td></tr></tbody>
	</table>
      </para>
    </section>
  </section>
  <section xml:id="Development_example13_wmq_mys_pql">
    <title>An example with WebSphere MQ, MySQL and PostgreSQL</title>
    <para>
      The example of this paragraph is quite complex because it involves
      three distinct
      Resource Managers: WebSphere MQ that's a message
      oriented middleware, MySQL and PostgreSQL thar are database servers.
      The proposed example can be easily adapted for WebSphere MQ and MySQL
      or WebSphere MQ and PostgreSQL removing useless stuff.
    </para>
    <para>
      It is strongly suggested you have yet tryed the examples described in
      <xref linkend="Development_example8_mys"/>,
      in <xref linkend="Development_example5_pql"/> and
      in <xref linkend="Development_example12_wmq"/>.
    </para>
    <figure xml:id="develop13">
      <title>Deploy model of an example with WebSphere MQ, MySQL and PostgreSQL</title>
      <mediaobject>
	<imageobject>
	  <imagedata fileref="../images/LIXA_Development_13.png"/>
	</imageobject>
      </mediaobject>
    </figure>
    <section>
      <title>Set-up WebSphere MQ, MySQL, PostgreSQL and LIXA environment</title>
      <para>
	Please follow the instructions explained 
	<itemizedlist mark="bullet">
	  <listitem><para>
	      in <xref linkend="Development_setup_WebSphereMQ_environment"/>
	      to set-up a running environment for WebSphere MQ
	  </para></listitem>
	  <listitem><para>
	      in <xref linkend="Development_setup_MySQL_environment"/>
	      to set-up a running environment for MySQL server
	  </para></listitem>
	  <listitem><para>
	      in <xref linkend="Development_setup_PostgreSQL_environment"/>
	      to set-up a running environment for PostgreSQL server
	  </para></listitem>
	  <listitem><para>
	      in <xref linkend="Development_start_LIXA_server"/>
	      to start up the LIXA state server
	  </para></listitem>
	</itemizedlist>
      </para>
    </section>
    <section>
      <title>Build the client program (SRV mode)</title>
      <para>
	Prepare the client (Application Program) using the below commands
	(<command>gcc</command> command was splitted on 
	several lines using \ to help
	readability, but you may use a single line): 
	<table frame="box">
	  <thead><tr><td>[Shell terminal session]</td></tr></thead>
	  <tbody><tr><td><screen>
[tiian@centos ~]$ mkdir tmp
[tiian@centos ~]$ cd tmp
[tiian@centos tmp]$ cp /opt/lixa/share/doc/lixa-X.Y.Z/examples/example13_wmq_mys_pql.c .
[tiian@centos tmp]$ /opt/lixa/bin/lixa-config -r|grep WebSphereMQ
WebSphereMQ     yes     (SRV)
[tiian@centos tmp]$ gcc example13_wmq_mys_pql.c \
> $(/opt/lixa/bin/lixa-config -c -f -m -p -d) \
> $(mysql_config --include --libs_r) -I/usr/include/postgresql -lpq \
> -I/opt/mqm71/inc -L/opt/mqm71/lib -Wl,-rpath -Wl,/opt/mqm71/lib \
> -lmqm_r -o example13_wmq_mys_pql
	  </screen></td></tr></tbody>
	</table>
	Verify the executable produced by <command>gcc</command>:
	<table frame="box">
	  <thead><tr><td>[Shell terminal session]</td></tr></thead>
	  <tbody><tr><td><screen>
[tiian@centos tmp]$ ldd example13_wmq_mys_pql
        linux-gate.so.1 =>  (0x008bc000)
        liblixac.so.0 => /opt/lixa/lib/liblixac.so.0 (0x00fe3000)
        liblixapq.so.0 => /opt/lixa/lib/liblixapq.so.0 (0x00163000)
        liblixamy.so.0 => /opt/lixa/lib/liblixamy.so.0 (0x00684000)
        libmysqlclient_r.so.16 => /usr/lib/mysql/libmysqlclient_r.so.16 (0x0016a000)
        libz.so.1 => /lib/libz.so.1 (0x00ce1000)
        libpthread.so.0 => /lib/libpthread.so.0 (0x00b81000)
        libcrypt.so.1 => /lib/libcrypt.so.1 (0x05144000)
        libnsl.so.1 => /lib/libnsl.so.1 (0x0524e000)
        libm.so.6 => /lib/libm.so.6 (0x00b9e000)
        libssl.so.10 => /usr/lib/libssl.so.10 (0x053f2000)
        libcrypto.so.10 => /usr/lib/libcrypto.so.10 (0x06344000)
        libpq.so.5 => /usr/lib/libpq.so.5 (0x00110000)
        libmqm_r.so => /opt/mqm71/lib/libmqm_r.so (0x00559000)
        libc.so.6 => /lib/libc.so.6 (0x009e8000)
        libgmodule-2.0.so.0 => /lib/libgmodule-2.0.so.0 (0x00da2000)
        libgthread-2.0.so.0 => /lib/libgthread-2.0.so.0 (0x00da8000)
        librt.so.1 => /lib/librt.so.1 (0x00bca000)
        libglib-2.0.so.0 => /lib/libglib-2.0.so.0 (0x00bd5000)
        libxml2.so.2 => /usr/lib/libxml2.so.2 (0x02d3c000)
        liblixab.so.0 => /opt/lixa/lib/liblixab.so.0 (0x00137000)
        /lib/ld-linux.so.2 (0x009c2000)
        libfreebl3.so => /lib/libfreebl3.so (0x051d0000)
        libgssapi_krb5.so.2 => /lib/libgssapi_krb5.so.2 (0x00950000)
        libkrb5.so.3 => /lib/libkrb5.so.3 (0x064d3000)
        libcom_err.so.2 => /lib/libcom_err.so.2 (0x0090e000)
        libk5crypto.so.3 => /lib/libk5crypto.so.3 (0x00922000)
        libresolv.so.2 => /lib/libresolv.so.2 (0x00d86000)
        libdl.so.2 => /lib/libdl.so.2 (0x00b7a000)
        libldap_r-2.4.so.2 => /lib/libldap_r-2.4.so.2 (0x002e1000)
        libmqe_r.so => /opt/mqm71/lib/libmqe_r.so (0xb708f000)
        libuuid.so.1 => /lib/libuuid.so.1 (0x0076f000)
        libkrb5support.so.0 => /lib/libkrb5support.so.0 (0x00915000)
        libkeyutils.so.1 => /lib/libkeyutils.so.1 (0x00991000)
        liblber-2.4.so.2 => /lib/liblber-2.4.so.2 (0x04e6c000)
        libssl3.so => /usr/lib/libssl3.so (0x055de000)
        libsmime3.so => /usr/lib/libsmime3.so (0x05616000)
        libnss3.so => /usr/lib/libnss3.so (0x05469000)
        libnssutil3.so => /usr/lib/libnssutil3.so (0x055b6000)
        libplds4.so => /lib/libplds4.so (0x055aa000)
        libplc4.so => /lib/libplc4.so (0x053a3000)
        libnspr4.so => /lib/libnspr4.so (0x053b2000)
        libsasl2.so.2 => /usr/lib/libsasl2.so.2 (0x057d8000)
        libselinux.so.1 => /lib/libselinux.so.1 (0x00cc0000)
	  </screen></td></tr></tbody>
	</table>
      </para>
    </section>
    <section>
      <title>Set-up LIXA environment (SRV mode)</title>
      <para>
	Set-up the <varname>LIXA_PROFILE</varname> environment variable:
	<table frame="box">
	  <thead><tr><td>[Shell terminal session]</td></tr></thead>
	  <tbody><tr><td><screen>
[tiian@centos tmp]$ echo $LIXA_PROFILE

[tiian@centos tmp]$ export LIXA_PROFILE=MQS_DYN_MYS_STA_PQL_STA
[tiian@centos tmp]$ echo $LIXA_PROFILE
MQS_DYN_MYS_STA_PQL_STA
	  </screen></td></tr></tbody>
	</table>
      </para>
    </section>
    <section>
      <title>Some checks before program execution (SRV mode)</title>
      <para>
	We set <varname>LIXA_PROFILE</varname> to value
	<quote>MQS_DYN_MYS_STA_PQL_STA</quote>, looking at
	<filename>/opt/lixa/etc/lixac_conf.xml</filename>:
	<screen>
    &lt;profile name="MQS_DYN_MYS_STA_PQL_STA"&gt;
      &lt;sttsrvs&gt;
        &lt;sttsrv&gt;local_1&lt;/sttsrv&gt;
      &lt;/sttsrvs&gt;
      &lt;rsrmgrs&gt;
        &lt;rsrmgr&gt;WSMQ_SRV_dynreg&lt;/rsrmgr&gt;
        &lt;rsrmgr&gt;MySQL_stareg&lt;/rsrmgr&gt;
        &lt;rsrmgr&gt;PostgreSQL_stareg&lt;/rsrmgr&gt;
      &lt;/rsrmgrs&gt;
    &lt;/profile&gt;
	</screen>
	the profile references the three Resource Managers named
	<quote>WSMQ_SRV_dynreg</quote>,	<quote>MySQL_stareg</quote> and 
	<quote>PostgreSQL_stareg</quote>;
	looking again at the config file:
	<screen>
    &lt;rsrmgr name="WSMQ_SRV_dynreg" switch_file="/opt/lixa/lib/switch_wsmq_dynreg.so" xa_open_info="axlib=/opt/lixa/lib/liblixac.so,qmname=LIXA,tpm=lixa" xa_close_info="" /&gt;
    &lt;rsrmgr name="MySQL_stareg" switch_file="/opt/lixa/lib/switch_mysql_stareg.so" xa_open_info="host=localhost,user=lixa,passwd=,db=lixa,client_flag=0" xa_close_info="" /&gt;
    &lt;rsrmgr name="PostgreSQL_stareg" switch_file="/opt/lixa/lib/switch_postgresql_stareg.so" xa_open_info="dbname=testdb" xa_close_info="" /&gt;
	</screen>
	we can discover how the Resource Managers are configured 
	for XA.
      </para>
    </section>
    <section>
      <title>Program execution (SRV mode)</title>
      <para>
	You should open three terminal sessions: one for the execution shell,
	one to check MySQL content and the last one to check PostgreSQL
	content.
      </para>
      <para>
	Check the program is in place, set-up WebSphere MQ environment
	variables (you have previously set-up LIXA environment) and check
	the queue is empty:
	<table frame="box">
	  <thead><tr><td>[Shell terminal session]</td></tr></thead>
	  <tbody><tr><td><screen>
[tiian@centos tmp]$ ls -la
total 136
drwxrwxr-x 2 tiian tiian  4096 Mar 18 07:00 .
drwx------ 8 tiian tiian  4096 Mar 17 17:58 ..
-rwxrwxr-x 1 tiian tiian 11879 Mar 18 07:00 example13_wmq_mys_pql
-rw-rw-r-- 1 tiian tiian  7843 Mar 18 06:59 example13_wmq_mys_pql.c
[tiian@centos tmp]$ . /opt/mqm71/bin/setmqenv -s
[tiian@centos tmp]$ /opt/mqm71/samp/bin/amqsget LIXA.QLOCAL LIXA
Sample AMQSGET0 start
no more messages
Sample AMQSGET0 end
	  </screen></td></tr></tbody>
	</table>
	Prepare a terminal session for MySQL and check the table is empty:
	<table frame="box">
	  <thead><tr><td>[MySQL terminal session]</td></tr></thead>
	  <tbody><tr><td><screen>
[tiian@centos ~]$ mysql -h localhost -u lixa lixa
Reading table information for completion of table and column names
You can turn off this feature to get a quicker startup with -A

Welcome to the MySQL monitor.  Commands end with ; or \g.
Your MySQL connection id is 2
Server version: 5.1.61 Source distribution

Copyright (c) 2000, 2011, Oracle and/or its affiliates. All rights reserved.

Oracle is a registered trademark of Oracle Corporation and/or its
affiliates. Other names may be trademarks of their respective
owners.

Type 'help;' or '\h' for help. Type '\c' to clear the current input statement.

mysql> SELECT * FROM authors;
Empty set (0.00 sec)
	  </screen></td></tr></tbody>
	</table>
	Prepare a terminal session for PostgreSQL and check the table is empty:
	<table frame="box">
	  <thead><tr><td>[PostgreSQL terminal session]</td></tr></thead>
	  <tbody><tr><td><screen>
[tiian@centos ~]$ psql testdb
psql (8.4.9)
Type "help" for help.

testdb=> SELECT * FROM authors;
 id | last_name | first_name
----+-----------+------------
(0 rows)
	  </screen></td></tr></tbody>
	</table>
	OK, now you are ready to produce one message and insert one row in
	each database:
	<table frame="box">
	  <thead><tr><td>[Shell terminal session]</td></tr></thead>
	  <tbody><tr><td><screen>
[tiian@centos tmp]$ ./example13_wmq_mys_pql insert
target queue is LIXA.QLOCAL
Message inserted in queue LIXA.QLOCAL: 'Test message for LIXA'
Inserting a row in MySQL table...
Inserting a row in PostgreSQL table...
	  </screen></td></tr></tbody>
	</table>
	Check the content of MySQL:
	<table frame="box">
	  <thead><tr><td>[MySQL terminal session]</td></tr></thead>
	  <tbody><tr><td><screen>
mysql> SELECT * FROM authors;
+----+-----------+------------+
| id | last_name | first_name |
+----+-----------+------------+
|  1 | Foo       | Bar        |
+----+-----------+------------+
1 row in set (0.00 sec)
	  </screen></td></tr></tbody>
	</table>
	Check the content of PostgreSQL:
	<table frame="box">
	  <thead><tr><td>[PostgreSQL terminal session]</td></tr></thead>
	  <tbody><tr><td><screen>
testdb=> SELECT * FROM authors;
 id | last_name | first_name
----+-----------+------------
  1 | Foo       | Bar
(1 row)
	  </screen></td></tr></tbody>
	</table>
	We are leaving the message in the queue and testing the extraction:
	<table frame="box">
	  <thead><tr><td>[Shell terminal session]</td></tr></thead>
	  <tbody><tr><td><screen>
[tiian@centos tmp]$ ./example13_wmq_mys_pql delete
target queue is LIXA.QLOCAL
Message retrieved from queue LIXA.QLOCAL: 'Test message for LIXA'
Deleting a row from MySQL  table...
Deleting a row from PostgreSQL table...
	  </screen></td></tr></tbody>
	</table>
	There was one message and the sample program picked it up; check the
	content of MySQL:
	<table frame="box">
	  <thead><tr><td>[MySQL terminal session]</td></tr></thead>
	  <tbody><tr><td><screen>
mysql> SELECT * FROM authors;
Empty set (0.00 sec)
	  </screen></td></tr></tbody>
	</table>
	check the content of PostgreSQL:
	<table frame="box">
	  <thead><tr><td>[PostgreSQL terminal session]</td></tr></thead>
	  <tbody><tr><td><screen>
testdb=> SELECT * FROM authors;
 id | last_name | first_name
----+-----------+------------
(0 rows)
	  </screen></td></tr></tbody>
	</table>
	It's time to verify what's happen with 
	<function>tx_rollback()</function> instead of
	<function>tx_commit()</function>; move the comments in the source
	code from:
	<table frame="box">
	  <thead><tr><td>[example13_wmq_mys_pql.c (before)]</td></tr></thead>
	  <tbody><tr><td><screen>
[...]
    if (TX_OK != (txrc = tx_commit())) {
        fprintf(stderr, "tx_commit error: %d\n", txrc);
        exit(txrc);
    }

    /*
    if (TX_OK != (txrc = tx_rollback())) {
        fprintf(stderr, "tx_rollback error: %d\n", txrc);
        exit(txrc);
    }
    */
[...]

	  </screen></td></tr></tbody>
	</table>
	to:
	<table frame="box">
	  <thead><tr><td>[example13_wmq_mys_pql.c (after)]</td></tr></thead>
	  <tbody><tr><td><screen>
[...]
    /*
    if (TX_OK != (txrc = tx_commit())) {
        fprintf(stderr, "tx_commit error: %d\n", txrc);
        exit(txrc);
    }
    */

    if (TX_OK != (txrc = tx_rollback())) {
        fprintf(stderr, "tx_rollback error: %d\n", txrc);
        exit(txrc);
    }
[...]
	  </screen></td></tr></tbody>
	</table>
	and re-compile the program:
	<table frame="box">
	  <thead><tr><td>[Shell terminal session]</td></tr></thead>
	  <tbody><tr><td><screen>
[tiian@centos tmp]$ gcc example13_wmq_mys_pql.c \
> $(/opt/lixa/bin/lixa-config -c -f -m -p -d) \
> $(mysql_config --include --libs_r) -I/usr/include/postgresql -lpq \
> -I/opt/mqm71/inc -L/opt/mqm71/lib -Wl,-rpath -Wl,/opt/mqm71/lib \
> -lmqm_r -o example13_wmq_mys_pql
	  </screen></td></tr></tbody>
	</table>
	Now you are ready to insert again message and row, but the rollback
	will discard the operation:
	<table frame="box">
	  <thead><tr><td>[Shell terminal session]</td></tr></thead>
	  <tbody><tr><td><screen>
[tiian@centos tmp]$ ./example13_wmq_mys_pql insert
target queue is LIXA.QLOCAL
Message inserted in queue LIXA.QLOCAL: 'Test message for LIXA'
Inserting a row in MySQL table...
Inserting a row in PostgreSQL table...
	  </screen></td></tr></tbody>
	</table>
	Check the content of MySQL:
	<table frame="box">
	  <thead><tr><td>[MySQL terminal session]</td></tr></thead>
	  <tbody><tr><td><screen>
mysql> SELECT * FROM authors;
Empty set (0.00 sec)
	  </screen></td></tr></tbody>
	</table>
	it's empty; check the content of PostgreSQL:
	<table frame="box">
	  <thead><tr><td>[PostgreSQL terminal session]</td></tr></thead>
	  <tbody><tr><td><screen>
testdb=> SELECT * FROM authors;
 id | last_name | first_name
----+-----------+------------
(0 rows)
	  </screen></td></tr></tbody>
	</table>
	it's empty; check the content of WebSphere MQ:
	<table frame="box">
	  <thead><tr><td>[Shell terminal session]</td></tr></thead>
	  <tbody><tr><td><screen>
[tiian@centos tmp]$ /opt/mqm71/samp/bin/amqsget LIXA.QLOCAL LIXA
Sample AMQSGET0 start
no more messages
Sample AMQSGET0 end
	  </screen></td></tr></tbody>
	</table>
	it's empty. Now you can restore the comment around
	<function>tx_rollback()</function> instead of
	<function>tx_commit()</function>.
      </para>
      <section>
	<title>Static registration</title>
	<para>
	  If you want to use WebSphere MQ with static registration instead of
	  dynamic registration you will use a different profile:
	  <table frame="box">
	    <thead><tr><td>[Shell terminal session]</td></tr></thead>
	    <tbody><tr><td><screen>
[tiian@centos tmp]$ echo $LIXA_PROFILE

[tiian@centos tmp]$ export LIXA_PROFILE=MQS_STA_MYS_STA_PQL_STA
[tiian@centos tmp]$ echo $LIXA_PROFILE
MQS_STA_MYS_STA_PQL_STA
	    </screen></td></tr></tbody>
	  </table>
	</para>
      </section>
    </section>
    <section>
      <title>Adapting the example to WebSphere MQ Extended Transactional Client (ETC)</title>
      <para>
	To try this example using Extended Transactional Client (ETC) for
	WebSphere MQ, you must change these steps in the sequence
	previously described:
	<itemizedlist mark="bullet">
	  <listitem><para>
	      configure LIXA software using
	      <option>--with-wsmq=ETC</option> option; clean the previous 
	      build (<command>make clean</command>) and install the build
	      (<command>su -c "make install"</command>)
	  </para></listitem>
	  <listitem><para>
	      check the output of 
	      <command>/opt/lixa/bin/lixa-config -r</command>
	      command
	  </para></listitem>
	  <listitem><para>
	      link library <filename>mqic_r</filename> instead of
	      library <filename>mqm_r</filename> to program
	      <filename>example13_wmq_mys_pql</filename>
	  </para></listitem>
	  <listitem><para>
	      set variable <varname>LIXA_PROFILE</varname> to
	      <varname>MQC_DYN_MYS_STA_PQL_STA</varname> (dynamic registration)
	      or to <varname>MQC_STA_MYS_STA_PQL_STA</varname> (static 
	      registration)
	  </para></listitem>
	  <listitem><para>
	      use utilities <command>amqsgetc, amqsputc</command> instead of
	      <command>amqsget, amqsput</command>
	  </para></listitem>
	  <listitem><para>
	      set variable <varname>MQSERVER</varname> to
	      <varname>LIXA.CHANNEL/TCP/'127.0.0.1(1414)'</varname>
	  </para></listitem>
	</itemizedlist>
      </para>
    </section>
  </section>
</chapter>
